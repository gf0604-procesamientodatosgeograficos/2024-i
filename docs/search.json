[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GF0604 Procesamiento de datos geográficos 2024-I",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geográficos mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Escuela de Geografía de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos los conocimientos y habilidades aprendidas. No se requiere de experiencia previa en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://gf0604-procesamientodatosgeograficos.github.io/2024-i/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nAplicar el pensamiento computacional para resolver problemas mediante el lenguaje de programación R.\nUtilizar un enfoque de ciencia de datos para la importación, transformación y visualización de datos.\nDesarrollar soluciones reproducibles a problemas computacionales.\nElaborar gráficos estadísticos con paquetes de R.\nProcesar datos geográficos con paquetes de R.\nDesarrollar aplicaciones interactivas que incluyan visualizaciones como tablas, gráficos estadísticos y mapas, entre otras.\n\n\n\nPrograma\nLos siguientes documentos contienen el programa del curso, para los grupos 001 y 002, según el formato definido por la Escuela de Geografía de la Universidad de Costa Rica.\n\nGrupo 001\nGrupo 002\n\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el primer lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2023-I\n2022-I\n2021-I\n2020-I\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso en el formato especificado por la Comisión de Docencia de la Escuela de Geografía:\nGrupo 001\nGrupo 002",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion_computadoras_ciencia_datos.html",
    "href": "parte-i-introduccion-programacion_computadoras_ciencia_datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Arquitectura de computadoras, pensamiento computacional y lenguajes de programación\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#resumen",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#resumen",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "Descomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#trabajo-previo",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#trabajo-previo",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas y videos\nCS50 (Director). (2024). CS50x 2024—Lecture 0—Scratch. https://www.youtube.com/watch?v=3LPJfIKxwWc\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-l",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-l",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.3 Características generales de l",
    "text": "1.3 Características generales de l\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. Los programas reciben entradas, las procesan y generan salidas.\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida.\n\n\n\n\nAl programar una computadora, se puede modificar su funcionamiento sin alterar sus componentes físicos"
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-las-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-las-computadoras",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.3 Características generales de las computadoras",
    "text": "1.3 Características generales de las computadoras\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones, entre los que pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un valor está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. por medio del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresarla en una secuencia de pasos claramente definidos. Estas secuencias se denominan algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como algunas recetas de cocina o tan complejos como los que se utilizan en aprendizaje automático.\nUn algoritmo debe cumplir con algunas características:\n\nDebe recibir entradas: datos que los que trabaja.\nDebe generar salidas: datos generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, los diagramas de flujo o simplemente como una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Se lee la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, se despliega la hilera de texto \"Lista vacía\" \n   y se concluye el proceso. Si no, se continúa con el paso 3.\n3. Se designa el primer elemento de la lista como \"máximo actual\".\n4. Se recorre la lista y se compara cada uno de los elementos con el máximo actual.\n5. Si un elemento comparado es mayor que el máximo actual, \n   entonces pasa a ser el nuevo máximo actual.\n6. El valor máximo de la lista es el máximo actual \n   cuando termina de recorrerse la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.2, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual.\nSi un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nEl valor máximo de la lista es el máximo actual cuando termina de recorrerse la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida describe la estructura básica de un algoritmo o de un programa de computación. De acuerdo con este modelo, un programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura.\n\nEntradas: \\(masa\\) (kg), \\(estatura\\) (m)\n\nProcesamiento: \\(imc = masa/estatura^2\\)\n\nSalida: \\(imc\\)\n\nA manera de ejercicio, calcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Sin embargo, son entidades independientes. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjecute los programas anteriores en:\n\nAmbiente de ejecución en línea de Python\nAmbiente de ejecución en línea de R",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "1.1 Resumen\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. La capacidad que tienen las computadoras de ser programadas permite modificar sus funcionamiento sin necesidad de alterar sus componentes físicos, lo que permite que ayuden a resolver una gran cantidad de problemas. Las secuencias de pasos describen la solución a un problema se denominan algoritmos. En un algoritmo recibe datos de entrada, los procesa y genera salidas. Un algoritmo puede ser implementado en diferentes lenguajes de programación.\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips. Los circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los circuitos integrados de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la teoría de la información y del álgebra booleana.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Sus componentes principales son la memoria principal, la unidad central de procesamiento (CPU) y los sistemas de entrada y salida.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por la CPU de una computadora. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Debido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales y otros.\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#arquitectura-de-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#arquitectura-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.4 Arquitectura de computadoras",
    "text": "1.4 Arquitectura de computadoras\nEn esta sección, se explican los principales componentes de las computadoras modernas. Se realiza un recorrido por algunos de los principales antecedentes históricos de su evolución y se detallan los componentes de la arquitectura de von Neumann, el modelo de arquitectura más utilizado en la actualidad.\n\n1.4.1 Evolución histórica\n\n1.4.1.1 Calculadoras mecánicas\nDurante el siglo XVII, varios matemáticos construyeron calculadoras mecánicas capaces de realizar operaciones aritméticas.\nAlrededor de 1645, el filósofo y matemático francés Blaise Pascal (1623-1662) inventó la Pascalina, una calculadora compuesta por ruedas y engranajes que podía sumar y restar. Pascal la creó con el propósito de ayudar a su padre, quien era contador en la Hacienda francesa y necesitaba una herramienta para realizar cálculos de aritmética comercial de manera más eficiente. La Pascalina podía sumar hasta tres partes en una sola operación, llegando al valor de 999 999.\nEn 1672, el científico alemán Gottfried Leibniz (1646 - 1716) extendió las ideas de Pascal e introdujo la Stepped Reckoner o máquina de Leibniz, un dispositivo que, además de sumar y restar, podía multiplicar, dividir y calcular raíces cuadradas. La máquina de Leibniz estaba basada en un dispositivo llamado rueda de Leibniz, un tambor con forma de cilindro, con un conjunto de dientes de longitud incremental a la que se le acopla una rueda de conteo. La Figura 1.2 muestra una réplica de la máquina de Leibniz.\n\n\n\n\n\n\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\n\n\n\nEl objetivo de Leibniz era realizar cálculos de una manera “fácil, rápida y fiable”. También pretendía que los números calculados pudieran ser tan grandes como se deseara, si el tamaño de la máquina era ajustado. Sin embargo, las primeras versiones de la rueda de Leibniz no eran fiables debido a que tenían piezas mecánicas que tendían a trabarse y a fallar.\nLos derivados de las calculadoras mecánicas creadas por Pascal y Leibniz continuaron siendo producidos durante tres siglos, hasta que a principios de los años 1970 sus equivalentes electrónicos finalmente llegaron a ser fácilmente disponibles y baratos.\n\n\n1.4.1.2 La máquina analítica de Babbage\nEn la primera mitad del siglo XIX, el matemático británico Charles Babbage (1791 - 1871) diseñó la máquina analítica, una computadora mecánica que incorporaba algunas características de las computadoras modernas. Fue inicialmente descrita en 1837, aunque Babbage continuó refinando el diseño hasta su muerte en 1871. Es considerada la primera computadora programable de la historia. La máquina analítica de Babbage se muestra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\n\n\n\nAunque nunca fue terminada debido a limitaciones técnicas y económicas, su diseño revolucionario permitía realizar cálculos complejos y programarla para diversas tareas. Utilizaba tarjetas perforadas para la entrada de datos, disponía de una unidad aritmética para realizar operaciones matemáticas y una memoria capaz de almacenar hasta 1000 números. El lenguaje de programación que sería utilizado era similar a los actuales lenguajes ensambladores. Era posible implementar ciclos y condicionales de manera que el lenguaje propuesto habría sido Turing-completo.\nEn 1843, la matemática británica Ada Lovelace (1815 - 1852) tradujo al inglés una descripción de la máquina analítica escrita en francés un año antes por el matemático italiano Luigi Menabrea (1809 - 1896). Entre las notas que acompañan la traducción, Lovelace incluyó el detalle de los pasos mediante los cuales la máquina podría calcular los números de Bernoulli, lo que se considera por algunos el primer programa de computadoras de la historia. El diagrama correspondiente a este algoritmo/programa se muestra en la Figura 1.4.\n\n\n\n\n\n\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\n\n\n\nAhora se cree que el autor de este programa fue probablemente el mismo Charles Babbage, que ya había desarrollado trabajos similares entre seis y siete años antes de la publicación del artículo de Lovelace.\nEl aporte de Ada Lovelace fue de suma importancia para la computación, ya que fue la primera en reconocer la capacidad de las máquinas para ir más allá de los simples cálculos de números. Acertadamente, anticipó que en el futuro podrían hacer muchas otras cosas, como componer música o generar gráficos. En sus notas, Lovelace enfatizó la diferencia entre la máquina analítica y las máquinas de cálculo previas, en particular su capacidad de ser programada para resolver problemas de mayor complejidad.\n\n\n1.4.1.3 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.5 muestra una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\n\n\n\nUna máquina de Turing está compuesta por:\n\nUna cinta: actúa como memoria de la máquina. Se compone de celdas, cada una de las cuales puede contener un símbolo (ej. una letra, un número).\nUna cabeza lectora/escritora: lee y escribe símbolos en la cinta.\nUn conjunto de estados: entre los cuales la máquina puede cambiar en respuesta a lo que lee en la cinta. Hay un estado inicial desde el cual el funcionamiento de la máquina comienza, y uno o más estados de parada que indican que la máquina ha terminado su computación.\nUna tabla de acciones: indica para combinación de estado actual y símbolo leído en la cinta, qué acción debe realizar la máquina. Estas acciones incluyen leer o escribir un símbolo en la cinta, mover la cabeza lectora/escritora a la izquierda o a la derecha sobre la cinta y cambiar a un nuevo estado.\n\nCon este esquema, una máquina de Turing puede ejecutar cualquier algoritmo. El modelo de Turing demostró que una máquina simple podía resolver cualquier problema computable, si cuenta con el tiempo y los recursos necesarios. Si un sistema (ej. una computadora, un lenguaje de programación) puede utilizarse para resolver cualquier problema de cómputo, se dice que es Turing-completo. No todos los sistemas o lenguajes de programación son Turing-completos, ya que algunos están diseñados para propósitos específicos y pueden tener restricciones que limitan su capacidad de cálculo.\nAllan Turing es considerado uno de los padres de la computación moderna. Sus contribuciones fueron fundamentales en el desarrollo de la teoría de la computación y la inteligencia artificial. En esta última área, Turing propuso un experimento para determinar si una máquina puede exhibir inteligencia equivalente a la de un ser humano. Este experimento, conocido como Prueba de Turing, sigue siendo una referencia en el debate sobre la inteligencia artificial.\n\n\n1.4.1.4 Primeras computadoras electrónicas\nCon base en las ideas de Turing, las computadoras de tipo Bombe y Colossus fueron construídas durante la II Guerra Mundial (1939 - 1945) en el Reino Unido para descifrar mensajes codificados. A pesar de que se consideran de las primeras computadoras digitales electrónicas programables, su programación se realizaba a través de componentes de hardware, como interruptores y enchufes, y no con un programa almacenado en la memoria. La Figura 1.6 muestra una computadora Colossus.\n\n\n\n\n\n\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\n\n\n\nTambién durante la II Guerra Mundial, el ejército de Estados Unidos de América construyó ENIAC (Electronic Numerical Integrator and Computer) para calcular tablas de tiro de artillería. Es considerada por algunos como la primera computadora programable digital de propósito general. Era capaz de seguir el modelo de la máquina de Turing, por lo que era Turing-completa. La Figura 1.7 presenta una imagen de ENIAC.\n\n\n\n\n\n\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\n\n\n\n\n\n\n1.4.2 La arquitectura de von Neumann\nEn 1945, el matemático húngaro - estadounidense John von Neumann (1903 - 1957) propuso un concepto conocido como programa almacenado según el cual los datos y los programas de una computadora se almacenan en una estructura llamada memoria, separada de los componentes que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Su esquema se muestra en la Figura 1.8.\n\n\n\n\n\n\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\nLos principales componentes de esta arquitectura son:\n\nMemoria principal. Almacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como Random Access Memory (Memoria de Acceso Aleatorio) o RAM, ya que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\nUnidad central de procesamiento. Llamada en inglés Central Processing Unit (CPU), se encarga de ejecutar las instrucciones de los programas. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros para almacenar los operandos y el resultado de las instrucciones. Está compuesta por dos partes principales:\n\nUnidad de control. Determina cuál es la siguiente instrucción a ejecutar.\nUnidad de aritmética y lógica. Llamada en inglés Arithmetic and Logic Unit (ALU), ejecuta las operaciones aritméticas y lógicas.\n\nSistemas de entrada y salida. Permiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\n1.4.3 Sistemas binarios\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips, como el que se muestra en la Figura 1.9.\n\n\n\n\n\n\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\n\n\n\nLos circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria, lo que significa que puede tener dos valores. Para representar estos dos valores internamente, las computadoras emplean dos niveles de tensión eléctrica: bajo (o ausencia de tensión) y alto (o presencia de tensión eléctrica). Estos estados se representan respectivamente con 0 y 1 (o viceversa). Este es un sistema binario y cada dígito binario se denomina bit (binary digit). Los bits se agrupan en grupos de ocho llamados bytes) para representar elementos de información más complejos, como números más grandes o carácteres de texto. Por ejemplo:\n\nEl número decimal 14 se representa en binario como 1110:\n1110 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 = 8 + 4 + 2 + 0 = 14\nLa palabra bit se representa en código ASCII como:\n01100010 01101001 01110100 = bit\n\nDe manera similar, se pueden representar otras clases de información, como imágenes, sonidos o videos, mediante secuencias de dígitos binarios.\n\n1.4.3.1 Ventajas\nEl uso de dos estados (en lugar de diez, doce u otra cantidad) facilita la aplicación de la teoría de la información, el estudio matemático de la cuantificación, almacenamiento y comunicación de la información, en el cual los bits son la unidad fundamental. La teoría de la información fue proṕuesta por el matemático estadounidense Claude Shannon (1916 - 2001) en la década de 1940.\nEl álgebra booleana, un pilar fundamental en el campo del análisis y diseño de sistemas digitales, así como en la programación de computadoras, también utiliza dos posibles valores: verdadero (1) y falso (0). Fue introducida en 1847 por el matemático británico George Boole (1815 - 1864). El álgebra booleana utiliza operaciones lógicas como AND (y), OR (o) y NOT (no) para combinar y transformar valores booleanos (verdaderos y falsos).\nPor otra parte, es más fácil diseñar y fabricar dispositivos electrónicos que solo necesitan reconocer dos estados. Por esta razón, los circuitos que manejan señales binarias pueden ser más simples, más confiables y menos costosos que aquellos que tendrían que manejar múltiples estados.\n\n\n\n1.4.4 Lenguaje máquina\nEl lenguaje máquina es un conjunto de instrucciones binarias (compuestas por unos y ceros) interpretables por un CPU. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Este es el único lenguaje que “entienden” directamente las computadoras.\nEl lenguaje máquina, siendo el más bajo nivel de lenguaje de programación y directamente entendible por el hardware del procesador, incluye varios tipos de instrucciones esenciales para la operación de una computadora. Estas instrucciones varían según la arquitectura del procesador (ej. x86, ARM, MIPS), pero generalmente se pueden agrupar en categorías como, por ejemplo:\n\nInstrucciones de aritmética y lógica. Realizan operaciones matemáticas básicas como suma, resta, multiplicación y división, así como operaciones lógicas como AND, OR y NOT.\nInstrucciones de manipulación de datos. Permiten el movimiento de datos dentro de la CPU o entre la CPU y la memoria. Ejemplos incluyen la carga (load) de datos desde la memoria al registro, almacenamiento (store) de datos del registro a la memoria, y transferencias de datos entre registros.\nInstrucciones de entrada/salida. Facilitan la comunicación entre la CPU y los dispositivos de entrada/salida, como discos duros, teclados, pantallas y otros.\nInstrucciones de comparación. Comparan valores y, a menudo, se usan junto con las instrucciones de control de flujo (ej. condicionales, ciclos) para tomar decisiones basadas en estas comparaciones.\nInstrucciones de operación de punto flotante. Específicas para el procesamiento de números de punto flotante, permiten realizar operaciones aritméticas sobre estos números, que son fundamentales para el cálculo científico y la ingeniería.\n\nCada instrucción en el lenguaje máquina se representa como una secuencia de bits, y el conjunto específico de instrucciones que un procesador puede ejecutar se conoce como su conjunto de instrucciones o Instruction Set Architecture (ISA).\nLa Figura 1.10 muestra una instrucción en lenguaje máquina que suma los contenidos de los registros 1 y 2 y almacena el resultado en el registro 6 de un CPU:\n\n\n\n\n\n\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\n\n\n\nLa Figura 1.11 muestra el programa Hola mundo (Hello World) en lenguaje máquina. Este programa simplemente imprime la hilera de texto “Hola mundo”, usualmente en la pantalla, y suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico.\n\n\n\n\n\n\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-modelo-entrada---procesamiento---salida",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-modelo-entrada---procesamiento---salida",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.4 El modelo Entrada - Procesamiento - Salida",
    "text": "1.4 El modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida describe la estructura básica de un algoritmo o de un programa de computación. De acuerdo con este modelo, un programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura.\n\nEntradas: \\(masa\\) (kg), \\(estatura\\) (m)\n\nProcesamiento: \\(imc = masa/estatura^2\\)\n\nSalida: \\(imc\\)\n\nA manera de ejercicio, calcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#la-máquina-de-turing",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#la-máquina-de-turing",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.5 La máquina de Turing",
    "text": "1.5 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.4 presenta una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.4: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#lenguajes-de-programación",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#lenguajes-de-programación",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.5 Lenguajes de programación",
    "text": "1.5 Lenguajes de programación\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. A manera de ejemplo, seguidamente se muestra el programa “Hola mundo” en varios lenguajes de programación:\nLenguaje C\n/* Hola mundo en lenguaje C */\n\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(\"Hola mundo\\n\");\n}\nLenguaje Python\n# Hola mundo en lenguaje Python\n\nprint(\"Hola mundo\")\nLenguaje R\n# Hola mundo en lenguaje R\n\ncat(\"Hola mundo\\n\")\nEl sitio web The Hello World Collection presenta el programa “Hola mundo” en más de 600 lenguajes de programación. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#pensamiento-computacional",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#pensamiento-computacional",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.6 Pensamiento computacional",
    "text": "1.6 Pensamiento computacional\nComo se ha mencionado, utilizamos computadoras porque nos ayudan a resolver problemas. La forma de solucionar un problema debe expresarse de manera que pueda ser implementada en una computadora: mediante programación (vea la Figura 1.12).\n\n\n\n\n\n\nFigura 1.12: Resolución de problemas mediante computadoras.\n\n\n\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Puede ser aplicado en otras áreas. Se considera una de las destrezas fundamentales del siglo XXI.\n\n1.6.1 Principios fundamentales\nEl pensamiento computacional tiene cuatro principios fundamentales:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes de un problema a resolver, con problemas ya resueltos.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.3 Conceptos fundamentales sobre programación de computadoras",
    "text": "1.3 Conceptos fundamentales sobre programación de computadoras\nEn esta sección, se detallan algunos conceptos básicos sobre programación de computadoras, incluyendo los algoritmos y el modelo Entrada - Procesamiento - Salida.\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones entre los que, por ejemplo, pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un elemento está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos (ej. listas, vectores, matrices) o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresar esta solución en una secuencia de pasos claramente definidos. A estas secuencias se les denomina algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como una receta de cocina o tan complejo como los que se utilizan en aprendizaje automático (machine learning).\nUn algoritmo debe cumplir con ciertas características básicas:\n\nRecibir entradas: datos con los que trabaja.\nGenerar salidas: resultados generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, un diagrama de flujo o simplemente una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Lea la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, despliegue la hilera de texto \"Lista vacía\" \n   y concluya el algoritmo. Si no, continúe con el paso 3.\n3. Designe el primer elemento de la lista como \"máximo actual\".\n4. Recorra la lista y compare cada uno de los elementos con el máximo actual.\n   4.1. Si un elemento comparado es mayor que el máximo actual, \n        entonces desígnelo como el nuevo máximo actual.\n5. Al finalizar el recorrido de la lista, imprima el máximo actual\n   como valor máximo de la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.6, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual. 4.1. Si un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nAl finalizar el recorrido de la lista, se imprime el máximo actual como valor máximo de la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\nNote además que el algoritmo incluye:\n\nLectura de entradas: la lista.\n\nProcesamiento de las entradas: recorrido de la lista y comparaciones entre sus elementos.\n\nGeneración de salidas: el valor máximo de la lista.\n\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida (Input - Process - Output o IPO) describe la estructura básica de un algoritmo o de un programa de cómputo. Es un concepto fundamental en computación que describe el flujo de trabajo básico que emplean los sistemas para procesar información o datos. De acuerdo con este modelo, un algoritmo o programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nA continuación se describen los componentes del modelo:\n\nEntrada (Input): consiste de datos o información que recibe el sistema. Pueden venir en diversas formas, como señales electrónicas, datos tecleados por un usuario o archivos, entre otros. La calidad y precisión de la entrada pueden afectar significativamente el resultado final del proceso.\nProcesamiento (Process): Una vez que los datos de entrada son recibidos, el sistema los procesa de acuerdo con un conjunto de instrucciones o pasos. El procesamiento puede involucrar operaciones como cálculos matemáticos, operaciones lógicas, transformaciones o cualquier otra acción necesaria para generar la salida que se requiere. En este componente es usualmente donde se realiza el “trabajo” principal del sistema.\nSalida (Output): Una vez finalizado el procesamiento, el sistema genera una salida. La salida es el resultado del proceso y puede presentarse en varias formas, como una visualización en pantalla, un archivo o un documento impreso, entre otras posibilidades. La salida puede ser el final del algoritmo o programa o puede servir como entrada para otro algoritmo o programa.\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura. El IMC necesita dos entradas: masa (en kilogramos) y estatura (en metros). El procesamiento se realiza mediante la fórmula: imc = imc = masa/estatura2.\nEntonces, un posible algoritmo para calcular el IMC de una persona es:\n\nLea la masa y la estatura de la persona.\nCalcule el imc mediante la fórmula: imc = masa/estatura2.\nImprima el imc.\n\nEjercicios\nCalcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjercicios\n\nEjecute los programas anteriores en R y Python en los siguientes ambientes de ejecución en línea. Solamente debe copiar cada programa en el espacio destinado para ese fin y presionar el botón Run (ejecutar, correr).\n\nAmbiente de ejecución en línea para Python\nAmbiente de ejecución en línea para R\n\nCon base en la descripción del IMC brindada en la sección anterior, elabore una hoja electrónica que calcule el IMC para 10 personas. Considere como incluir los componentes de entrada, procesamiento y salida.\nCon base en el algoritmo descrito en la sección para el cálculo del IMC, elabore un programa en Python y otro programa en R que calculen el IMC de una persona.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-lenguaje-de-programación-scratch",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-lenguaje-de-programación-scratch",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.7 El lenguaje de programación Scratch",
    "text": "1.7 El lenguaje de programación Scratch\nScratch es un lenguaje de programación orientado a educación. Su nombre proviene de la palabra en ingés scratching. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita. Es software libre que se comparte mediante una licencia GPLv2.\n\n1.7.1 Aplicación de los principios del pensamiento computacional\n\nIngrese a la sitio web de Scratch en la dirección https://scratch.mit.edu/ y presione el botón Start Creating o Empiezo a crear para iniciar un proyecto (para este curso, no es necesario crear un usuario en el sitio). Se desplegará el ambiente de programación de Scratch.\n\n\n\n\n\n\n\nFigura 1.13: Ambiente de programación de Scratch.\n\n\n\nEl ambiente de programación de Scratch está compuesto por varias zonas. Seguidamente se describen algunas de las principales:\n\nUn área de bloques, a la izquierda de la pantalla, los cuales ejecutan tareas: mover, girar, ir a, etc. Estos bloques se agrupan en secciones: Movimiento, Apariencia, Sonido, etc.\nUn área en el centro de la pantalla al que pueden arrastrarse los bloques con el ratón para unirse y acoplarse.\nUn área en la parte superior derecha de la pantalla en la que se despliega el resultado de las tareas ejecutadas por los bloques.\nUn botón ubicado en la esquina inferior izquierda de la pantalla llamado Agregar Extensión. En el contexto de Scratch, una extensión es un grupo de tareas adicional a los bloques que se despliegan por defecto. Las extensiones pueden ser desarrolladas por programadores diferentes a los creadores de Scratch.\n\nNota: si lo desea, puede cambiar el idioma a español, u otro de su preferencia, con la opción de menú Settings - Language.\n\nCon el bloque decir de la sección Apariencia, programe el programa “Hola Mundo” en Scratch. Utilice el evento al presionar de la sección Eventos para poder ejecutar el programa al presionar la bandera de salida.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Código fuente\n\n\n\n\n\n\n\n\n\n\n\n(b) Salida\n\n\n\n\n\n\n\nFigura 1.14: Programa “Hola mundo”\n\n\n\nCon la opción de menú Archivo - Guardar en tu computador, guarde el programa en un archivo. Puede cargarlo con la opción de menú Archivo - Subir desde tu computador.\n\nProblema a resolver: dibujar un paisaje como el que se muestra en la figura de abajo.\n\n\n\n\n\n\n\nFigura 1.15: Paisaje.\n\n\n\nPara comenzar, dibuje un par de casas. Se sugiere agregar la extensión Lápiz y bloques como bajar lápiz, subir lápiz, borrar todo, mover, girar, ir a, apuntar en dirección y cualquier otro que le sea útil.\n\n1.7.1.1 Descomposición\nDivisión de un problema en subproblemas más pequeños\n\nIdentifique subproblemas en los que se pueda dividir el problema general (ej. figuras geométricas) y agrupe los bloques correspondientes a cada subproblema.\nPara cada subproblema, cree un bloque nuevo con Crear un bloque en la sección Mis bloques.\nUtilice estructuras de control como repetir en la sección Control para realizar tareas repetitivas.\n\n\n\n1.7.1.2 Reconocimiento de patrones\nBúsqueda de similitudes de un problema a resolver, con problemas ya resueltos\n\nBusque problemas conocidos similares a los que está resolviendo (ej. dibujos de figuras geométricas) y aplique las soluciones.\n\n\n\n1.7.1.3 Abstracción\nFiltrado de la información que se necesita y de la que no se necesita para resolver un problema.\n\nIdentifique los elementos de información que necesita para resolver los subproblemas que ha identificado (ej. tamaños, ángulos). Trate de usarlos como entrada de los bloques que creó.\n\n\n\n1.7.1.4 Algoritmos\nDescripción, paso por paso, de la solución a un problema.\n\nDescriba un algoritmo para la solución al problema.\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.\nFigura 1.12: Resolución de problemas mediante computadoras.\nFigura 1.13: Ambiente de programación de Scratch.\nFigura 1.15: Paisaje.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "1.1 Resumen\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. La capacidad que tienen las computadoras de ser programadas permite modificar sus funcionamiento sin necesidad de alterar sus componentes físicos, lo que permite que ayuden a resolver una gran cantidad de problemas. Las secuencias de pasos describen la solución a un problema se denominan algoritmos. En un algoritmo recibe datos de entrada, los procesa y genera salidas. Un algoritmo puede ser implementado en diferentes lenguajes de programación.\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips. Los circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los circuitos integrados de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la teoría de la información y del álgebra booleana.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Sus componentes principales son la memoria principal, la unidad central de procesamiento (CPU) y los sistemas de entrada y salida.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por la CPU de una computadora. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Debido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales y otros.\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#resumen",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#resumen",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "Descomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#trabajo-previo",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#trabajo-previo",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas y videos\nCS50 (Director). (2024). CS50x 2024—Lecture 0—Scratch. https://www.youtube.com/watch?v=3LPJfIKxwWc\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.3 Conceptos fundamentales sobre programación de computadoras",
    "text": "1.3 Conceptos fundamentales sobre programación de computadoras\nEn esta sección, se detallan algunos conceptos básicos sobre programación de computadoras, incluyendo los algoritmos y el modelo Entrada - Procesamiento - Salida.\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones entre los que, por ejemplo, pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un elemento está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos (ej. listas, vectores, matrices) o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresar esta solución en una secuencia de pasos claramente definidos. A estas secuencias se les denomina algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como una receta de cocina o tan complejo como los que se utilizan en aprendizaje automático (machine learning).\nUn algoritmo debe cumplir con ciertas características básicas:\n\nRecibir entradas: datos con los que trabaja.\nGenerar salidas: resultados generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, un diagrama de flujo o simplemente una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Lea la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, despliegue la hilera de texto \"Lista vacía\" \n   y concluya el algoritmo. Si no, continúe con el paso 3.\n3. Designe el primer elemento de la lista como \"máximo actual\".\n4. Recorra la lista y compare cada uno de los elementos con el máximo actual.\n   4.1. Si un elemento comparado es mayor que el máximo actual, \n        entonces desígnelo como el nuevo máximo actual.\n5. Al finalizar el recorrido de la lista, imprima el máximo actual\n   como valor máximo de la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.6, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual. 4.1. Si un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nAl finalizar el recorrido de la lista, se imprime el máximo actual como valor máximo de la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\nNote además que el algoritmo incluye:\n\nLectura de entradas: la lista.\n\nProcesamiento de las entradas: recorrido de la lista y comparaciones entre sus elementos.\n\nGeneración de salidas: el valor máximo de la lista.\n\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida (Input - Process - Output o IPO) describe la estructura básica de un algoritmo o de un programa de cómputo. Es un concepto fundamental en computación que describe el flujo de trabajo básico que emplean los sistemas para procesar información o datos. De acuerdo con este modelo, un algoritmo o programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nA continuación se describen los componentes del modelo:\n\nEntrada (Input): consiste de datos o información que recibe el sistema. Pueden venir en diversas formas, como señales electrónicas, datos tecleados por un usuario o archivos, entre otros. La calidad y precisión de la entrada pueden afectar significativamente el resultado final del proceso.\nProcesamiento (Process): Una vez que los datos de entrada son recibidos, el sistema los procesa de acuerdo con un conjunto de instrucciones o pasos. El procesamiento puede involucrar operaciones como cálculos matemáticos, operaciones lógicas, transformaciones o cualquier otra acción necesaria para generar la salida que se requiere. En este componente es usualmente donde se realiza el “trabajo” principal del sistema.\nSalida (Output): Una vez finalizado el procesamiento, el sistema genera una salida. La salida es el resultado del proceso y puede presentarse en varias formas, como una visualización en pantalla, un archivo o un documento impreso, entre otras posibilidades. La salida puede ser el final del algoritmo o programa o puede servir como entrada para otro algoritmo o programa.\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura. El IMC necesita dos entradas: masa (en kilogramos) y estatura (en metros). El procesamiento se realiza mediante la fórmula: imc = imc = masa/estatura2.\nEntonces, un posible algoritmo para calcular el IMC de una persona es:\n\nLea la masa y la estatura de la persona.\nCalcule el imc mediante la fórmula: imc = masa/estatura2.\nImprima el imc.\n\nEjercicios\nCalcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjercicios\n\nEjecute los programas anteriores en R y Python en los siguientes ambientes de ejecución en línea. Solamente debe copiar cada programa en el espacio destinado para ese fin y presionar el botón Run (ejecutar, correr).\n\nAmbiente de ejecución en línea para Python\nAmbiente de ejecución en línea para R\n\nCon base en la descripción del IMC brindada en la sección anterior, elabore una hoja electrónica que calcule el IMC para 10 personas. Considere como incluir los componentes de entrada, procesamiento y salida.\nCon base en el algoritmo descrito en la sección para el cálculo del IMC, elabore un programa en Python y otro programa en R que calculen el IMC de una persona.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#arquitectura-de-computadoras",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#arquitectura-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.4 Arquitectura de computadoras",
    "text": "1.4 Arquitectura de computadoras\nEn esta sección, se explican los principales componentes de las computadoras modernas. Se realiza un recorrido por algunos de los principales antecedentes históricos de su evolución y se detallan los componentes de la arquitectura de von Neumann, el modelo de arquitectura más utilizado en la actualidad.\n\n1.4.1 Evolución histórica\n\n1.4.1.1 Calculadoras mecánicas\nDurante el siglo XVII, varios matemáticos construyeron calculadoras mecánicas capaces de realizar operaciones aritméticas.\nAlrededor de 1645, el filósofo y matemático francés Blaise Pascal (1623-1662) inventó la Pascalina, una calculadora compuesta por ruedas y engranajes que podía sumar y restar. Pascal la creó con el propósito de ayudar a su padre, quien era contador en la Hacienda francesa y necesitaba una herramienta para realizar cálculos de aritmética comercial de manera más eficiente. La Pascalina podía sumar hasta tres partes en una sola operación, llegando al valor de 999 999.\nEn 1672, el científico alemán Gottfried Leibniz (1646 - 1716) extendió las ideas de Pascal e introdujo la Stepped Reckoner o máquina de Leibniz, un dispositivo que, además de sumar y restar, podía multiplicar, dividir y calcular raíces cuadradas. La máquina de Leibniz estaba basada en un dispositivo llamado rueda de Leibniz, un tambor con forma de cilindro, con un conjunto de dientes de longitud incremental a la que se le acopla una rueda de conteo. La Figura 1.2 muestra una réplica de la máquina de Leibniz.\n\n\n\n\n\n\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\n\n\n\nEl objetivo de Leibniz era realizar cálculos de una manera “fácil, rápida y fiable”. También pretendía que los números calculados pudieran ser tan grandes como se deseara, si el tamaño de la máquina era ajustado. Sin embargo, las primeras versiones de la rueda de Leibniz no eran fiables debido a que tenían piezas mecánicas que tendían a trabarse y a fallar.\nLos derivados de las calculadoras mecánicas creadas por Pascal y Leibniz continuaron siendo producidos durante tres siglos, hasta que a principios de los años 1970 sus equivalentes electrónicos finalmente llegaron a ser fácilmente disponibles y baratos.\n\n\n1.4.1.2 La máquina analítica de Babbage\nEn la primera mitad del siglo XIX, el matemático británico Charles Babbage (1791 - 1871) diseñó la máquina analítica, una computadora mecánica que incorporaba algunas características de las computadoras modernas. Fue inicialmente descrita en 1837, aunque Babbage continuó refinando el diseño hasta su muerte en 1871. Es considerada la primera computadora programable de la historia. La máquina analítica de Babbage se muestra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\n\n\n\nAunque nunca fue terminada debido a limitaciones técnicas y económicas, su diseño revolucionario permitía realizar cálculos complejos y programarla para diversas tareas. Utilizaba tarjetas perforadas para la entrada de datos, disponía de una unidad aritmética para realizar operaciones matemáticas y una memoria capaz de almacenar hasta 1000 números. El lenguaje de programación que sería utilizado era similar a los actuales lenguajes ensambladores. Era posible implementar ciclos y condicionales de manera que el lenguaje propuesto habría sido Turing-completo.\nEn 1843, la matemática británica Ada Lovelace (1815 - 1852) tradujo al inglés una descripción de la máquina analítica escrita en francés un año antes por el matemático italiano Luigi Menabrea (1809 - 1896). Entre las notas que acompañan la traducción, Lovelace incluyó el detalle de los pasos mediante los cuales la máquina podría calcular los números de Bernoulli, lo que se considera por algunos el primer programa de computadoras de la historia. El diagrama correspondiente a este algoritmo/programa se muestra en la Figura 1.4.\n\n\n\n\n\n\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\n\n\n\nAhora se cree que el autor de este programa fue probablemente el mismo Charles Babbage, que ya había desarrollado trabajos similares entre seis y siete años antes de la publicación del artículo de Lovelace.\nEl aporte de Ada Lovelace fue de suma importancia para la computación, ya que fue la primera en reconocer la capacidad de las máquinas para ir más allá de los simples cálculos de números. Acertadamente, anticipó que en el futuro podrían hacer muchas otras cosas, como componer música o generar gráficos. En sus notas, Lovelace enfatizó la diferencia entre la máquina analítica y las máquinas de cálculo previas, en particular su capacidad de ser programada para resolver problemas de mayor complejidad.\n\n\n1.4.1.3 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.5 muestra una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\n\n\n\nUna máquina de Turing está compuesta por:\n\nUna cinta: actúa como memoria de la máquina. Se compone de celdas, cada una de las cuales puede contener un símbolo (ej. una letra, un número).\nUna cabeza lectora/escritora: lee y escribe símbolos en la cinta.\nUn conjunto de estados: entre los cuales la máquina puede cambiar en respuesta a lo que lee en la cinta. Hay un estado inicial desde el cual el funcionamiento de la máquina comienza, y uno o más estados de parada que indican que la máquina ha terminado su computación.\nUna tabla de acciones: indica para combinación de estado actual y símbolo leído en la cinta, qué acción debe realizar la máquina. Estas acciones incluyen leer o escribir un símbolo en la cinta, mover la cabeza lectora/escritora a la izquierda o a la derecha sobre la cinta y cambiar a un nuevo estado.\n\nCon este esquema, una máquina de Turing puede ejecutar cualquier algoritmo. El modelo de Turing demostró que una máquina simple podía resolver cualquier problema computable, si cuenta con el tiempo y los recursos necesarios. Si un sistema (ej. una computadora, un lenguaje de programación) puede utilizarse para resolver cualquier problema de cómputo, se dice que es Turing-completo. No todos los sistemas o lenguajes de programación son Turing-completos, ya que algunos están diseñados para propósitos específicos y pueden tener restricciones que limitan su capacidad de cálculo.\nAllan Turing es considerado uno de los padres de la computación moderna. Sus contribuciones fueron fundamentales en el desarrollo de la teoría de la computación y la inteligencia artificial. En esta última área, Turing propuso un experimento para determinar si una máquina puede exhibir inteligencia equivalente a la de un ser humano. Este experimento, conocido como Prueba de Turing, sigue siendo una referencia en el debate sobre la inteligencia artificial.\n\n\n1.4.1.4 Primeras computadoras electrónicas\nCon base en las ideas de Turing, las computadoras de tipo Bombe y Colossus fueron construídas durante la II Guerra Mundial (1939 - 1945) en el Reino Unido para descifrar mensajes codificados. A pesar de que se consideran de las primeras computadoras digitales electrónicas programables, su programación se realizaba a través de componentes de hardware, como interruptores y enchufes, y no con un programa almacenado en la memoria. La Figura 1.6 muestra una computadora Colossus.\n\n\n\n\n\n\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\n\n\n\nTambién durante la II Guerra Mundial, el ejército de Estados Unidos de América construyó ENIAC (Electronic Numerical Integrator and Computer) para calcular tablas de tiro de artillería. Es considerada por algunos como la primera computadora programable digital de propósito general. Era capaz de seguir el modelo de la máquina de Turing, por lo que era Turing-completa. La Figura 1.7 presenta una imagen de ENIAC.\n\n\n\n\n\n\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\n\n\n\n\n\n\n1.4.2 La arquitectura de von Neumann\nEn 1945, el matemático húngaro - estadounidense John von Neumann (1903 - 1957) propuso un concepto conocido como programa almacenado según el cual los datos y los programas de una computadora se almacenan en una estructura llamada memoria, separada de los componentes que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Su esquema se muestra en la Figura 1.8.\n\n\n\n\n\n\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\nLos principales componentes de esta arquitectura son:\n\nMemoria principal. Almacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como Random Access Memory (Memoria de Acceso Aleatorio) o RAM, ya que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\nUnidad central de procesamiento. Llamada en inglés Central Processing Unit (CPU), se encarga de ejecutar las instrucciones de los programas. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros para almacenar los operandos y el resultado de las instrucciones. Está compuesta por dos partes principales:\n\nUnidad de control. Determina cuál es la siguiente instrucción a ejecutar.\nUnidad de aritmética y lógica. Llamada en inglés Arithmetic and Logic Unit (ALU), ejecuta las operaciones aritméticas y lógicas.\n\nSistemas de entrada y salida. Permiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\n1.4.3 Sistemas binarios\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips, como el que se muestra en la Figura 1.9.\n\n\n\n\n\n\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\n\n\n\nLos circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria, lo que significa que puede tener dos valores. Para representar estos dos valores internamente, las computadoras emplean dos niveles de tensión eléctrica: bajo (o ausencia de tensión) y alto (o presencia de tensión eléctrica). Estos estados se representan respectivamente con 0 y 1 (o viceversa). Este es un sistema binario y cada dígito binario se denomina bit (binary digit). Los bits se agrupan en grupos de ocho llamados bytes) para representar elementos de información más complejos, como números más grandes o carácteres de texto. Por ejemplo:\n\nEl número decimal 14 se representa en binario como 1110:\n1110 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 = 8 + 4 + 2 + 0 = 14\nLa palabra bit se representa en código ASCII como:\n01100010 01101001 01110100 = bit\n\nDe manera similar, se pueden representar otras clases de información, como imágenes, sonidos o videos, mediante secuencias de dígitos binarios.\n\n1.4.3.1 Ventajas\nEl uso de dos estados (en lugar de diez, doce u otra cantidad) facilita la aplicación de la teoría de la información, el estudio matemático de la cuantificación, almacenamiento y comunicación de la información, en el cual los bits son la unidad fundamental. La teoría de la información fue proṕuesta por el matemático estadounidense Claude Shannon (1916 - 2001) en la década de 1940.\nEl álgebra booleana, un pilar fundamental en el campo del análisis y diseño de sistemas digitales, así como en la programación de computadoras, también utiliza dos posibles valores: verdadero (1) y falso (0). Fue introducida en 1847 por el matemático británico George Boole (1815 - 1864). El álgebra booleana utiliza operaciones lógicas como AND (y), OR (o) y NOT (no) para combinar y transformar valores booleanos (verdaderos y falsos).\nPor otra parte, es más fácil diseñar y fabricar dispositivos electrónicos que solo necesitan reconocer dos estados. Por esta razón, los circuitos que manejan señales binarias pueden ser más simples, más confiables y menos costosos que aquellos que tendrían que manejar múltiples estados.\n\n\n\n1.4.4 Lenguaje máquina\nEl lenguaje máquina es un conjunto de instrucciones binarias (compuestas por unos y ceros) interpretables por un CPU. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Este es el único lenguaje que “entienden” directamente las computadoras.\nEl lenguaje máquina, siendo el más bajo nivel de lenguaje de programación y directamente entendible por el hardware del procesador, incluye varios tipos de instrucciones esenciales para la operación de una computadora. Estas instrucciones varían según la arquitectura del procesador (ej. x86, ARM, MIPS), pero generalmente se pueden agrupar en categorías como, por ejemplo:\n\nInstrucciones de aritmética y lógica. Realizan operaciones matemáticas básicas como suma, resta, multiplicación y división, así como operaciones lógicas como AND, OR y NOT.\nInstrucciones de manipulación de datos. Permiten el movimiento de datos dentro de la CPU o entre la CPU y la memoria. Ejemplos incluyen la carga (load) de datos desde la memoria al registro, almacenamiento (store) de datos del registro a la memoria, y transferencias de datos entre registros.\nInstrucciones de entrada/salida. Facilitan la comunicación entre la CPU y los dispositivos de entrada/salida, como discos duros, teclados, pantallas y otros.\nInstrucciones de comparación. Comparan valores y, a menudo, se usan junto con las instrucciones de control de flujo (ej. condicionales, ciclos) para tomar decisiones basadas en estas comparaciones.\nInstrucciones de operación de punto flotante. Específicas para el procesamiento de números de punto flotante, permiten realizar operaciones aritméticas sobre estos números, que son fundamentales para el cálculo científico y la ingeniería.\n\nCada instrucción en el lenguaje máquina se representa como una secuencia de bits, y el conjunto específico de instrucciones que un procesador puede ejecutar se conoce como su conjunto de instrucciones o Instruction Set Architecture (ISA).\nLa Figura 1.10 muestra una instrucción en lenguaje máquina que suma los contenidos de los registros 1 y 2 y almacena el resultado en el registro 6 de un CPU:\n\n\n\n\n\n\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\n\n\n\nLa Figura 1.11 muestra el programa Hola mundo (Hello World) en lenguaje máquina. Este programa simplemente imprime la hilera de texto “Hola mundo”, usualmente en la pantalla, y suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico.\n\n\n\n\n\n\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#lenguajes-de-programación",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#lenguajes-de-programación",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.5 Lenguajes de programación",
    "text": "1.5 Lenguajes de programación\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. A manera de ejemplo, seguidamente se muestra el programa “Hola mundo” en varios lenguajes de programación:\nLenguaje C\n/* Hola mundo en lenguaje C */\n\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(\"Hola mundo\\n\");\n}\nLenguaje Python\n# Hola mundo en lenguaje Python\n\nprint(\"Hola mundo\")\nLenguaje R\n# Hola mundo en lenguaje R\n\ncat(\"Hola mundo\\n\")\nEl sitio web The Hello World Collection presenta el programa “Hola mundo” en más de 600 lenguajes de programación. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#pensamiento-computacional",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#pensamiento-computacional",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.6 Pensamiento computacional",
    "text": "1.6 Pensamiento computacional\nComo se ha mencionado, utilizamos computadoras porque nos ayudan a resolver problemas. La forma de solucionar un problema debe expresarse de manera que pueda ser implementada en una computadora: mediante programación (vea la Figura 1.12).\n\n\n\n\n\n\nFigura 1.12: Resolución de problemas mediante computadoras.\n\n\n\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Puede ser aplicado en otras áreas. Se considera una de las destrezas fundamentales del siglo XXI.\n\n1.6.1 Principios fundamentales\nEl pensamiento computacional tiene cuatro principios fundamentales:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes de un problema a resolver, con problemas ya resueltos.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#el-lenguaje-de-programación-scratch",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#el-lenguaje-de-programación-scratch",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.7 El lenguaje de programación Scratch",
    "text": "1.7 El lenguaje de programación Scratch\nScratch es un lenguaje de programación orientado a educación. Su nombre proviene de la palabra en ingés scratching. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita. Es software libre que se comparte mediante una licencia GPLv2.\n\n1.7.1 Aplicación de los principios del pensamiento computacional\n\nIngrese a la sitio web de Scratch en la dirección https://scratch.mit.edu/ y presione el botón Start Creating o Empiezo a crear para iniciar un proyecto (para este curso, no es necesario crear un usuario en el sitio). Se desplegará el ambiente de programación de Scratch.\n\n\n\n\n\n\n\nFigura 1.13: Ambiente de programación de Scratch.\n\n\n\nEl ambiente de programación de Scratch está compuesto por varias zonas. Seguidamente se describen algunas de las principales:\n\nUn área de bloques, a la izquierda de la pantalla, los cuales ejecutan tareas: mover, girar, ir a, etc. Estos bloques se agrupan en secciones: Movimiento, Apariencia, Sonido, etc.\nUn área en el centro de la pantalla al que pueden arrastrarse los bloques con el ratón para unirse y acoplarse.\nUn área en la parte superior derecha de la pantalla en la que se despliega el resultado de las tareas ejecutadas por los bloques.\nUn botón ubicado en la esquina inferior izquierda de la pantalla llamado Agregar Extensión. En el contexto de Scratch, una extensión es un grupo de tareas adicional a los bloques que se despliegan por defecto. Las extensiones pueden ser desarrolladas por programadores diferentes a los creadores de Scratch.\n\nNota: si lo desea, puede cambiar el idioma a español, u otro de su preferencia, con la opción de menú Settings - Language.\n\nCon el bloque decir de la sección Apariencia, programe el programa “Hola Mundo” en Scratch. Utilice el evento al presionar de la sección Eventos para poder ejecutar el programa al presionar la bandera de salida.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Código fuente\n\n\n\n\n\n\n\n\n\n\n\n(b) Salida\n\n\n\n\n\n\n\nFigura 1.14: Programa “Hola mundo”\n\n\n\nCon la opción de menú Archivo - Guardar en tu computador, guarde el programa en un archivo. Puede cargarlo con la opción de menú Archivo - Subir desde tu computador.\n\nProblema a resolver: dibujar un paisaje como el que se muestra en la figura de abajo.\n\n\n\n\n\n\n\nFigura 1.15: Paisaje.\n\n\n\nPara comenzar, dibuje un par de casas. Se sugiere agregar la extensión Lápiz y bloques como bajar lápiz, subir lápiz, borrar todo, mover, girar, ir a, apuntar en dirección y cualquier otro que le sea útil.\n\n1.7.1.1 Descomposición\nDivisión de un problema en subproblemas más pequeños\n\nIdentifique subproblemas en los que se pueda dividir el problema general (ej. figuras geométricas) y agrupe los bloques correspondientes a cada subproblema.\nPara cada subproblema, cree un bloque nuevo con Crear un bloque en la sección Mis bloques.\nUtilice estructuras de control como repetir en la sección Control para realizar tareas repetitivas.\n\n\n\n1.7.1.2 Reconocimiento de patrones\nBúsqueda de similitudes de un problema a resolver, con problemas ya resueltos\n\nBusque problemas conocidos similares a los que está resolviendo (ej. dibujos de figuras geométricas) y aplique las soluciones.\n\n\n\n1.7.1.3 Abstracción\nFiltrado de la información que se necesita y de la que no se necesita para resolver un problema.\n\nIdentifique los elementos de información que necesita para resolver los subproblemas que ha identificado (ej. tamaños, ángulos). Trate de usarlos como entrada de los bloques que creó.\n\n\n\n1.7.1.4 Algoritmos\nDescripción, paso por paso, de la solución a un problema.\n\nDescriba un algoritmo para la solución al problema.\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.\nFigura 1.12: Resolución de problemas mediante computadoras.\nFigura 1.13: Ambiente de programación de Scratch.\nFigura 1.15: Paisaje.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "2.1 Resumen\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento de datos. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento. Incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Trabajo previo",
    "text": "2.2 Trabajo previo\n\n2.2.1 Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/ (capítulo 1)\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulo introductorio)",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#estadística",
    "href": "02-introduccion-ciencia-datos.html#estadística",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Estadística",
    "text": "2.3 Estadística\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos (Çetinkaya-Rundel & Hardin, 2021).\n\n2.3.1 Datos\nLa presentación y descripción efectivas de los datos es el primer paso en un análisis (Çetinkaya-Rundel & Hardin, 2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.3.1.1 Observaciones y variables\nLa tabla 2.1. contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\nTabla 2.1.\n\n\n\n\nid\n\n\nprovincia\n\n\nequipo\n\n\nmasa\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n1\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\notro\n\n\n0\n\n\nnulo\n\n\n\n\n2\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n3\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n4\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n5\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n6\n\n\notra\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n7\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n8\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n9\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n10\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.3.1.2 Tipos de variables\nLos datos de la tabla 2.1. son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\n\n\n\n\n2.3.1.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares.\n\n2.3.1.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no es posible tener 2.5 hermanos.\n\n\n2.3.1.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables masa y estatura son continuas.\n\n\n\n2.3.1.2.2 Categóricas\n\n2.3.1.2.2.1 Nominales\n\n\n2.3.1.2.2.2 Ordinales",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Ciencia de datos",
    "text": "2.4 Ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento (Wickham, Çetinkaya-Rundel, & Grolemund, 2023). Utiliza estadística y ciencias de la computación, entre otras disciplinas.\nLa Figura 2.2 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias",
    "href": "02-introduccion-ciencia-datos.html#referencias",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias",
    "text": "2.5 Referencias\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\nFigura 2.2: Modelo de ciencia de datos. Fuente: R for Data Science.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Datos",
    "text": "2.3 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis (Çetinkaya-Rundel & Hardin, 2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.3.1 Observaciones y variables\nLa tabla 2.1. contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\nTabla 2.1.\n\n\n\n\nid\n\n\nprovincia\n\n\nequipo\n\n\nmasa\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n1\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\notro\n\n\n0\n\n\nnulo\n\n\n\n\n2\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n3\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n4\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n5\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n6\n\n\notra\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n7\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n8\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n9\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n10\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.3.2 Tipos de variables\nLos datos de la tabla 2.1. son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\n\n\n\n\n2.3.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares.\n\n2.3.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no es posible tener 2.5 hermanos.\n\n\n2.3.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables masa y estatura son continuas.\n\n\n\n2.3.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y clasifican las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades numéricas, las variables categóricas expresan atributos no numéricos.\n\n2.3.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.3.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra es categórica.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "3.1 Resumen\nR es un lenguaje de programación y un entorno para graficación y análisis estadístico. Como lenguaje, es interpretado, multiplataforma, de tipado dinámico y multiparadigma. Es un proyecto de software libre que se comparte mediante una licencia GNU GPL.\nEl código de R se estructura en funciones, las cuales se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. Algunos paquetes están incorporados en la instalación base de R y otros deben instalarse separadamente.\nR puede manejar diversos tipos de datos básicos, como números, textos y valores lógicos, entre otros. También tipos de datos compuestos, como factores y data frames. Al igual que otros lenguajes de programación, cuenta con estructuras de control como condicionales y ciclos.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Trabajo previo",
    "text": "3.2 Trabajo previo\n\n3.2.1 Lecturas\nGrolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Introducción",
    "text": "3.3 Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, en inglés Integrated Development Environment) como Jupyter o RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.4 El ambiente de desarrollo integrado RStudio",
    "text": "3.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n1. Instale en su computadora:\na. Sistema base del lenguaje R.\nb. RStudio Desktop.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conjuntos-de-datos-para-pruebas",
    "href": "03-r.html#conjuntos-de-datos-para-pruebas",
    "title": "3  R: lenguaje de programación para análisis estadístico",
    "section": "3.5 Conjuntos de datos para pruebas",
    "text": "3.5 Conjuntos de datos para pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nGapminder\nPapers with Code - conjuntos de datos",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R: lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#funciones",
    "href": "03-r.html#funciones",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.5 Funciones",
    "text": "3.5 Funciones\n\n3.5.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.5.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd().\n2. Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n3.5.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.5.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#paquetes",
    "href": "03-r.html#paquetes",
    "title": "3  R: lenguaje de programación para análisis estadístico",
    "section": "3.7 Paquetes",
    "text": "3.7 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R: lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conjuntos-de-datos-para-ejemplos-y-pruebas",
    "href": "03-r.html#conjuntos-de-datos-para-ejemplos-y-pruebas",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Conjuntos de datos para ejemplos y pruebas",
    "text": "3.6 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\n\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n3.6.1 Funciones\n\n3.6.1.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.6.1.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd().\n2. Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n3.6.1.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.6.1.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.5 Conceptos fundamentales",
    "text": "3.5 Conceptos fundamentales\n\n3.5.1 Manejo de datos\n\n3.5.1.1 Tipos y estructuras de datos\nR maneja los datos en una gran variedad de tipos y estructuras, los cuales incluyen tipos básicos como números, caracteres y lógicos y tipos compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nUna de las herramientas fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Un data frame puede verse como lo que comúmmente se conoce como una tabla de datos (ej. las de las hojas de cálculo). Los data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n\n3.5.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\nGapminder\n\n\n\n\n3.5.2 Funciones\n\n3.5.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.5.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n2. Cambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n3. Con la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n4. Ejecute su programa con los botones Run y Source de RStudio.\n5. Cambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n3.5.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.5.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.5.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene datos sobre el destino de los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.5.4 Visualización de datos\n\n3.5.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen, por ejemplo, predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.5.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.5.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.5.5 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.5.5.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.5.5.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.5.5.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.5.5.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.5.5.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.5.5.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.5.5.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.5.5.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.5.5.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.5.5.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.5.5.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.5.5.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.5.5.2 Tipos compuestos\n\n3.5.5.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.5.5.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.5.5.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.5.5.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.5.5.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.5.5.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.5.5.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.5.5.3 Otros\n\n3.5.5.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.5.5.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2024-04-08\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.5.6 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n1. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n2. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n3. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n3.5.7 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.5.7.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.5.7.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.5.7.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n1. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n3.5.8 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.5.8.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n1. Utilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n2. Utilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n3.5.8.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n1. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.\n\n\n3.5.8.3 La sentencia repeat\nLa sentencia repeat implementa un ciclo que se repite indefinidamente. Puede interrumpirse con una sentencia break.\n\n# Sintaxis de la sentencia repeat\nrepeat {\n  # bloque de instrucciones \n}\n\nLos ciclos repeat tienen una estructura más sencilla que los while. Algo que los diferencia es que los bloques de los ciclos repeat se ejecutan al menos una vez.\nEn el siguiente ejemplo, se utiliza un ciclo repeat para implementar la pregunta y lectura de la respuesta que anteriormente se implementó con un ciclo while.\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Ciclo para imprimir la pregunta y leer la respuesta hasta que esta sea correcta\nrepeat {\n  respuesta &lt;- leer_respuesta()\n  if (respuesta != \"42\") {\n    # Respuesta incorrecta\n    print(\"¡Su respuesta es incorrecta!\")\n  } else {\n    # Respuesta correcta. Se interrumpe el ciclo.\n    break\n  }\n}\n\n\n\n3.5.8.4 Las sentencias break y next\nLa sentencia break interrumpe un ciclo. La ejecución del programa continúa con la instrucción siguiente al bloque del ciclo.\nEn el siguiente ciclo for, se suman uno a uno los números de un vector, pero se usa un break para interrumpir el ciclo cuando el acumulado es mayor que 100.\n\nvector_numeros &lt;- c(17, 23, 37, 41, 52, 64, 75)\n\nacumulado &lt;- 0\n\nfor (x in vector_numeros) {\n  acumulado &lt;- acumulado + x\n  cat(\"Acumulado:\", acumulado, \"\\n\")\n  if (acumulado &gt;= 100) {\n    cat(\"Se superó el límite de 100 en el acumulado\")\n    break\n  }\n}\n## Acumulado: 17 \n## Acumulado: 40 \n## Acumulado: 77 \n## Acumulado: 118 \n## Se superó el límite de 100 en el acumulado\n\nPor su parte, la sentencia next retorna el control al principio del bloque. Las instrucciones que hay después del next no se ejecutan. La siguiente iteración del ciclo (si la hay), se inicia entonces.\nEl siguiente ciclo recorre un vector de números. Se utiliza la sentencia next para “saltar” los números impares y sumar solo los pares.\n\nvector_numeros &lt;- c(17, 23, 37, 41, 52, 64, 75)\n\nsuma_pares &lt;- 0\n\nfor (x in vector_numeros) {\n  if (x %% 2 == 0) {\n    # Número par: se suma\n    suma_pares &lt;- suma_pares + x\n  } else {\n    # Número impar: se \"salta\" al siguiente número\n    next\n  }\n}\n\ncat(\"Suma de los números pares:\", suma_pares)\n## Suma de los números pares: 116\n\n\n\n3.5.8.5 La familia de funciones apply()\nEsta es una familia de funciones que manipulan subconjuntos de datos obtenidos a partir de matrices, listas y data frames, los cuales son recorridos de una forma repetitiva. Pueden funcionar como una alternativa a los ciclos y aplicar funciones en los subconjuntos de datos como, por ejemplo, funciones estadísticas en las columnas de una matriz o de un data frame. Su uso es muy recomendado por su eficiencia, flexibilidad y simplicidad.\nEntre estas funciones, pueden mencionarse apply(), lapply(), sapply(), vapply(), mapply(), rapply() y tapply().\n\n3.5.8.5.1 La función apply()\nLa función apply() toma como entrada un arreglo o una matriz y aplica alguna función sobre sus filas o columnas.\nLa sintaxis de la función es:\n\n# Sintaxis de la función apply()\napply(X, MARGIN, FUN, ...)\n\nEn donde:\n- X: es un arreglo o matriz.\n- MARGIN: MARGIN = 1 significa que la función actúa en las filas, MARGIN = 2 significa que la función actúa en las columnas y MARGIN = c(1, 2) significa que la función actúa en las filas y en las columnas.\n- FUN: es la función que se aplicará a cada uno de los elementos de X.\nEn el siguiente ejemplo, se utiliza la función apply() para sumar los elementos de las columnas de una matriz.\n\nm &lt;- matrix(1:12, nrow=3, ncol=4)\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n# Suma de las columnas\napply(m, 2, sum)\n\n[1]  6 15 24 33\n\n\nEjercicios\n1. Utilice la función apply() para obtener el promedio de los elementos de cada columna de la matriz del ejemplo anterior.\n\n\n3.5.8.5.2 La función lapply()\nLa función lapply() toma como entrada un vector o lista y retorna una lista de la misma longitud en la que cada uno de sus elementos es el resultado de aplicar una función al vector o lista de entrada.\nLa sintaxis de la función es:\n\n# Sintaxis de la función lapply()\nlapply(X, FUN, ...)\n\nEn donde:\n- X: es un vector o lista.\n- FUN: es la función que se aplicará a cada elemento de X. Algunas funciones predefinidas que pueden utilizarse incluyen mean(), median(), sum(), min() y max(). También pueden usarse funciones definidas por el usuario.\nEn los siguientes ejemplos, se utiliza lapply() para aplicar diferentes funciones a un vector de nombres de personas.\n\nnombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Los nombres de la lista se transforman a minúscula\nnombres_en_minuscula &lt;- lapply(nombres, tolower)\nnombres_en_minuscula\n\n[[1]]\n[1] \"andrés\"\n\n[[2]]\n[1] \"beatriz\"\n\n[[3]]\n[1] \"carlos\"\n\n[[4]]\n[1] \"marta\"\n\n[[5]]\n[1] \"pedro\"\n\n[[6]]\n[1] \"sara\"\n\n# Se genera un saludo para cada nombre\nnombres_con_saludo &lt;- lapply(nombres, function(arg1, arg2) paste(arg1, arg2), arg1=\"Hola\")\nnombres_con_saludo\n\n[[1]]\n[1] \"Hola Andrés\"\n\n[[2]]\n[1] \"Hola Beatriz\"\n\n[[3]]\n[1] \"Hola Carlos\"\n\n[[4]]\n[1] \"Hola Marta\"\n\n[[5]]\n[1] \"Hola Pedro\"\n\n[[6]]\n[1] \"Hola Sara\"\n\n\n\n\n3.5.8.5.3 La función tapply()\nLa función tapply() aplica una función a cada nivel de un factor.\nLa sintaxis de la función es:\n\n# Sintaxis de la función tapply()\ntapply(X, INDEX, FUN)\n\nEn donde:\n- X: es un objeto, tipicamente un vector.\n- INDEX: es una lista que contiene un factor.\n- FUN: es la función que se aplicará a cada elemento de X.\nEn el siguiente ejemplo, se utiliza tapply() para calcular la mediana del ancho del sépalo para cada especie del conjunto de datos iris.\n\ndata(iris)\ntapply(iris$Sepal.Width, iris$Species, median)\n\n    setosa versicolor  virginica \n       3.4        2.8        3.0 \n\n\nEjercicios\n1. Utilice la función tapply() para obtener el promedio de las longitudes de los pétalos para cada especie del conjunto de datos iris.\n\n\n\n3.5.8.6 Vectorización\nEn R, muchas operaciones y funciones pueden ser vectorizadas, lo que significa que pueden aplicarse a los elementos de un vector sin necesidad de iterar uno por uno en estos.\nPor ejemplo, considérese el siguiente fragmento de código no vectorizado, que utiliza un ciclo para convertir los números de un vector a sus valores absolutos:\n\nvector_numeros &lt;- c(23, -17, 34, 0, -12, 55)\n\nfor (i in 1:length(vector_numeros)) {\n  if (vector_numeros[i] &lt; 0) {\n    vector_numeros[i] &lt;- -vector_numeros[i]\n  }\n}\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\nEl siguiente fragmento de código realiza la misma tarea, pero de forma vectorizada:\n\nvector_numeros &lt;- c(23, -17, 34, 0, -12, 55)\n\n# Se usa una expresión lógica para seleccionar los elementos del vector &lt; 0\nnegativos &lt;- vector_numeros &lt; 0\nnegativos\n## [1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Se cambian los elementos seleccionados en el paso anterior sin utilizar el for\nvector_numeros[negativos] &lt;- vector_numeros[negativos] * -1\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\nEjercicios\n1. Utilice código vectorizado para implementar una función que reciba como argumento un vector de números y retorne el mismo vector con los elementos impares (solo los impares) elevados al cuadrado.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "examen-corto-01.html",
    "href": "examen-corto-01.html",
    "title": "Examen corto 1",
    "section": "",
    "text": "Fecha",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "examen-corto-01.html#fecha",
    "href": "examen-corto-01.html#fecha",
    "title": "Examen corto 1",
    "section": "",
    "text": "Grupo 001: jueves 11 de abril de 2024\nGrupo 002: miércoles 10 de abril de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "examen-corto-01.html#temas-a-evaluar",
    "href": "examen-corto-01.html#temas-a-evaluar",
    "title": "Examen corto 1",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n1 Arquitectura de computadoras, lenguajes de programación y pensamiento computacional\n2 Introducción a la ciencia de datos\n3 R - lenguaje de programación para análisis estadístico (hasta la sección “3.5.4 Visualización de datos” inclusive)",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "parte-vii-evaluaciones.html",
    "href": "parte-vii-evaluaciones.html",
    "title": "Evaluaciones",
    "section": "",
    "text": "Exámenes cortos\nExamen corto 1",
    "crumbs": [
      "Evaluaciones"
    ]
  }
]