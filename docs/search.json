[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GF0604 Procesamiento de datos geográficos 2024-I",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geográficos mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Escuela de Geografía de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos los conocimientos y habilidades aprendidas. No se requiere de experiencia previa en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://gf0604-procesamientodatosgeograficos.github.io/2024-i/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nAplicar el pensamiento computacional para resolver problemas mediante el lenguaje de programación R.\nUtilizar un enfoque de ciencia de datos para la importación, transformación y visualización de datos.\nDesarrollar soluciones reproducibles a problemas computacionales.\nElaborar gráficos estadísticos con paquetes de R.\nProcesar datos geográficos con paquetes de R.\nDesarrollar aplicaciones interactivas que incluyan visualizaciones como tablas, gráficos estadísticos y mapas, entre otras.\n\n\n\nPrograma\nLos siguientes documentos contienen el programa del curso, para los grupos 001 y 002, según el formato definido por la Escuela de Geografía de la Universidad de Costa Rica.\n\nGrupo 001\nGrupo 002\n\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el primer lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2023-I\n2022-I\n2021-I\n2020-I\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso en el formato especificado por la Comisión de Docencia de la Escuela de Geografía:\nGrupo 001\nGrupo 002",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion_computadoras_ciencia_datos.html",
    "href": "parte-i-introduccion-programacion_computadoras_ciencia_datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Arquitectura de computadoras, pensamiento computacional y lenguajes de programación\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#resumen",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#resumen",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "Descomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#trabajo-previo",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#trabajo-previo",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas y videos\nCS50 (Director). (2024). CS50x 2024—Lecture 0—Scratch. https://www.youtube.com/watch?v=3LPJfIKxwWc\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-l",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-l",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.3 Características generales de l",
    "text": "1.3 Características generales de l\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. Los programas reciben entradas, las procesan y generan salidas.\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida.\n\n\n\n\nAl programar una computadora, se puede modificar su funcionamiento sin alterar sus componentes físicos"
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-las-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#características-generales-de-las-computadoras",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.3 Características generales de las computadoras",
    "text": "1.3 Características generales de las computadoras\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones, entre los que pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un valor está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. por medio del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresarla en una secuencia de pasos claramente definidos. Estas secuencias se denominan algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como algunas recetas de cocina o tan complejos como los que se utilizan en aprendizaje automático.\nUn algoritmo debe cumplir con algunas características:\n\nDebe recibir entradas: datos que los que trabaja.\nDebe generar salidas: datos generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, los diagramas de flujo o simplemente como una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Se lee la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, se despliega la hilera de texto \"Lista vacía\" \n   y se concluye el proceso. Si no, se continúa con el paso 3.\n3. Se designa el primer elemento de la lista como \"máximo actual\".\n4. Se recorre la lista y se compara cada uno de los elementos con el máximo actual.\n5. Si un elemento comparado es mayor que el máximo actual, \n   entonces pasa a ser el nuevo máximo actual.\n6. El valor máximo de la lista es el máximo actual \n   cuando termina de recorrerse la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.2, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual.\nSi un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nEl valor máximo de la lista es el máximo actual cuando termina de recorrerse la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida describe la estructura básica de un algoritmo o de un programa de computación. De acuerdo con este modelo, un programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura.\n\nEntradas: \\(masa\\) (kg), \\(estatura\\) (m)\n\nProcesamiento: \\(imc = masa/estatura^2\\)\n\nSalida: \\(imc\\)\n\nA manera de ejercicio, calcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Sin embargo, son entidades independientes. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjecute los programas anteriores en:\n\nAmbiente de ejecución en línea de Python\nAmbiente de ejecución en línea de R",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "1.1 Resumen\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. La capacidad que tienen las computadoras de ser programadas permite modificar sus funcionamiento sin necesidad de alterar sus componentes físicos, lo que permite que ayuden a resolver una gran cantidad de problemas. Las secuencias de pasos describen la solución a un problema se denominan algoritmos. En un algoritmo recibe datos de entrada, los procesa y genera salidas. Un algoritmo puede ser implementado en diferentes lenguajes de programación.\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips. Los circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los circuitos integrados de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la teoría de la información y del álgebra booleana.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Sus componentes principales son la memoria principal, la unidad central de procesamiento (CPU) y los sistemas de entrada y salida.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por la CPU de una computadora. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Debido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales y otros.\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#arquitectura-de-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#arquitectura-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.4 Arquitectura de computadoras",
    "text": "1.4 Arquitectura de computadoras\nEn esta sección, se explican los principales componentes de las computadoras modernas. Se realiza un recorrido por algunos de los principales antecedentes históricos de su evolución y se detallan los componentes de la arquitectura de von Neumann, el modelo de arquitectura más utilizado en la actualidad.\n\n1.4.1 Evolución histórica\n\n1.4.1.1 Calculadoras mecánicas\nDurante el siglo XVII, varios matemáticos construyeron calculadoras mecánicas capaces de realizar operaciones aritméticas.\nAlrededor de 1645, el filósofo y matemático francés Blaise Pascal (1623-1662) inventó la Pascalina, una calculadora compuesta por ruedas y engranajes que podía sumar y restar. Pascal la creó con el propósito de ayudar a su padre, quien era contador en la Hacienda francesa y necesitaba una herramienta para realizar cálculos de aritmética comercial de manera más eficiente. La Pascalina podía sumar hasta tres partes en una sola operación, llegando al valor de 999 999.\nEn 1672, el científico alemán Gottfried Leibniz (1646 - 1716) extendió las ideas de Pascal e introdujo la Stepped Reckoner o máquina de Leibniz, un dispositivo que, además de sumar y restar, podía multiplicar, dividir y calcular raíces cuadradas. La máquina de Leibniz estaba basada en un dispositivo llamado rueda de Leibniz, un tambor con forma de cilindro, con un conjunto de dientes de longitud incremental a la que se le acopla una rueda de conteo. La Figura 1.2 muestra una réplica de la máquina de Leibniz.\n\n\n\n\n\n\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\n\n\n\nEl objetivo de Leibniz era realizar cálculos de una manera “fácil, rápida y fiable”. También pretendía que los números calculados pudieran ser tan grandes como se deseara, si el tamaño de la máquina era ajustado. Sin embargo, las primeras versiones de la rueda de Leibniz no eran fiables debido a que tenían piezas mecánicas que tendían a trabarse y a fallar.\nLos derivados de las calculadoras mecánicas creadas por Pascal y Leibniz continuaron siendo producidos durante tres siglos, hasta que a principios de los años 1970 sus equivalentes electrónicos finalmente llegaron a ser fácilmente disponibles y baratos.\n\n\n1.4.1.2 La máquina analítica de Babbage\nEn la primera mitad del siglo XIX, el matemático británico Charles Babbage (1791 - 1871) diseñó la máquina analítica, una computadora mecánica que incorporaba algunas características de las computadoras modernas. Fue inicialmente descrita en 1837, aunque Babbage continuó refinando el diseño hasta su muerte en 1871. Es considerada la primera computadora programable de la historia. La máquina analítica de Babbage se muestra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\n\n\n\nAunque nunca fue terminada debido a limitaciones técnicas y económicas, su diseño revolucionario permitía realizar cálculos complejos y programarla para diversas tareas. Utilizaba tarjetas perforadas para la entrada de datos, disponía de una unidad aritmética para realizar operaciones matemáticas y una memoria capaz de almacenar hasta 1000 números. El lenguaje de programación que sería utilizado era similar a los actuales lenguajes ensambladores. Era posible implementar ciclos y condicionales de manera que el lenguaje propuesto habría sido Turing-completo.\nEn 1843, la matemática británica Ada Lovelace (1815 - 1852) tradujo al inglés una descripción de la máquina analítica escrita en francés un año antes por el matemático italiano Luigi Menabrea (1809 - 1896). Entre las notas que acompañan la traducción, Lovelace incluyó el detalle de los pasos mediante los cuales la máquina podría calcular los números de Bernoulli, lo que se considera por algunos el primer programa de computadoras de la historia. El diagrama correspondiente a este algoritmo/programa se muestra en la Figura 1.4.\n\n\n\n\n\n\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\n\n\n\nAhora se cree que el autor de este programa fue probablemente el mismo Charles Babbage, que ya había desarrollado trabajos similares entre seis y siete años antes de la publicación del artículo de Lovelace.\nEl aporte de Ada Lovelace fue de suma importancia para la computación, ya que fue la primera en reconocer la capacidad de las máquinas para ir más allá de los simples cálculos de números. Acertadamente, anticipó que en el futuro podrían hacer muchas otras cosas, como componer música o generar gráficos. En sus notas, Lovelace enfatizó la diferencia entre la máquina analítica y las máquinas de cálculo previas, en particular su capacidad de ser programada para resolver problemas de mayor complejidad.\n\n\n1.4.1.3 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.5 muestra una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\n\n\n\nUna máquina de Turing está compuesta por:\n\nUna cinta: actúa como memoria de la máquina. Se compone de celdas, cada una de las cuales puede contener un símbolo (ej. una letra, un número).\nUna cabeza lectora/escritora: lee y escribe símbolos en la cinta.\nUn conjunto de estados: entre los cuales la máquina puede cambiar en respuesta a lo que lee en la cinta. Hay un estado inicial desde el cual el funcionamiento de la máquina comienza, y uno o más estados de parada que indican que la máquina ha terminado su computación.\nUna tabla de acciones: indica para combinación de estado actual y símbolo leído en la cinta, qué acción debe realizar la máquina. Estas acciones incluyen leer o escribir un símbolo en la cinta, mover la cabeza lectora/escritora a la izquierda o a la derecha sobre la cinta y cambiar a un nuevo estado.\n\nCon este esquema, una máquina de Turing puede ejecutar cualquier algoritmo. El modelo de Turing demostró que una máquina simple podía resolver cualquier problema computable, si cuenta con el tiempo y los recursos necesarios. Si un sistema (ej. una computadora, un lenguaje de programación) puede utilizarse para resolver cualquier problema de cómputo, se dice que es Turing-completo. No todos los sistemas o lenguajes de programación son Turing-completos, ya que algunos están diseñados para propósitos específicos y pueden tener restricciones que limitan su capacidad de cálculo.\nAllan Turing es considerado uno de los padres de la computación moderna. Sus contribuciones fueron fundamentales en el desarrollo de la teoría de la computación y la inteligencia artificial. En esta última área, Turing propuso un experimento para determinar si una máquina puede exhibir inteligencia equivalente a la de un ser humano. Este experimento, conocido como Prueba de Turing, sigue siendo una referencia en el debate sobre la inteligencia artificial.\n\n\n1.4.1.4 Primeras computadoras electrónicas\nCon base en las ideas de Turing, las computadoras de tipo Bombe y Colossus fueron construídas durante la II Guerra Mundial (1939 - 1945) en el Reino Unido para descifrar mensajes codificados. A pesar de que se consideran de las primeras computadoras digitales electrónicas programables, su programación se realizaba a través de componentes de hardware, como interruptores y enchufes, y no con un programa almacenado en la memoria. La Figura 1.6 muestra una computadora Colossus.\n\n\n\n\n\n\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\n\n\n\nTambién durante la II Guerra Mundial, el ejército de Estados Unidos de América construyó ENIAC (Electronic Numerical Integrator and Computer) para calcular tablas de tiro de artillería. Es considerada por algunos como la primera computadora programable digital de propósito general. Era capaz de seguir el modelo de la máquina de Turing, por lo que era Turing-completa. La Figura 1.7 presenta una imagen de ENIAC.\n\n\n\n\n\n\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\n\n\n\n\n\n\n1.4.2 La arquitectura de von Neumann\nEn 1945, el matemático húngaro - estadounidense John von Neumann (1903 - 1957) propuso un concepto conocido como programa almacenado según el cual los datos y los programas de una computadora se almacenan en una estructura llamada memoria, separada de los componentes que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Su esquema se muestra en la Figura 1.8.\n\n\n\n\n\n\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\nLos principales componentes de esta arquitectura son:\n\nMemoria principal. Almacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como Random Access Memory (Memoria de Acceso Aleatorio) o RAM, ya que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\nUnidad central de procesamiento. Llamada en inglés Central Processing Unit (CPU), se encarga de ejecutar las instrucciones de los programas. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros para almacenar los operandos y el resultado de las instrucciones. Está compuesta por dos partes principales:\n\nUnidad de control. Determina cuál es la siguiente instrucción a ejecutar.\nUnidad de aritmética y lógica. Llamada en inglés Arithmetic and Logic Unit (ALU), ejecuta las operaciones aritméticas y lógicas.\n\nSistemas de entrada y salida. Permiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\n1.4.3 Sistemas binarios\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips, como el que se muestra en la Figura 1.9.\n\n\n\n\n\n\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\n\n\n\nLos circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria, lo que significa que puede tener dos valores. Para representar estos dos valores internamente, las computadoras emplean dos niveles de tensión eléctrica: bajo (o ausencia de tensión) y alto (o presencia de tensión eléctrica). Estos estados se representan respectivamente con 0 y 1 (o viceversa). Este es un sistema binario y cada dígito binario se denomina bit (binary digit). Los bits se agrupan en grupos de ocho llamados bytes) para representar elementos de información más complejos, como números más grandes o carácteres de texto. Por ejemplo:\n\nEl número decimal 14 se representa en binario como 1110:\n1110 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 = 8 + 4 + 2 + 0 = 14\nLa palabra bit se representa en código ASCII como:\n01100010 01101001 01110100 = bit\n\nDe manera similar, se pueden representar otras clases de información, como imágenes, sonidos o videos, mediante secuencias de dígitos binarios.\n\n1.4.3.1 Ventajas\nEl uso de dos estados (en lugar de diez, doce u otra cantidad) facilita la aplicación de la teoría de la información, el estudio matemático de la cuantificación, almacenamiento y comunicación de la información, en el cual los bits son la unidad fundamental. La teoría de la información fue proṕuesta por el matemático estadounidense Claude Shannon (1916 - 2001) en la década de 1940.\nEl álgebra booleana, un pilar fundamental en el campo del análisis y diseño de sistemas digitales, así como en la programación de computadoras, también utiliza dos posibles valores: verdadero (1) y falso (0). Fue introducida en 1847 por el matemático británico George Boole (1815 - 1864). El álgebra booleana utiliza operaciones lógicas como AND (y), OR (o) y NOT (no) para combinar y transformar valores booleanos (verdaderos y falsos).\nPor otra parte, es más fácil diseñar y fabricar dispositivos electrónicos que solo necesitan reconocer dos estados. Por esta razón, los circuitos que manejan señales binarias pueden ser más simples, más confiables y menos costosos que aquellos que tendrían que manejar múltiples estados.\n\n\n\n1.4.4 Lenguaje máquina\nEl lenguaje máquina es un conjunto de instrucciones binarias (compuestas por unos y ceros) interpretables por un CPU. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Este es el único lenguaje que “entienden” directamente las computadoras.\nEl lenguaje máquina, siendo el más bajo nivel de lenguaje de programación y directamente entendible por el hardware del procesador, incluye varios tipos de instrucciones esenciales para la operación de una computadora. Estas instrucciones varían según la arquitectura del procesador (ej. x86, ARM, MIPS), pero generalmente se pueden agrupar en categorías como, por ejemplo:\n\nInstrucciones de aritmética y lógica. Realizan operaciones matemáticas básicas como suma, resta, multiplicación y división, así como operaciones lógicas como AND, OR y NOT.\nInstrucciones de manipulación de datos. Permiten el movimiento de datos dentro de la CPU o entre la CPU y la memoria. Ejemplos incluyen la carga (load) de datos desde la memoria al registro, almacenamiento (store) de datos del registro a la memoria, y transferencias de datos entre registros.\nInstrucciones de entrada/salida. Facilitan la comunicación entre la CPU y los dispositivos de entrada/salida, como discos duros, teclados, pantallas y otros.\nInstrucciones de comparación. Comparan valores y, a menudo, se usan junto con las instrucciones de control de flujo (ej. condicionales, ciclos) para tomar decisiones basadas en estas comparaciones.\nInstrucciones de operación de punto flotante. Específicas para el procesamiento de números de punto flotante, permiten realizar operaciones aritméticas sobre estos números, que son fundamentales para el cálculo científico y la ingeniería.\n\nCada instrucción en el lenguaje máquina se representa como una secuencia de bits, y el conjunto específico de instrucciones que un procesador puede ejecutar se conoce como su conjunto de instrucciones o Instruction Set Architecture (ISA).\nLa Figura 1.10 muestra una instrucción en lenguaje máquina que suma los contenidos de los registros 1 y 2 y almacena el resultado en el registro 6 de un CPU:\n\n\n\n\n\n\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\n\n\n\nLa Figura 1.11 muestra el programa Hola mundo (Hello World) en lenguaje máquina. Este programa simplemente imprime la hilera de texto “Hola mundo”, usualmente en la pantalla, y suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico.\n\n\n\n\n\n\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-modelo-entrada---procesamiento---salida",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-modelo-entrada---procesamiento---salida",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.4 El modelo Entrada - Procesamiento - Salida",
    "text": "1.4 El modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida describe la estructura básica de un algoritmo o de un programa de computación. De acuerdo con este modelo, un programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura.\n\nEntradas: \\(masa\\) (kg), \\(estatura\\) (m)\n\nProcesamiento: \\(imc = masa/estatura^2\\)\n\nSalida: \\(imc\\)\n\nA manera de ejercicio, calcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#la-máquina-de-turing",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#la-máquina-de-turing",
    "title": "1  Arquitectura de computadoras, pensamiento computacional y lenguajes de programación",
    "section": "1.5 La máquina de Turing",
    "text": "1.5 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.4 presenta una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.4: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, pensamiento computacional y lenguajes de programación</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#lenguajes-de-programación",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#lenguajes-de-programación",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.5 Lenguajes de programación",
    "text": "1.5 Lenguajes de programación\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. A manera de ejemplo, seguidamente se muestra el programa “Hola mundo” en varios lenguajes de programación:\nLenguaje C\n/* Hola mundo en lenguaje C */\n\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(\"Hola mundo\\n\");\n}\nLenguaje Python\n# Hola mundo en lenguaje Python\n\nprint(\"Hola mundo\")\nLenguaje R\n# Hola mundo en lenguaje R\n\ncat(\"Hola mundo\\n\")\nEl sitio web The Hello World Collection presenta el programa “Hola mundo” en más de 600 lenguajes de programación. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#pensamiento-computacional",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#pensamiento-computacional",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.6 Pensamiento computacional",
    "text": "1.6 Pensamiento computacional\nComo se ha mencionado, utilizamos computadoras porque nos ayudan a resolver problemas. La forma de solucionar un problema debe expresarse de manera que pueda ser implementada en una computadora: mediante programación (vea la Figura 1.12).\n\n\n\n\n\n\nFigura 1.12: Resolución de problemas mediante computadoras.\n\n\n\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Puede ser aplicado en otras áreas. Se considera una de las destrezas fundamentales del siglo XXI.\n\n1.6.1 Principios fundamentales\nEl pensamiento computacional tiene cuatro principios fundamentales:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes de un problema a resolver, con problemas ya resueltos.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.3 Conceptos fundamentales sobre programación de computadoras",
    "text": "1.3 Conceptos fundamentales sobre programación de computadoras\nEn esta sección, se detallan algunos conceptos básicos sobre programación de computadoras, incluyendo los algoritmos y el modelo Entrada - Procesamiento - Salida.\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones entre los que, por ejemplo, pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un elemento está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos (ej. listas, vectores, matrices) o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresar esta solución en una secuencia de pasos claramente definidos. A estas secuencias se les denomina algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como una receta de cocina o tan complejo como los que se utilizan en aprendizaje automático (machine learning).\nUn algoritmo debe cumplir con ciertas características básicas:\n\nRecibir entradas: datos con los que trabaja.\nGenerar salidas: resultados generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, un diagrama de flujo o simplemente una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Lea la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, despliegue la hilera de texto \"Lista vacía\" \n   y concluya el algoritmo. Si no, continúe con el paso 3.\n3. Designe el primer elemento de la lista como \"máximo actual\".\n4. Recorra la lista y compare cada uno de los elementos con el máximo actual.\n   4.1. Si un elemento comparado es mayor que el máximo actual, \n        entonces desígnelo como el nuevo máximo actual.\n5. Al finalizar el recorrido de la lista, imprima el máximo actual\n   como valor máximo de la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.6, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual. 4.1. Si un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nAl finalizar el recorrido de la lista, se imprime el máximo actual como valor máximo de la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\nNote además que el algoritmo incluye:\n\nLectura de entradas: la lista.\n\nProcesamiento de las entradas: recorrido de la lista y comparaciones entre sus elementos.\n\nGeneración de salidas: el valor máximo de la lista.\n\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida (Input - Process - Output o IPO) describe la estructura básica de un algoritmo o de un programa de cómputo. Es un concepto fundamental en computación que describe el flujo de trabajo básico que emplean los sistemas para procesar información o datos. De acuerdo con este modelo, un algoritmo o programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nA continuación se describen los componentes del modelo:\n\nEntrada (Input): consiste de datos o información que recibe el sistema. Pueden venir en diversas formas, como señales electrónicas, datos tecleados por un usuario o archivos, entre otros. La calidad y precisión de la entrada pueden afectar significativamente el resultado final del proceso.\nProcesamiento (Process): Una vez que los datos de entrada son recibidos, el sistema los procesa de acuerdo con un conjunto de instrucciones o pasos. El procesamiento puede involucrar operaciones como cálculos matemáticos, operaciones lógicas, transformaciones o cualquier otra acción necesaria para generar la salida que se requiere. En este componente es usualmente donde se realiza el “trabajo” principal del sistema.\nSalida (Output): Una vez finalizado el procesamiento, el sistema genera una salida. La salida es el resultado del proceso y puede presentarse en varias formas, como una visualización en pantalla, un archivo o un documento impreso, entre otras posibilidades. La salida puede ser el final del algoritmo o programa o puede servir como entrada para otro algoritmo o programa.\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura. El IMC necesita dos entradas: masa (en kilogramos) y estatura (en metros). El procesamiento se realiza mediante la fórmula: imc = imc = masa/estatura2.\nEntonces, un posible algoritmo para calcular el IMC de una persona es:\n\nLea la masa y la estatura de la persona.\nCalcule el imc mediante la fórmula: imc = masa/estatura2.\nImprima el imc.\n\nEjercicios\nCalcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjercicios\n\nEjecute los programas anteriores en R y Python en los siguientes ambientes de ejecución en línea. Solamente debe copiar cada programa en el espacio destinado para ese fin y presionar el botón Run (ejecutar, correr).\n\nAmbiente de ejecución en línea para Python\nAmbiente de ejecución en línea para R\n\nCon base en la descripción del IMC brindada en la sección anterior, elabore una hoja electrónica que calcule el IMC para 10 personas. Considere como incluir los componentes de entrada, procesamiento y salida.\nCon base en el algoritmo descrito en la sección para el cálculo del IMC, elabore un programa en Python y otro programa en R que calculen el IMC de una persona.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-lenguaje-de-programación-scratch",
    "href": "01-arquitectura_computadoras-pensamiento_computacional-lenguajes_programacion.html#el-lenguaje-de-programación-scratch",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.7 El lenguaje de programación Scratch",
    "text": "1.7 El lenguaje de programación Scratch\nScratch es un lenguaje de programación orientado a educación. Su nombre proviene de la palabra en ingés scratching. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita. Es software libre que se comparte mediante una licencia GPLv2.\n\n1.7.1 Aplicación de los principios del pensamiento computacional\n\nIngrese a la sitio web de Scratch en la dirección https://scratch.mit.edu/ y presione el botón Start Creating o Empiezo a crear para iniciar un proyecto (para este curso, no es necesario crear un usuario en el sitio). Se desplegará el ambiente de programación de Scratch.\n\n\n\n\n\n\n\nFigura 1.13: Ambiente de programación de Scratch.\n\n\n\nEl ambiente de programación de Scratch está compuesto por varias zonas. Seguidamente se describen algunas de las principales:\n\nUn área de bloques, a la izquierda de la pantalla, los cuales ejecutan tareas: mover, girar, ir a, etc. Estos bloques se agrupan en secciones: Movimiento, Apariencia, Sonido, etc.\nUn área en el centro de la pantalla al que pueden arrastrarse los bloques con el ratón para unirse y acoplarse.\nUn área en la parte superior derecha de la pantalla en la que se despliega el resultado de las tareas ejecutadas por los bloques.\nUn botón ubicado en la esquina inferior izquierda de la pantalla llamado Agregar Extensión. En el contexto de Scratch, una extensión es un grupo de tareas adicional a los bloques que se despliegan por defecto. Las extensiones pueden ser desarrolladas por programadores diferentes a los creadores de Scratch.\n\nNota: si lo desea, puede cambiar el idioma a español, u otro de su preferencia, con la opción de menú Settings - Language.\n\nCon el bloque decir de la sección Apariencia, programe el programa “Hola Mundo” en Scratch. Utilice el evento al presionar de la sección Eventos para poder ejecutar el programa al presionar la bandera de salida.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Código fuente\n\n\n\n\n\n\n\n\n\n\n\n(b) Salida\n\n\n\n\n\n\n\nFigura 1.14: Programa “Hola mundo”\n\n\n\nCon la opción de menú Archivo - Guardar en tu computador, guarde el programa en un archivo. Puede cargarlo con la opción de menú Archivo - Subir desde tu computador.\n\nProblema a resolver: dibujar un paisaje como el que se muestra en la figura de abajo.\n\n\n\n\n\n\n\nFigura 1.15: Paisaje.\n\n\n\nPara comenzar, dibuje un par de casas. Se sugiere agregar la extensión Lápiz y bloques como bajar lápiz, subir lápiz, borrar todo, mover, girar, ir a, apuntar en dirección y cualquier otro que le sea útil.\n\n1.7.1.1 Descomposición\nDivisión de un problema en subproblemas más pequeños\n\nIdentifique subproblemas en los que se pueda dividir el problema general (ej. figuras geométricas) y agrupe los bloques correspondientes a cada subproblema.\nPara cada subproblema, cree un bloque nuevo con Crear un bloque en la sección Mis bloques.\nUtilice estructuras de control como repetir en la sección Control para realizar tareas repetitivas.\n\n\n\n1.7.1.2 Reconocimiento de patrones\nBúsqueda de similitudes de un problema a resolver, con problemas ya resueltos\n\nBusque problemas conocidos similares a los que está resolviendo (ej. dibujos de figuras geométricas) y aplique las soluciones.\n\n\n\n1.7.1.3 Abstracción\nFiltrado de la información que se necesita y de la que no se necesita para resolver un problema.\n\nIdentifique los elementos de información que necesita para resolver los subproblemas que ha identificado (ej. tamaños, ángulos). Trate de usarlos como entrada de los bloques que creó.\n\n\n\n1.7.1.4 Algoritmos\nDescripción, paso por paso, de la solución a un problema.\n\nDescriba un algoritmo para la solución al problema.\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.\nFigura 1.12: Resolución de problemas mediante computadoras.\nFigura 1.13: Ambiente de programación de Scratch.\nFigura 1.15: Paisaje.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "1.1 Resumen\nUna computadora es una máquina que ejecuta secuencias de instrucciones, llamadas programas. La capacidad que tienen las computadoras de ser programadas permite modificar sus funcionamiento sin necesidad de alterar sus componentes físicos, lo que permite que ayuden a resolver una gran cantidad de problemas. Las secuencias de pasos describen la solución a un problema se denominan algoritmos. En un algoritmo recibe datos de entrada, los procesa y genera salidas. Un algoritmo puede ser implementado en diferentes lenguajes de programación.\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips. Los circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los circuitos integrados de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la teoría de la información y del álgebra booleana.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Sus componentes principales son la memoria principal, la unidad central de procesamiento (CPU) y los sistemas de entrada y salida.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por la CPU de una computadora. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Debido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales y otros.\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#resumen",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#resumen",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "",
    "text": "Descomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#trabajo-previo",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#trabajo-previo",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas y videos\nCS50 (Director). (2024). CS50x 2024—Lecture 0—Scratch. https://www.youtube.com/watch?v=3LPJfIKxwWc\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#conceptos-fundamentales-sobre-programación-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.3 Conceptos fundamentales sobre programación de computadoras",
    "text": "1.3 Conceptos fundamentales sobre programación de computadoras\nEn esta sección, se detallan algunos conceptos básicos sobre programación de computadoras, incluyendo los algoritmos y el modelo Entrada - Procesamiento - Salida.\n\n1.3.1 Programabilidad\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones llamadas programas. Las instrucciones de los programas realizan diversos tipos de operaciones entre los que, por ejemplo, pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un elemento está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos (ej. listas, vectores, matrices) o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la resolución de un problema, es necesario expresar esta solución en una secuencia de pasos claramente definidos. A estas secuencias se les denomina algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como una receta de cocina o tan complejo como los que se utilizan en aprendizaje automático (machine learning).\nUn algoritmo debe cumplir con ciertas características básicas:\n\nRecibir entradas: datos con los que trabaja.\nGenerar salidas: resultados generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, un diagrama de flujo o simplemente una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Lea la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, despliegue la hilera de texto \"Lista vacía\" \n   y concluya el algoritmo. Si no, continúe con el paso 3.\n3. Designe el primer elemento de la lista como \"máximo actual\".\n4. Recorra la lista y compare cada uno de los elementos con el máximo actual.\n   4.1. Si un elemento comparado es mayor que el máximo actual, \n        entonces desígnelo como el nuevo máximo actual.\n5. Al finalizar el recorrido de la lista, imprima el máximo actual\n   como valor máximo de la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.6, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual. 4.1. Si un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nAl finalizar el recorrido de la lista, se imprime el máximo actual como valor máximo de la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\nNote además que el algoritmo incluye:\n\nLectura de entradas: la lista.\n\nProcesamiento de las entradas: recorrido de la lista y comparaciones entre sus elementos.\n\nGeneración de salidas: el valor máximo de la lista.\n\n\n\n1.3.3 Modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida (Input - Process - Output o IPO) describe la estructura básica de un algoritmo o de un programa de cómputo. Es un concepto fundamental en computación que describe el flujo de trabajo básico que emplean los sistemas para procesar información o datos. De acuerdo con este modelo, un algoritmo o programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nA continuación se describen los componentes del modelo:\n\nEntrada (Input): consiste de datos o información que recibe el sistema. Pueden venir en diversas formas, como señales electrónicas, datos tecleados por un usuario o archivos, entre otros. La calidad y precisión de la entrada pueden afectar significativamente el resultado final del proceso.\nProcesamiento (Process): Una vez que los datos de entrada son recibidos, el sistema los procesa de acuerdo con un conjunto de instrucciones o pasos. El procesamiento puede involucrar operaciones como cálculos matemáticos, operaciones lógicas, transformaciones o cualquier otra acción necesaria para generar la salida que se requiere. En este componente es usualmente donde se realiza el “trabajo” principal del sistema.\nSalida (Output): Una vez finalizado el procesamiento, el sistema genera una salida. La salida es el resultado del proceso y puede presentarse en varias formas, como una visualización en pantalla, un archivo o un documento impreso, entre otras posibilidades. La salida puede ser el final del algoritmo o programa o puede servir como entrada para otro algoritmo o programa.\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura. El IMC necesita dos entradas: masa (en kilogramos) y estatura (en metros). El procesamiento se realiza mediante la fórmula: imc = imc = masa/estatura2.\nEntonces, un posible algoritmo para calcular el IMC de una persona es:\n\nLea la masa y la estatura de la persona.\nCalcule el imc mediante la fórmula: imc = masa/estatura2.\nImprima el imc.\n\nEjercicios\nCalcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjercicios\n\nEjecute los programas anteriores en R y Python en los siguientes ambientes de ejecución en línea. Solamente debe copiar cada programa en el espacio destinado para ese fin y presionar el botón Run (ejecutar, correr).\n\nAmbiente de ejecución en línea para Python\nAmbiente de ejecución en línea para R\n\nCon base en la descripción del IMC brindada en la sección anterior, elabore una hoja electrónica que calcule el IMC para 10 personas. Considere como incluir los componentes de entrada, procesamiento y salida.\nCon base en el algoritmo descrito en la sección para el cálculo del IMC, elabore un programa en Python y otro programa en R que calculen el IMC de una persona.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#arquitectura-de-computadoras",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#arquitectura-de-computadoras",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.4 Arquitectura de computadoras",
    "text": "1.4 Arquitectura de computadoras\nEn esta sección, se explican los principales componentes de las computadoras modernas. Se realiza un recorrido por algunos de los principales antecedentes históricos de su evolución y se detallan los componentes de la arquitectura de von Neumann, el modelo de arquitectura más utilizado en la actualidad.\n\n1.4.1 Evolución histórica\n\n1.4.1.1 Calculadoras mecánicas\nDurante el siglo XVII, varios matemáticos construyeron calculadoras mecánicas capaces de realizar operaciones aritméticas.\nAlrededor de 1645, el filósofo y matemático francés Blaise Pascal (1623-1662) inventó la Pascalina, una calculadora compuesta por ruedas y engranajes que podía sumar y restar. Pascal la creó con el propósito de ayudar a su padre, quien era contador en la Hacienda francesa y necesitaba una herramienta para realizar cálculos de aritmética comercial de manera más eficiente. La Pascalina podía sumar hasta tres partes en una sola operación, llegando al valor de 999 999.\nEn 1672, el científico alemán Gottfried Leibniz (1646 - 1716) extendió las ideas de Pascal e introdujo la Stepped Reckoner o máquina de Leibniz, un dispositivo que, además de sumar y restar, podía multiplicar, dividir y calcular raíces cuadradas. La máquina de Leibniz estaba basada en un dispositivo llamado rueda de Leibniz, un tambor con forma de cilindro, con un conjunto de dientes de longitud incremental a la que se le acopla una rueda de conteo. La Figura 1.2 muestra una réplica de la máquina de Leibniz.\n\n\n\n\n\n\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\n\n\n\nEl objetivo de Leibniz era realizar cálculos de una manera “fácil, rápida y fiable”. También pretendía que los números calculados pudieran ser tan grandes como se deseara, si el tamaño de la máquina era ajustado. Sin embargo, las primeras versiones de la rueda de Leibniz no eran fiables debido a que tenían piezas mecánicas que tendían a trabarse y a fallar.\nLos derivados de las calculadoras mecánicas creadas por Pascal y Leibniz continuaron siendo producidos durante tres siglos, hasta que a principios de los años 1970 sus equivalentes electrónicos finalmente llegaron a ser fácilmente disponibles y baratos.\n\n\n1.4.1.2 La máquina analítica de Babbage\nEn la primera mitad del siglo XIX, el matemático británico Charles Babbage (1791 - 1871) diseñó la máquina analítica, una computadora mecánica que incorporaba algunas características de las computadoras modernas. Fue inicialmente descrita en 1837, aunque Babbage continuó refinando el diseño hasta su muerte en 1871. Es considerada la primera computadora programable de la historia. La máquina analítica de Babbage se muestra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\n\n\n\nAunque nunca fue terminada debido a limitaciones técnicas y económicas, su diseño revolucionario permitía realizar cálculos complejos y programarla para diversas tareas. Utilizaba tarjetas perforadas para la entrada de datos, disponía de una unidad aritmética para realizar operaciones matemáticas y una memoria capaz de almacenar hasta 1000 números. El lenguaje de programación que sería utilizado era similar a los actuales lenguajes ensambladores. Era posible implementar ciclos y condicionales de manera que el lenguaje propuesto habría sido Turing-completo.\nEn 1843, la matemática británica Ada Lovelace (1815 - 1852) tradujo al inglés una descripción de la máquina analítica escrita en francés un año antes por el matemático italiano Luigi Menabrea (1809 - 1896). Entre las notas que acompañan la traducción, Lovelace incluyó el detalle de los pasos mediante los cuales la máquina podría calcular los números de Bernoulli, lo que se considera por algunos el primer programa de computadoras de la historia. El diagrama correspondiente a este algoritmo/programa se muestra en la Figura 1.4.\n\n\n\n\n\n\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\n\n\n\nAhora se cree que el autor de este programa fue probablemente el mismo Charles Babbage, que ya había desarrollado trabajos similares entre seis y siete años antes de la publicación del artículo de Lovelace.\nEl aporte de Ada Lovelace fue de suma importancia para la computación, ya que fue la primera en reconocer la capacidad de las máquinas para ir más allá de los simples cálculos de números. Acertadamente, anticipó que en el futuro podrían hacer muchas otras cosas, como componer música o generar gráficos. En sus notas, Lovelace enfatizó la diferencia entre la máquina analítica y las máquinas de cálculo previas, en particular su capacidad de ser programada para resolver problemas de mayor complejidad.\n\n\n1.4.1.3 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.5 muestra una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\n\n\n\nUna máquina de Turing está compuesta por:\n\nUna cinta: actúa como memoria de la máquina. Se compone de celdas, cada una de las cuales puede contener un símbolo (ej. una letra, un número).\nUna cabeza lectora/escritora: lee y escribe símbolos en la cinta.\nUn conjunto de estados: entre los cuales la máquina puede cambiar en respuesta a lo que lee en la cinta. Hay un estado inicial desde el cual el funcionamiento de la máquina comienza, y uno o más estados de parada que indican que la máquina ha terminado su computación.\nUna tabla de acciones: indica para combinación de estado actual y símbolo leído en la cinta, qué acción debe realizar la máquina. Estas acciones incluyen leer o escribir un símbolo en la cinta, mover la cabeza lectora/escritora a la izquierda o a la derecha sobre la cinta y cambiar a un nuevo estado.\n\nCon este esquema, una máquina de Turing puede ejecutar cualquier algoritmo. El modelo de Turing demostró que una máquina simple podía resolver cualquier problema computable, si cuenta con el tiempo y los recursos necesarios. Si un sistema (ej. una computadora, un lenguaje de programación) puede utilizarse para resolver cualquier problema de cómputo, se dice que es Turing-completo. No todos los sistemas o lenguajes de programación son Turing-completos, ya que algunos están diseñados para propósitos específicos y pueden tener restricciones que limitan su capacidad de cálculo.\nAllan Turing es considerado uno de los padres de la computación moderna. Sus contribuciones fueron fundamentales en el desarrollo de la teoría de la computación y la inteligencia artificial. En esta última área, Turing propuso un experimento para determinar si una máquina puede exhibir inteligencia equivalente a la de un ser humano. Este experimento, conocido como Prueba de Turing, sigue siendo una referencia en el debate sobre la inteligencia artificial.\n\n\n1.4.1.4 Primeras computadoras electrónicas\nCon base en las ideas de Turing, las computadoras de tipo Bombe y Colossus fueron construídas durante la II Guerra Mundial (1939 - 1945) en el Reino Unido para descifrar mensajes codificados. A pesar de que se consideran de las primeras computadoras digitales electrónicas programables, su programación se realizaba a través de componentes de hardware, como interruptores y enchufes, y no con un programa almacenado en la memoria. La Figura 1.6 muestra una computadora Colossus.\n\n\n\n\n\n\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\n\n\n\nTambién durante la II Guerra Mundial, el ejército de Estados Unidos de América construyó ENIAC (Electronic Numerical Integrator and Computer) para calcular tablas de tiro de artillería. Es considerada por algunos como la primera computadora programable digital de propósito general. Era capaz de seguir el modelo de la máquina de Turing, por lo que era Turing-completa. La Figura 1.7 presenta una imagen de ENIAC.\n\n\n\n\n\n\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\n\n\n\n\n\n\n1.4.2 La arquitectura de von Neumann\nEn 1945, el matemático húngaro - estadounidense John von Neumann (1903 - 1957) propuso un concepto conocido como programa almacenado según el cual los datos y los programas de una computadora se almacenan en una estructura llamada memoria, separada de los componentes que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Su esquema se muestra en la Figura 1.8.\n\n\n\n\n\n\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\nLos principales componentes de esta arquitectura son:\n\nMemoria principal. Almacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como Random Access Memory (Memoria de Acceso Aleatorio) o RAM, ya que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\nUnidad central de procesamiento. Llamada en inglés Central Processing Unit (CPU), se encarga de ejecutar las instrucciones de los programas. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros para almacenar los operandos y el resultado de las instrucciones. Está compuesta por dos partes principales:\n\nUnidad de control. Determina cuál es la siguiente instrucción a ejecutar.\nUnidad de aritmética y lógica. Llamada en inglés Arithmetic and Logic Unit (ALU), ejecuta las operaciones aritméticas y lógicas.\n\nSistemas de entrada y salida. Permiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\n1.4.3 Sistemas binarios\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips, como el que se muestra en la Figura 1.9.\n\n\n\n\n\n\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\n\n\n\nLos circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria, lo que significa que puede tener dos valores. Para representar estos dos valores internamente, las computadoras emplean dos niveles de tensión eléctrica: bajo (o ausencia de tensión) y alto (o presencia de tensión eléctrica). Estos estados se representan respectivamente con 0 y 1 (o viceversa). Este es un sistema binario y cada dígito binario se denomina bit (binary digit). Los bits se agrupan en grupos de ocho llamados bytes) para representar elementos de información más complejos, como números más grandes o carácteres de texto. Por ejemplo:\n\nEl número decimal 14 se representa en binario como 1110:\n1110 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 = 8 + 4 + 2 + 0 = 14\nLa palabra bit se representa en código ASCII como:\n01100010 01101001 01110100 = bit\n\nDe manera similar, se pueden representar otras clases de información, como imágenes, sonidos o videos, mediante secuencias de dígitos binarios.\n\n1.4.3.1 Ventajas\nEl uso de dos estados (en lugar de diez, doce u otra cantidad) facilita la aplicación de la teoría de la información, el estudio matemático de la cuantificación, almacenamiento y comunicación de la información, en el cual los bits son la unidad fundamental. La teoría de la información fue proṕuesta por el matemático estadounidense Claude Shannon (1916 - 2001) en la década de 1940.\nEl álgebra booleana, un pilar fundamental en el campo del análisis y diseño de sistemas digitales, así como en la programación de computadoras, también utiliza dos posibles valores: verdadero (1) y falso (0). Fue introducida en 1847 por el matemático británico George Boole (1815 - 1864). El álgebra booleana utiliza operaciones lógicas como AND (y), OR (o) y NOT (no) para combinar y transformar valores booleanos (verdaderos y falsos).\nPor otra parte, es más fácil diseñar y fabricar dispositivos electrónicos que solo necesitan reconocer dos estados. Por esta razón, los circuitos que manejan señales binarias pueden ser más simples, más confiables y menos costosos que aquellos que tendrían que manejar múltiples estados.\n\n\n\n1.4.4 Lenguaje máquina\nEl lenguaje máquina es un conjunto de instrucciones binarias (compuestas por unos y ceros) interpretables por un CPU. Un programa consiste de una secuencia de instrucciones en lenguaje máquina. Este es el único lenguaje que “entienden” directamente las computadoras.\nEl lenguaje máquina, siendo el más bajo nivel de lenguaje de programación y directamente entendible por el hardware del procesador, incluye varios tipos de instrucciones esenciales para la operación de una computadora. Estas instrucciones varían según la arquitectura del procesador (ej. x86, ARM, MIPS), pero generalmente se pueden agrupar en categorías como, por ejemplo:\n\nInstrucciones de aritmética y lógica. Realizan operaciones matemáticas básicas como suma, resta, multiplicación y división, así como operaciones lógicas como AND, OR y NOT.\nInstrucciones de manipulación de datos. Permiten el movimiento de datos dentro de la CPU o entre la CPU y la memoria. Ejemplos incluyen la carga (load) de datos desde la memoria al registro, almacenamiento (store) de datos del registro a la memoria, y transferencias de datos entre registros.\nInstrucciones de entrada/salida. Facilitan la comunicación entre la CPU y los dispositivos de entrada/salida, como discos duros, teclados, pantallas y otros.\nInstrucciones de comparación. Comparan valores y, a menudo, se usan junto con las instrucciones de control de flujo (ej. condicionales, ciclos) para tomar decisiones basadas en estas comparaciones.\nInstrucciones de operación de punto flotante. Específicas para el procesamiento de números de punto flotante, permiten realizar operaciones aritméticas sobre estos números, que son fundamentales para el cálculo científico y la ingeniería.\n\nCada instrucción en el lenguaje máquina se representa como una secuencia de bits, y el conjunto específico de instrucciones que un procesador puede ejecutar se conoce como su conjunto de instrucciones o Instruction Set Architecture (ISA).\nLa Figura 1.10 muestra una instrucción en lenguaje máquina que suma los contenidos de los registros 1 y 2 y almacena el resultado en el registro 6 de un CPU:\n\n\n\n\n\n\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\n\n\n\nLa Figura 1.11 muestra el programa Hola mundo (Hello World) en lenguaje máquina. Este programa simplemente imprime la hilera de texto “Hola mundo”, usualmente en la pantalla, y suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico.\n\n\n\n\n\n\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#lenguajes-de-programación",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#lenguajes-de-programación",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.5 Lenguajes de programación",
    "text": "1.5 Lenguajes de programación\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. A manera de ejemplo, seguidamente se muestra el programa “Hola mundo” en varios lenguajes de programación:\nLenguaje C\n/* Hola mundo en lenguaje C */\n\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(\"Hola mundo\\n\");\n}\nLenguaje Python\n# Hola mundo en lenguaje Python\n\nprint(\"Hola mundo\")\nLenguaje R\n# Hola mundo en lenguaje R\n\ncat(\"Hola mundo\\n\")\nEl sitio web The Hello World Collection presenta el programa “Hola mundo” en más de 600 lenguajes de programación. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#pensamiento-computacional",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#pensamiento-computacional",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.6 Pensamiento computacional",
    "text": "1.6 Pensamiento computacional\nComo se ha mencionado, utilizamos computadoras porque nos ayudan a resolver problemas. La forma de solucionar un problema debe expresarse de manera que pueda ser implementada en una computadora: mediante programación (vea la Figura 1.12).\n\n\n\n\n\n\nFigura 1.12: Resolución de problemas mediante computadoras.\n\n\n\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Puede ser aplicado en otras áreas. Se considera una de las destrezas fundamentales del siglo XXI.\n\n1.6.1 Principios fundamentales\nEl pensamiento computacional tiene cuatro principios fundamentales:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes de un problema a resolver, con problemas ya resueltos.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#el-lenguaje-de-programación-scratch",
    "href": "01-arquitectura_computadoras-lenguajes_programacion-pensamiento_computacional.html#el-lenguaje-de-programación-scratch",
    "title": "1  Arquitectura de computadoras, lenguajes de programación y pensamiento computacional",
    "section": "1.7 El lenguaje de programación Scratch",
    "text": "1.7 El lenguaje de programación Scratch\nScratch es un lenguaje de programación orientado a educación. Su nombre proviene de la palabra en ingés scratching. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita. Es software libre que se comparte mediante una licencia GPLv2.\n\n1.7.1 Aplicación de los principios del pensamiento computacional\n\nIngrese a la sitio web de Scratch en la dirección https://scratch.mit.edu/ y presione el botón Start Creating o Empiezo a crear para iniciar un proyecto (para este curso, no es necesario crear un usuario en el sitio). Se desplegará el ambiente de programación de Scratch.\n\n\n\n\n\n\n\nFigura 1.13: Ambiente de programación de Scratch.\n\n\n\nEl ambiente de programación de Scratch está compuesto por varias zonas. Seguidamente se describen algunas de las principales:\n\nUn área de bloques, a la izquierda de la pantalla, los cuales ejecutan tareas: mover, girar, ir a, etc. Estos bloques se agrupan en secciones: Movimiento, Apariencia, Sonido, etc.\nUn área en el centro de la pantalla al que pueden arrastrarse los bloques con el ratón para unirse y acoplarse.\nUn área en la parte superior derecha de la pantalla en la que se despliega el resultado de las tareas ejecutadas por los bloques.\nUn botón ubicado en la esquina inferior izquierda de la pantalla llamado Agregar Extensión. En el contexto de Scratch, una extensión es un grupo de tareas adicional a los bloques que se despliegan por defecto. Las extensiones pueden ser desarrolladas por programadores diferentes a los creadores de Scratch.\n\nNota: si lo desea, puede cambiar el idioma a español, u otro de su preferencia, con la opción de menú Settings - Language.\n\nCon el bloque decir de la sección Apariencia, programe el programa “Hola Mundo” en Scratch. Utilice el evento al presionar de la sección Eventos para poder ejecutar el programa al presionar la bandera de salida.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Código fuente\n\n\n\n\n\n\n\n\n\n\n\n(b) Salida\n\n\n\n\n\n\n\nFigura 1.14: Programa “Hola mundo”\n\n\n\nCon la opción de menú Archivo - Guardar en tu computador, guarde el programa en un archivo. Puede cargarlo con la opción de menú Archivo - Subir desde tu computador.\n\nProblema a resolver: dibujar un paisaje como el que se muestra en la figura de abajo.\n\n\n\n\n\n\n\nFigura 1.15: Paisaje.\n\n\n\nPara comenzar, dibuje un par de casas. Se sugiere agregar la extensión Lápiz y bloques como bajar lápiz, subir lápiz, borrar todo, mover, girar, ir a, apuntar en dirección y cualquier otro que le sea útil.\n\n1.7.1.1 Descomposición\nDivisión de un problema en subproblemas más pequeños\n\nIdentifique subproblemas en los que se pueda dividir el problema general (ej. figuras geométricas) y agrupe los bloques correspondientes a cada subproblema.\nPara cada subproblema, cree un bloque nuevo con Crear un bloque en la sección Mis bloques.\nUtilice estructuras de control como repetir en la sección Control para realizar tareas repetitivas.\n\n\n\n1.7.1.2 Reconocimiento de patrones\nBúsqueda de similitudes de un problema a resolver, con problemas ya resueltos\n\nBusque problemas conocidos similares a los que está resolviendo (ej. dibujos de figuras geométricas) y aplique las soluciones.\n\n\n\n1.7.1.3 Abstracción\nFiltrado de la información que se necesita y de la que no se necesita para resolver un problema.\n\nIdentifique los elementos de información que necesita para resolver los subproblemas que ha identificado (ej. tamaños, ángulos). Trate de usarlos como entrada de los bloques que creó.\n\n\n\n1.7.1.4 Algoritmos\nDescripción, paso por paso, de la solución a un problema.\n\nDescriba un algoritmo para la solución al problema.\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\nFigura 1.10: Instrucción en lenguaje máquina. Imagen de Wikipedia.\nFigura 1.11: Programa Hola mundo en lenguaje máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.\nFigura 1.12: Resolución de problemas mediante computadoras.\nFigura 1.13: Ambiente de programación de Scratch.\nFigura 1.15: Paisaje.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Arquitectura de computadoras, lenguajes de programación y pensamiento computacional</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "2.1 Resumen\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento de datos. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento. Incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Trabajo previo",
    "text": "2.2 Trabajo previo\n\n2.2.1 Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/ (capítulo 1)\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulo introductorio)",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#estadística",
    "href": "02-introduccion-ciencia-datos.html#estadística",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Estadística",
    "text": "2.3 Estadística\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos (Çetinkaya-Rundel & Hardin, 2021).\n\n2.3.1 Datos\nLa presentación y descripción efectivas de los datos es el primer paso en un análisis (Çetinkaya-Rundel & Hardin, 2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.3.1.1 Observaciones y variables\nLa tabla 2.1. contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\nTabla 2.1.\n\n\n\n\nid\n\n\nprovincia\n\n\nequipo\n\n\nmasa\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n1\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\notro\n\n\n0\n\n\nnulo\n\n\n\n\n2\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n3\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n4\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n5\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n6\n\n\notra\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n7\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n8\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n9\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n10\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.3.1.2 Tipos de variables\nLos datos de la tabla 2.1. son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\n\n\n\n\n2.3.1.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares.\n\n2.3.1.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no es posible tener 2.5 hermanos.\n\n\n2.3.1.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables masa y estatura son continuas.\n\n\n\n2.3.1.2.2 Categóricas\n\n2.3.1.2.2.1 Nominales\n\n\n2.3.1.2.2.2 Ordinales",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Ciencia de datos",
    "text": "2.4 Ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento (Wickham, Çetinkaya-Rundel, & Grolemund, 2023). Utiliza estadística y ciencias de la computación, entre otras disciplinas.\nLa Figura 4.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias",
    "href": "02-introduccion-ciencia-datos.html#referencias",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias",
    "text": "2.5 Referencias\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nGandrud, C. (2020). Reproducible research with R and\nRStudio (Third edition). Boca Raton, FL: CRC Press.\n\n\nPeng, R. D. (2011). Reproducible Research in\nComputational Science. Science,\n334(6060), 1226–1227. https://doi.org/10.1126/science.1213847\n\n\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing\na framework for Open Geographic\nInformation science. International Journal of\nGeographical Information Science, 30(8), 1507–1521. https://doi.org/10.1080/13658816.2015.1137579\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\nFigura 2.2: Modelo de ciencia de datos. Fuente: R for Data Science.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Datos",
    "text": "2.3 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis (Çetinkaya-Rundel & Hardin, 2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.3.1 Observaciones y variables\nLa tabla 2.1. contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\nTabla 2.1.\n\n\n\n\nid\n\n\nprovincia\n\n\nequipo\n\n\nmasa\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n1\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\notro\n\n\n0\n\n\nnulo\n\n\n\n\n2\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n3\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n4\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n5\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n6\n\n\notra\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n7\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n8\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n9\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n10\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.3.2 Tipos de variables\nLos datos de la tabla 2.1. son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables. Fuente: Introduction to Modern Statistics.\n\n\n\n\n2.3.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares.\n\n2.3.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no es posible tener 2.5 hermanos.\n\n\n2.3.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables masa y estatura son continuas.\n\n\n\n2.3.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y clasifican las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades numéricas, las variables categóricas expresan atributos no numéricos.\n\n2.3.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.3.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra es categórica.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico\n4 Tidyverse - colección de paquetes para ciencia de datos",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "3.1 Resumen\nR es un lenguaje de programación y un entorno para graficación y análisis estadístico. Como lenguaje, es interpretado, multiplataforma, de tipado dinámico y multiparadigma. Es un proyecto de software libre que se comparte mediante una licencia GNU GPL.\nEl código de R se estructura en funciones, las cuales se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. Algunos paquetes están incorporados en la instalación base de R y otros deben instalarse separadamente.\nR puede manejar diversos tipos de datos básicos, como números, textos y valores lógicos, entre otros. También tipos de datos compuestos, como factores y data frames. Al igual que otros lenguajes de programación, cuenta con estructuras de control como condicionales y ciclos.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Trabajo previo",
    "text": "3.2 Trabajo previo\n\n3.2.1 Lecturas\nGrolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Introducción",
    "text": "3.3 Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, en inglés Integrated Development Environment) como Jupyter o RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.4 El ambiente de desarrollo integrado RStudio",
    "text": "3.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n1. Instale en su computadora:\na. Sistema base del lenguaje R.\nb. RStudio Desktop.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conjuntos-de-datos-para-pruebas",
    "href": "03-r.html#conjuntos-de-datos-para-pruebas",
    "title": "3  R: lenguaje de programación para análisis estadístico",
    "section": "3.5 Conjuntos de datos para pruebas",
    "text": "3.5 Conjuntos de datos para pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nGapminder\nPapers with Code - conjuntos de datos",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R: lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#funciones",
    "href": "03-r.html#funciones",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.5 Funciones",
    "text": "3.5 Funciones\n\n3.5.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.5.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd().\n2. Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n3.5.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.5.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#paquetes",
    "href": "03-r.html#paquetes",
    "title": "3  R: lenguaje de programación para análisis estadístico",
    "section": "3.7 Paquetes",
    "text": "3.7 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R: lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conjuntos-de-datos-para-ejemplos-y-pruebas",
    "href": "03-r.html#conjuntos-de-datos-para-ejemplos-y-pruebas",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Conjuntos de datos para ejemplos y pruebas",
    "text": "3.6 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\n\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n3.6.1 Funciones\n\n3.6.1.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.6.1.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd().\n2. Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n3.6.1.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.6.1.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.5 Conceptos fundamentales",
    "text": "3.5 Conceptos fundamentales\n\n3.5.1 Manejo de datos\n\n3.5.1.1 Tipos y estructuras de datos\nR maneja los datos en una gran variedad de tipos y estructuras, los cuales incluyen tipos básicos como números, caracteres y lógicos y tipos compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nUna de las herramientas fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Un data frame puede verse como lo que comúmmente se conoce como una tabla de datos (ej. las de las hojas de cálculo). Los data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n\n3.5.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\nGapminder\n\n\n\n\n3.5.2 Funciones\n\n3.5.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.5.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n2. Cambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n3. Con la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n4. Ejecute su programa con los botones Run y Source de RStudio.\n5. Cambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n3.5.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\na. Un título.\nb. Un subtítulo.\n\n\n3.5.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.5.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene datos sobre el destino de los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.5.4 Visualización de datos\n\n3.5.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen, por ejemplo, predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.5.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.5.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.5.5 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.5.5.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.5.5.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.5.5.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.5.5.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.5.5.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.5.5.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.5.5.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.5.5.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.5.5.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.5.5.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.5.5.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.5.5.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.5.5.2 Tipos compuestos\n\n3.5.5.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.5.5.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.5.5.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.5.5.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.5.5.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.5.5.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.5.5.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.5.5.3 Otros\n\n3.5.5.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.5.5.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2024-04-30\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.5.6 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n1. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n2. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n3. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n3.5.7 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.5.7.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.5.7.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.5.7.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n1. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n3.5.8 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.5.8.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n1. Utilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n2. Utilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n3.5.8.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n1. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "examen-corto-01.html",
    "href": "examen-corto-01.html",
    "title": "Examen corto 1",
    "section": "",
    "text": "Fecha",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "examen-corto-01.html#fecha",
    "href": "examen-corto-01.html#fecha",
    "title": "Examen corto 1",
    "section": "",
    "text": "Grupo 001: jueves 11 de abril de 2024\nGrupo 002: miércoles 10 de abril de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "examen-corto-01.html#temas-a-evaluar",
    "href": "examen-corto-01.html#temas-a-evaluar",
    "title": "Examen corto 1",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n1 Arquitectura de computadoras, lenguajes de programación y pensamiento computacional\n2 Introducción a la ciencia de datos\n3 R - lenguaje de programación para análisis estadístico (hasta la sección “3.5.4 Visualización de datos” inclusive)",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 1"
    ]
  },
  {
    "objectID": "parte-vii-evaluaciones.html",
    "href": "parte-vii-evaluaciones.html",
    "title": "Evaluaciones",
    "section": "",
    "text": "Exámenes cortos\nExamen corto 1\nExamen corto 2\nExamen corto 3- grupo 001 Examen corto 3- grupo 002\nExamen corto 4",
    "crumbs": [
      "Evaluaciones"
    ]
  },
  {
    "objectID": "04-tidyverse.html",
    "href": "04-tidyverse.html",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "4.1 Resumen\nTidyverse es una colección de paquetes de R orientados a ciencia de datos y que apoya los procesos de importación, organización, transformación, visualización, modelado y comunicación.\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), los cuales deben cumplir con tres características:\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación de funciones.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#resumen",
    "href": "04-tidyverse.html#resumen",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Cada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#trabajo-previo",
    "href": "04-tidyverse.html#trabajo-previo",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.2 Trabajo previo",
    "text": "4.2 Trabajo previo\n\n4.2.1 Lecturas\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulos 1 -8, 25 - 27)",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#introducción",
    "href": "04-tidyverse.html#introducción",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.3 Introducción",
    "text": "4.3 Introducción\nTidyverse es una colección de paquetes de R enfocados en ciencia de datos, una discipina que permite convertir datos no procesados en entendimiento, comprensión y conocimiento.\nLa Figura 4.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 4.1: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\n\nLos paquetes de Tidyverse comparten filosofía de diseño, gramática y estructuras de datos para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#paquetes",
    "href": "04-tidyverse.html#paquetes",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.4 Paquetes",
    "text": "4.4 Paquetes\nEl núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:\n\ndplyr: gramática que proporciona un conjunto consistente de “verbos” que resuelven los retos más comunes de transformación de datos.\nggplot2: sistema para la creación declarativa de gráficos, basado en el libro The Grammar of Graphics, de Wilkinson et al..\ntidyr: conjunto de funciones para organizar (to tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.\nreadr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.\npurr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.\ntibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.\nstringr: colección de funciones para facilitar el trabajo con hileras de caracteres.\nforcats: colección de funciones para facilitar el trabajo con factores.\n\nHay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#instalación-y-carga",
    "href": "04-tidyverse.html#instalación-y-carga",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.5 Instalación y carga",
    "text": "4.5 Instalación y carga\nLos paquetes de Tidyverse pueden instalarse con la función install.packages(), ya sea de manera conjunta (todos los paquetes básicos) o individualmente:\n\n# Instalación conjunta (toma más tiempo)\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n\nUna vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():\n\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n\nTambién es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete (siempre y cuando este haya sido instalado):\n\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "href": "04-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.6 El conjunto de datos palmerpenguins",
    "text": "4.6 El conjunto de datos palmerpenguins\npalmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización, como las de Tidyverse. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa a otros conjuntos de datos usualmente usados para ejemplos como, por ejemplo, iris.\nLos datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.\nEn R, el paquete puede instalarse con la función install.packages():\n\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nUna vez instalado, el paquete puede cargarse con la función library():\n\n# Carga de palmerpenguins\nlibrary(palmerpenguins)\n\nEl paquete contiene dos conjuntos de datos:\n\npenguins_raw: datos sin procesar.\npenguins: subconjunto curado de los datos sin procesar.\n\npalmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.\n\n4.6.1 Ejemplos de visualizaciones\nSeguidamente se muestran varios tipos de gráficos estadísticos generados con la función ggplot() del paquete ggplot2.\n\n4.6.1.1 Gráficos de dispersión\nEste tipo de gráficos muestra relaciones entre variables.\n\n# Gráfico de dispersión de longitud del pico vs masa (peso)\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n4.6.1.2 Histogramas\nEste tipo de gráficos muestra distribuciones de variables numéricas.\n\n# Distribución de la variable de masa (peso)\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n\n\n\n\n\n\n\n\n\n# Distribución de la variable de masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n4.6.1.3 Diagramas de caja\nEste tipo de gráficos muestra datos a través de sus cuartiles.\n\n# Diagrama de caja de la variable masa (peso)\npenguins |&gt;\n  ggplot(aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n\n\n\n\n\n\n\n\n\n# Diagrama de caja de la variable masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#datos-tidy",
    "href": "04-tidyverse.html#datos-tidy",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.7 Datos tidy",
    "text": "4.7 Datos tidy\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares a las tablas o matrices.\nSegún Wickham, los datos tidy deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nEstas características se ilustran en la Figura 4.2.\n\n\n\n\n\n\nFigura 4.2: Datos tidy. Fuente: R for Data Science.\n\n\n\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis a resolver.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#pipes",
    "href": "04-tidyverse.html#pipes",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.8 Pipes",
    "text": "4.8 Pipes\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados a funciones.\nEl siguiente ejemplo implementa un pipeline de dos funciones de Tidyverse:\n\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins |&gt;\n  dplyr::filter(species == \"Gentoo\") %&gt;% # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nUna alternativa a los pipes es la anidación de llamados a funciones:\n\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       species,\n       bill_length_mm,\n       flipper_length_mm)\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nEl uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "04-tidyverse.html#recursos-de-interés",
    "href": "04-tidyverse.html#recursos-de-interés",
    "title": "4  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "4.9 Recursos de interés",
    "text": "4.9 Recursos de interés\nCanelón, S. (s.f.). Slides | Silvia Canelón—An Antarctic Tour of the Tidyverse. Recuperado 16 de octubre de 2022, de https://slides.silviacanelon.com/tour-of-the-tidyverse-v2/#/title-slide\n\n\n\nFigura 4.1: Modelo de ciencia de datos. Fuente: R for Data Science.\nFigura 4.2: Datos tidy. Fuente: R for Data Science.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "03-r.html#ejemplo-de-programa-que-utiliza-funciones-ciclos-y-condicionales",
    "href": "03-r.html#ejemplo-de-programa-que-utiliza-funciones-ciclos-y-condicionales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Ejemplo de programa que utiliza funciones, ciclos y condicionales",
    "text": "3.6 Ejemplo de programa que utiliza funciones, ciclos y condicionales\nEl siguiente programa solicita al usuario diferentes datos de varias personas:\n\nNombre.\nMasa (kg).\nEstatura (m).\n\nEsta entrada de datos se implementa a través de un ciclo, el cual finaliza cuando el usuario indica que no desea ingresar más datos.\nPor medio de funciones, se calcula el índice de masa corporal (IMC) de cada persona y la interpretación de si se considera bajo, normal o sobrepeso.\nAl final, se imprime el promedio de los IMC calculados.\n\n# Función para calcular el IMC\nimc &lt;- function(masa, estatura) {\n  return(masa / estatura^2)\n}\n\n# Función para interpretar el IMC\nimc_interpretacion &lt;- function(imc) {\n  if (imc &lt; 18.5) {\n    return(\"bajo\")\n  } else if (imc &lt; 25) {\n    return(\"normal\")\n  } else {\n    return(\"sobrepeso\")\n  }\n}\n\n# Vector para almacenar los IMC y luego calcular el promedio\nimcs &lt;- c()\n\n# Variable para almacenar la respuesta del usuario a la pregunta\n# de si desea ingresar datos de otra persona\nrespuesta &lt;- \"s\"\n\n# Ciclo para solicitar datos\nwhile (respuesta == \"s\") {\n  nombre &lt;- readline(prompt = \"Nombre de la persona: \")\n  masa &lt;- as.numeric(readline(prompt = \"Masa (kg) de la persona: \"))\n  estatura &lt;- as.numeric(readline(prompt = \"Estatura (m) de la persona: \"))\n  \n  # Cálculo del IMC\n  valor_imc &lt;- imc(masa, estatura)\n  interpretacion_imc &lt;- imc_interpretacion(valor_imc)\n  \n  # Despliegue de resultados\n  print(\n    cat(\n      nombre, \"tiene un IMC de\", valor_imc, \n      \"lo cual es considerado\", interpretacion_imc\n    )\n  )\n  \n  # Almacenamiento del valor del IMC\n  imcs &lt;- c(imcs, valor_imc)\n  \n  # Preguntar si desea continuar\n  respuesta &lt;- readline(prompt = \"¿Desea calcular el IMC de otra persona? (s/n): \")\n}\n\n# Mostrar el promedio de los IMC calculados\nif (length(imcs) &gt; 0) {\n  promedio_imc &lt;- mean(imcs)\n  print(cat(\"El promedio de los IMC calculados es:\", promedio_imc))\n} else {\n  print(cat(\"No se calcularon IMC\"))\n}",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html",
    "href": "05-reproducibilidad.html",
    "title": "5  Reproducibilidad",
    "section": "",
    "text": "5.1 Resumen\nUn análisis realizado por un investigador se considera reproducible si el código fuente y los datos que utilizó para obtener los resultados están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado. El concepto de reproducibilidad es cada vez más importante debido al aumento exponencial de datos y al empleo de la programación de computadoras por parte de especialistas de diversas disciplinas.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#trabajo-previo",
    "href": "05-reproducibilidad.html#trabajo-previo",
    "title": "5  Reproducibilidad",
    "section": "5.2 Trabajo previo",
    "text": "5.2 Trabajo previo\n\n5.2.1 Lecturas\nSingleton, Alex David; Spielman, Seth; & Brunsdon, Chris (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#introducción",
    "href": "05-reproducibilidad.html#introducción",
    "title": "5  Reproducibilidad",
    "section": "5.3 Introducción",
    "text": "5.3 Introducción\nEn general, la reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” (Gandrud, 2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad (véase, por ejemplo, The Excel Depression, de Paul Krugman, Growth in a Time of Debt), dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias.\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#reproducibilidad-en-ciencia-de-datos-geoespaciales",
    "href": "05-reproducibilidad.html#reproducibilidad-en-ciencia-de-datos-geoespaciales",
    "title": "5  Reproducibilidad",
    "section": "5.4 Reproducibilidad en ciencia de datos geoespaciales",
    "text": "5.4 Reproducibilidad en ciencia de datos geoespaciales\nAlex Singleton y otros autores (Singleton, Spielman, & Brunsdon, 2016) han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales:\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores (Peng, 2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Espectro de reproducibilidad. Imagen de Anita Graser, basada en (Peng, 2001).",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#herramientas-para-facilitar-la-reproducibilidad",
    "href": "05-reproducibilidad.html#herramientas-para-facilitar-la-reproducibilidad",
    "title": "5  Reproducibilidad",
    "section": "5.5 Herramientas para facilitar la reproducibilidad",
    "text": "5.5 Herramientas para facilitar la reproducibilidad\nLa documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#recursos-de-interés",
    "href": "05-reproducibilidad.html#recursos-de-interés",
    "title": "5  Reproducibilidad",
    "section": "5.6 Recursos de interés",
    "text": "5.6 Recursos de interés\nBartomeus Lab. (2016). A reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zw\nFOSS4G. (2021). FOSS4G2021—Open source for open spatial data science—Anita Graser. https://www.youtube.com/watch?v=ZjXb53pOor0\nKrugman, P. (2013). Opinion | The Excel Depression. The New York Times. https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "05-reproducibilidad.html#referencias",
    "href": "05-reproducibilidad.html#referencias",
    "title": "5  Reproducibilidad",
    "section": "5.7 Referencias",
    "text": "5.7 Referencias\n\n\nGandrud, C. (2020). Reproducible research with R and RStudio (Third edition). Boca Raton, FL: CRC Press.\n\n\nPeng, R. D. (2011). Reproducible Research in Computational Science. Science, 334(6060), 1226-1227. https://doi.org/10.1126/science.1213847\n\n\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\n\n\n\n\n\nFigura 5.1: Espectro de reproducibilidad. Imagen de Anita Graser, basada en (Peng, 2001).",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Reproducibilidad</span>"
    ]
  },
  {
    "objectID": "06-markdown.html",
    "href": "06-markdown.html",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "",
    "text": "6.1 Resumen\nMarkdown es un lenguaje de marcado ligero ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible, entre otras aplicaciones. Incluye marcas para especificar aspectos de estructura, semántica y estilo de un documento. Se basa en texto simple y se convierte fácilmente a HTML, el lenguaje de marcado más utilizado en páginas web.\nMarkdown puede emplearse junto con lenguajes de programación (ej. R, Python) para así combinar texto con código fuente, el cual inserta en los documentos salidas como tablas, gráficos y mapas, entre otras. Esta forma de trabajo facilita la automatización y la reproducibilidad de una investigación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#trabajo-previo",
    "href": "06-markdown.html#trabajo-previo",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.2 Trabajo previo",
    "text": "6.2 Trabajo previo\n\n6.2.1 Lecturas\nQuarto - Markdown Basics. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/authoring/markdown-basics.html\n\n\n6.2.2 Tutoriales\nMarkdown Tutorial. (s.f.). Recuperado el 1 de marzo de 2024, de https://www.markdowntutorial.com/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#introducción",
    "href": "06-markdown.html#introducción",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.3 Introducción",
    "text": "6.3 Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\nKramdown: para el lenguaje Ruby.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#ejemplo-de-documento",
    "href": "06-markdown.html#ejemplo-de-documento",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.4 Ejemplo de documento",
    "text": "6.4 Ejemplo de documento\nEl siguiente es un ejemplo de la sintaxis de Markdown, con marcas para un encabezado, texto en negrita, texto en itálica, un hipervínculo y una imagen.\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites\nde Júpiter descubiertos en 1610 por \n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\nY la siguiente es la manera en la que se visualiza el documento:\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por Galileo Galilei: Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo fue tomado de Satélite galileano - Wikipedia, la enciclopedia libre.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#herramientas-para-escritura-de-documentos",
    "href": "06-markdown.html#herramientas-para-escritura-de-documentos",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.5 Herramientas para escritura de documentos",
    "text": "6.5 Herramientas para escritura de documentos\nMarkdown se escribe en “texto simple o plano” (i.e. texto sin formato, compuesto únicamente por caracteres que son legibles por humanos), por lo que puede escribirse con cualquier editor de texto. Se recomienda el uso de editores orientados a programación, también llamados editores de código fuente, los cuales proporcionan facilidades para el programador, como coloración de palabras clave, sangrado y autocompletado, entre otras.\nTambién pueden utilizarse Entornos Integrados de Desarrollo o IDE, los cuales son aplicaciones informáticas que proporcionan servicios integrales para facilitarle al programador el desarrollo de software. Además de un editor de código fuente, un IDE incluye funciones para depuración (i.e. identificación de errores), interpretación y compilación de programas, entre otras.\nAlgunos de los editores de código fuente o IDE recomendados para Markdown son:\n\nVisual Studio Code: editor de código fuente muy popular y de código abierto. Puede editar código de múltiples lenguajes de programación y sintaxis asociadas\nRStudio: IDE para desarrollo en el lenguaje de programación R, el cual también puede manejar código en otros lenguajes de programación y sintaxis.\n\nNo se recomienda el uso de procesadores de texto (ej. Microsoft Word, Libre Office Writer), debido a que introducen caracteres especiales que no son reconocidos por Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#sintaxis",
    "href": "06-markdown.html#sintaxis",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.6 Sintaxis",
    "text": "6.6 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n6.6.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n6.6.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco. Un simple cambio de línea no generará un nuevo párrafo.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n6.6.3 Negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n6.6.4 Itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n6.6.5 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:* &gt; *\"My name is Ozymandias, king of kings:* &gt; *Look on my works, ye Mighty, and despair!\"* *Percy Bysshe Shelley, \"Ozymandias\" (1818)*\n\n\n\n “And on the pedestal these words appear:”My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!“ \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n6.6.6 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n6.6.7 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n\n6.6.8 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\n\n\n6.6.9 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento.\n- Otro elemento.\n- Otro elemento más.\n\n\n\n\nUn elemento.\n\nOtro elemento.\n\nOtro elemento más.\n\n\n\n\n\n\n\n6.6.10 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#ejercicios",
    "href": "06-markdown.html#ejercicios",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.7 Ejercicios",
    "text": "6.7 Ejercicios\n\nCon RStudio, cree un documento Markdown llamado README.md y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "06-markdown.html#recursos-de-interés",
    "href": "06-markdown.html#recursos-de-interés",
    "title": "6  Markdown - lenguaje de marcado",
    "section": "6.8 Recursos de interés",
    "text": "6.8 Recursos de interés\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "href": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "title": "III - Herramientas para investigación reproducible y desarrollo colaborativo",
    "section": "",
    "text": "5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones\n8 Quarto - sistema de publicación técnica y científica",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo"
    ]
  },
  {
    "objectID": "07-git.html",
    "href": "07-git.html",
    "title": "7  Git - sistema de control de versiones",
    "section": "",
    "text": "7.1 Resumen\nGit es un sistema para administrar versiones de código fuente o, en general, de cualquier conjunto de archivos. Un sistema de administración de versiones permite recuperar versiones anteriores de los archivos e integrar modificaciones efectuadas por varias personas, entre otras capacidades. Git es utilizado en varios sitios que proveen servicios de alojamiento de software, incluído GitHub.\nGit puede utilizarse para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de las operaciones:\nEl sistema Git cuenta con otras muchas operaciones, como commit, para guardar los cambios realizados.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#resumen",
    "href": "07-git.html#resumen",
    "title": "7  Git - sistema de control de versiones",
    "section": "",
    "text": "push: para “subir” al repositorio remoto los cambios realizados en el repositorio local.\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#trabajo-previo",
    "href": "07-git.html#trabajo-previo",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.2 Trabajo previo",
    "text": "7.2 Trabajo previo\n\n7.2.1 Instalación de software\nInstale en su computadora:\nGit\n\n\n7.2.2 Tutoriales\nAbba, Ihechikara Vincent (2021). Git and GitHub Tutorial – Version Control for Beginners. freeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/\n\n\n7.2.3 Otros\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo de software GitHub.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#introducción",
    "href": "07-git.html#introducción",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.3 Introducción",
    "text": "7.3 Introducción\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No requiere un repositorio “central”, pero también puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#funcionamiento-de-git",
    "href": "07-git.html#funcionamiento-de-git",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.4 Funcionamiento de Git",
    "text": "7.4 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figura 7.1.\n\n\n\n\n\n\nFigura 7.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figura 7.2.\n\n\n\n\n\n\nFigura 7.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\nEn la Figura 7.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\n\nFigura 7.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#ejemplos-de-uso",
    "href": "07-git.html#ejemplos-de-uso",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.5 Ejemplos de uso",
    "text": "7.5 Ejemplos de uso\n\n7.5.1 Clonación de un repositorio remoto y sincronización de los cambios efectuados localmente\nPara seguir este ejemplo:\n\nObtenga un token de GitHub en la siguiente opción de menú de su perfil de usuario: Settings - Developer settings - Personal access tokens - Tokens (classic) - Generate new token (classic). Ingrese una descripción y seleccione las operaciones de tipo “repo”. Presione Generate token. Copie el token en un lugar seguro, ya que lo necesitará para autenticarse en GitHub.\nRealice un fork a su cuenta en GitHub del repositorio localizado en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2023-i-tutorial-git-repo-ejemplo. Obtendrá un repositorio llamado “https://github.com/[nombre-usuario]/2023-i-tutorial-git-repo-ejemplo”, en donde [nombre-usuario] es su nombre de usuario en GitHub.\nCon la opción File - New Project - Version Control - Git de RStudio, clone a su computadora el repositorio que acaba de bifurcar.\nCon el editor de RStudio, abra el archivo README.md, agregue una línea y guarde el archivo.\nLuego, ejecute los siguientes comandos desde la la ventana Terminal de RStudio para sincronizar el repositorio local y el repositorio remoto (las líneas que empiezan con # son comentarios).\n\n# a. Parámetros de configuración: nombre y dirección de correo del usuario.\n#    Debe cambiar [email-usuario] y [nombre-usuario] por sus propios datos, sin usar los [].\ngit config --global user.email [email-usuario]\ngit config --global user.name [nombre-usuario]\n# Para revisar los parámetros de configuración:\ngit config --global --list\n\n# b. Revisión de los archivos con modificaciones.\ngit status\n\n# c. Adición (add) de los archivos modificados al \"área de espera\".\n#    El punto (.) indica que se agregarán todos los archivos modificados.\ngit add .\n\n# d. Grabado (commit) del conjunto de archivos modificados,\n#    junto con un mensaje explicativo:\n#    Debe cambiar [comentario] por su propio comentario (ej. \"Agregar línea 2\"), sin usar los [].\ngit commit -m [comentario]\n\n# e. \"Subida\" (push) de las modificaciones al repositorio remoto.\n#    En este paso, es posible que deba utilizar su nombre de usuario/clave\n#    o su token de GitHub para autenticarse.\ngit push\n\nRevise los cambios aplicados en el repositorio remoto en GitHub.\nAgregue más líneas al archivo del repositorio local y sincronícelo con el remoto, realizando nuevamente los pasos del b al e para cada commit. Recuerde que los comentarios de cada commit deben reflejar los cambios que están siendo aplicados.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#ejercicios",
    "href": "07-git.html#ejercicios",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.5 Ejercicios",
    "text": "7.5 Ejercicios\n\n7.5.1 Sitio 1\n\nCree un repositorio en GitHub (ej. currículum).\nClone el nuevo repositorio a su computadora.\nCopie al directorio del repositorio clonado el archivo README.md que creó en el capítulo anterior, con su currículum.\nSincronice ambos repositorios.\nPublique su curriculum como un sitio web en GitHub Pages, con la opción Settings - Pages. Elija la rama (branch) main y guarde los cambios. El sitio tomará algunos segundos para generarse.\nRealice cambios adicionales en su currículum y sincronícelos con el repositorio remoto.\n\n\n\n7.5.2 Sitio 2\n\nDescargue las estadísticas sobre delitos cometidos en Costa Rica en 2023 y 2024 del sitio de datos abiertos del Organismo de Investigación Judicial (OIJ).\nConvierta los archivos a formato CSV.\nCon R, genere gráficos de barras de:\n\nCantidad de delitos por provincia en 2023 y en 2024 (en gráficos separados).\nCantidad de homicidios por provincia en 2023 y en 2024 (en gráficos separados).\nCantidad de delitos por cantón en 2023 y en 2024 (en gráficos separados).\nCantidad de homicidios por cantón en 2023 y en 2024 (en gráficos separados).\n\n\nGuarde los gráficos como archivos PNG.\nElabore un documento Markdown que muestre los gráficos.\nPublique el documento en GitHub Pages.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "07-git.html#recursos-de-interés",
    "href": "07-git.html#recursos-de-interés",
    "title": "7  Git - sistema de control de versiones",
    "section": "7.6 Recursos de interés",
    "text": "7.6 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6\n\n\n\nFigura 7.1: Operaciones push y pull. Imagen de Melinda Higgins.\nFigura 7.2: Operaciones de Git. Imagen de Steven Klavins.\nFigura 7.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "08-quarto.html",
    "href": "08-quarto.html",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "8.1 Resumen\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Estos documentos combinan código en R, y sus salidas (ej. tablas, gráficos, mapas), con la sintaxis de Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "08-quarto.html#trabajo-previo",
    "href": "08-quarto.html#trabajo-previo",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.2 Trabajo previo",
    "text": "8.2 Trabajo previo\n\n8.2.1 Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "08-quarto.html#introducción",
    "href": "08-quarto.html#introducción",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.3 Introducción",
    "text": "8.3 Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "08-quarto.html#anatomía-de-un-documento-quarto",
    "href": "08-quarto.html#anatomía-de-un-documento-quarto",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.4 Anatomía de un documento Quarto",
    "text": "8.4 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n8.4.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n8.4.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n8.4.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "08-quarto.html#cómo-funciona-quarto",
    "href": "08-quarto.html#cómo-funciona-quarto",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.5 ¿Cómo funciona Quarto?",
    "text": "8.5 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 8.1.\n\n\n\n\n\n\nFigura 8.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "08-quarto.html#ejercicios",
    "href": "08-quarto.html#ejercicios",
    "title": "8  Quarto - sistema de publicación técnica y científica",
    "section": "8.6 Ejercicios",
    "text": "8.6 Ejercicios\nCon R y Quarto, cree un sitio web en GitHub Pages que contenga visualizaciones de los datos de homicidios ocurridos en Costa Rica en 2024, de acuerdo con las estadísticas publicadas en el sitio de datos abiertos del Organismo de Investigación Judicial (OIJ).\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un repositorio vacío en su cuenta en GitHub (ej. delitos-graficosbase).\nClone el nuevo repositorio en su computadora con la opción File - New Project - Version Control - Git de RStudio.\nCopie en el repositorio clonado el archivo CSV con los datos de delitos.\nCree un nuevo documento Quarto con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento en el repositorio clonado, con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue texto Markdown que explique su contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente.\nEn un bloque de código en R, cargue el archivo CSV en un dataframe. Se recomienda asignar una etiqueta al bloque con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente. Despliegue una muestra de los datos en una tabla.\nEscriba bloques adicionales de código en R que generen los siguientes gráficos (en cada uno, agregue título, fuente y procure que luzca bien mediante colores, tamaños de letras y otros elementos estéticos):\n\nCantidad de delitos por provincia.\n\nGráfico de barras verticales.\nGráfico de barras horizontales.\nGráfico de pastel.\n\nCantidad de delitos por cantón en los 20 cantones con más delitos - gráfico de barras (verticales u horizontales).\nCantidad de delitos por edad de la víctima - gráfico de pastel.\nCantidad de delitos por provincia y edad de la víctima (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\nCantidad de homicidios por provincia y edad de la víctima (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\nCantidad de homicidios por cantón y edad de la víctima en los 20 cantones con más homicidios (una barra por provincia con colores según las edades) - gráfico de barras apiladas.\n\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nSincronice el repositorio local con el repositorio en GitHub, ya sea con comandos de Git o subiendo manualmente los archivos. Si lo hace manualmente, asegúrese de actualizar:\n\nEl documento HTML (index.html).\nEl documento Quarto (index.qmd).\nEl archivo CSV (estadisticaspoliciales2022.csv).\nArchivos temporales (ej. directorio index_files).\n\nGenere el sitio en GitHub Pages con la opción Settings - Pages de GitHub.\nRepita los pasos del 8 al 10 para cada modificación que realice en el documento Quarto.\n\n\n\n\nFigura 8.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "examen-corto-02.html",
    "href": "examen-corto-02.html",
    "title": "Examen corto 2",
    "section": "",
    "text": "Fecha",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 2"
    ]
  },
  {
    "objectID": "examen-corto-02.html#fecha",
    "href": "examen-corto-02.html#fecha",
    "title": "Examen corto 2",
    "section": "",
    "text": "Grupo 001: jueves 9 de mayo de 2024\nGrupo 002: miércoles 8 de mayo de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 2"
    ]
  },
  {
    "objectID": "examen-corto-02.html#temas-a-evaluar",
    "href": "examen-corto-02.html#temas-a-evaluar",
    "title": "Examen corto 2",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n3 R - lenguaje de programación para análisis estadístico desde la sección “3.5.5 Tipos de datos” (inclusive) hasta el final\n4 Tidyverse - colección de paquetes para ciencia de datos\n5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 2"
    ]
  },
  {
    "objectID": "parte-iv-graficacion-estadistica-r.html",
    "href": "parte-iv-graficacion-estadistica-r.html",
    "title": "IV - Graficación estadística en R",
    "section": "",
    "text": "9 dplyr - gramática para manipulación de datos",
    "crumbs": [
      "IV - Graficación estadística en R"
    ]
  },
  {
    "objectID": "09-dplyr.html",
    "href": "09-dplyr.html",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "9.1 Resumen\nEl paquete dplyr proporciona un conjunto de funciones que ayudan a solucionar las tareas de transformación de datos más comunes, entre las que están la selección de columnas, el ordenamiento de filas, el filtrado de filas, la creación o modificación de columnas y los cálculos en grupos de filas. Estas transformaciones son usualmente requeridas antes de la visualización y el modelado de los datos.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#trabajo-previo",
    "href": "09-dplyr.html#trabajo-previo",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.2 Trabajo previo",
    "text": "9.2 Trabajo previo\n\n9.2.1 Lecturas\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) Chapter 4 - Data transformation. Recuperado 5 de mayo de 2024, de https://r4ds.hadley.nz/data-transform.html",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#introducción",
    "href": "09-dplyr.html#introducción",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.3 Introducción",
    "text": "9.3 Introducción\nEl paquete dplyr de Tidyverse es descrito como una gramática para la manipulación de datos, la cual proporciona un conjunto consistente de “verbos” que ayuda a solucionar los retos de procesamiento de datos más comunes. Los principales verbos (i.e. funciones) de esta gramática son:\nselect(): selecciona columnas con base en sus nombres.\nfilter(): selecciona filas con base en sus valores.\narrange(): cambia el orden de las filas.\nmutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.\nsummarize(): agrupa y resume valores.\nTodas estas operaciones pueden combinarse con la función group_by(), la cual ejecuta cualquiera de las operaciones anteriores “en grupo”. Además, dplyr proporciona funciones adicionales para tareas más específicas.\nLas funciones de dplyr pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). En el material de este curso, se prefiere la segunda opción. Los pipes se utilizan para comunicar procesos y así formar pipelines (tuberías).\nTodas las funciones de dplyr trabajan de manera similar:\n\nEl primer argumento siempre es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado siempre es un nuevo data frame.\n\nYa que cada función de dplyr se especializa en una sola tarea, usualmente es necesario encadenar funciones mediante pipes para lograr un objetivo de procesamiento de datos. Por ejemplo, el siguiente bloque de código usa tres verbos, o funciones, de dplyr para obtener la masa promedio de cada especie de pingüinos que habita en la isla Biscoe.\n\n# Cálculo de la masa promedio para cada especie de pingüinos\n# que habita en la isla Biscoe\npenguins |&gt;\n  filter(island == \"Biscoe\") |&gt; \n  group_by(species) |&gt; \n  summarize(\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)\n  )\n\nA tibble: 2 × 2\nspecies body_mass_g_mean\n&lt;fct&gt;              &lt;dbl&gt;\nAdelie          3710.659\nGentoo          5076.016",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#instalación-y-carga",
    "href": "09-dplyr.html#instalación-y-carga",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.4 Instalación y carga",
    "text": "9.4 Instalación y carga\nEl paquete dplyr puede instalarse junto con todos los demás paquete de Tidyverse o de manera individual:\n\n# Instalación conjunta de Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Instalación individual\ninstall.packages(\"dplyr\")\n\nUna vez instalado, dplyr puede cargarse con la función library():\n\n# Carga conjunta de Tidyverse\nlibrary(tidyverse)\n\n# Carga individual\nlibrary(dplyr)\n\nSeguidamente, se cargan algunos paquetes adicionales que se utilizan en este capítulo.\n\n# Carga de readr, paquete para lectura de datos\nlibrary(readr)\n\n# Carga de tidyr, paquete para creación de datos \"tidy\"\nlibrary(tidyr)\n\n# Carga de knitr, paquete para integrar salidas en R en documentos dinámicos\n# (ej. Quarto). En este capítulo se usa para generar tablas.\nlibrary(knitr)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "href": "09-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.5 Conjuntos de datos para ejemplos",
    "text": "9.5 Conjuntos de datos para ejemplos\nEn los ejemplos de este capítulo, se utilizan dos conjunto de datos:\n\nPingüinos del archipiélago Palmer, contenido en el paquete palmerpenguins.\nDelitos cometidos en Costa Rica en 2023, disponibles en el sitio Datos Abiertos del Organismo de Investigación Judicial (OIJ).\n\n\n9.5.1 Pingüinos del archipiélago Palmer\nPara cargar el conjunto de datos penguins, basta con cargar el paquete palmerpenguins.\n\n# Carga del paquete de datos palmerpenguins\nlibrary(palmerpenguins)\n\nLa función glimpse() despliega la estructura de un conjunto de datos, incluyendo los nombres de las columnas, sus tipos de datos y una muestra de estos:\n\n# Estructura del conjunto de datos penguins\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nLa función también puede llamarse mediante un pipe:\n\n# Estructura del conjunto de datos penguins\npenguins |&gt;\n  glimpse()\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nUn conjunto de datos puede visualizarse al escribir su nombre en la consola de R o en un programa:\n\n# Despliegue de los datos de penguins\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\npenguins es un tibble, un tipo especial de data frame que se utiliza en Tidyverse. La diferencia más importante entre un tibble y un data frame es la manera en la que se imprimen: los tibbles están diseñados para conjuntos de datos grandes, por lo que solo muestran los primeros registros y las columnas que caben en la pantalla. Un data frame regular muestra todas sus columnas y muchos más registros, lo que dificulta su visualización. Note la diferencia, por ejemplo, con la forma en la que se despliega el conjunto de datos iris (observe también la diferencia entre las salidas de class(iris) y class(penguins)). A pesar de estas diferencias en el despliegue, en general, un data frame regular y un tibble pueden tratarse indistintamente.\nPara generar una salida más estilizada, puede usarse la función knitr::kable(), la cual genera tablas para documentos web. En el siguiente ejemplo, se obtienen los primeros registros de penguins con la función head() y se despliegan en una tabla mediante kable().\n\n# Despliegue de los primeros registros de penguins en una tabla kable\npenguins |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3625\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4675\nmale\n2007\n\n\nAdelie\nTorgersen\n34.1\n18.1\n193\n3475\nNA\n2007\n\n\nAdelie\nTorgersen\n42.0\n20.2\n190\n4250\nNA\n2007\n\n\n\n\n\n\n\n\n\n\n9.5.2 Delitos cometidos en Costa Rica en 2023\nSe utiliza la función readr::read_csv() para leer un archivo CSV almacenado en el repositorio GitHub de este curso, con los datos de las estadísticas policiales proporcionados por el OIJ en formato Excel. readr::read_csv() es más eficiente que read.csv() (del paquete base de R) y tiene otras ventajas como detección automática de tipos de datos y mejor integración con otros paquetes de Tidyverse (ej. dplyr, tidyr, ggplot2).\n\n# Carga de los datos de delitos cometidos en 2023\ndelitos_2023 &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/oij/estadisticas-policiales/estadisticaspoliciales2023.csv\"\n  )\n\nEstructura del conjunto de datos:\n\n# Estructura de los datos de delitos cometidos en 2023\nglimpse(delitos_2023)\n\nRows: 49,609\nColumns: 12\n$ Delito       &lt;chr&gt; \"ASALTO\", \"ASALTO\", \"HURTO\", \"ASALTO\", \"ASALTO\", \"HURTO\",…\n$ SubDelito    &lt;chr&gt; \"ARMA BLANCA\", \"ARMA BLANCA\", \"ARDID PREVIO/DISTRACCION\",…\n$ Fecha        &lt;chr&gt; \"12/31/2023\", \"12/31/2023\", \"12/31/2023\", \"12/31/2023\", \"…\n$ Hora         &lt;chr&gt; \"21:00:00 - 23:59:59\", \"21:00:00 - 23:59:59\", \"21:00:00 -…\n$ Victima      &lt;chr&gt; \"PERSONA\", \"PERSONA\", \"PERSONA\", \"PERSONA\", \"PERSONA\", \"V…\n$ SubVictima   &lt;chr&gt; \"PEATON [PERSONA]\", \"PEATON [PERSONA]\", \"TAXISTA [PERSONA…\n$ Edad         &lt;chr&gt; \"Mayor de edad\", \"Mayor de edad\", \"Mayor de edad\", \"Mayor…\n$ Genero       &lt;chr&gt; \"HOMBRE\", \"MUJER\", \"HOMBRE\", \"HOMBRE\", \"HOMBRE\", \"MUJER\",…\n$ Nacionalidad &lt;chr&gt; \"COSTA RICA\", \"COSTA RICA\", \"COSTA RICA\", \"NICARAGUA\", \"C…\n$ Provincia    &lt;chr&gt; \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE…\n$ Canton       &lt;chr&gt; \"SAN JOSE\", \"MORAVIA\", \"DESAMPARADOS\", \"SAN JOSE\", \"SAN J…\n$ Distrito     &lt;chr&gt; \"MERCED\", \"SAN VICENTE\", \"SAN MIGUEL\", \"HOSPITAL\", \"HOSPI…\n\n\nDespliegue de los datos (debido a que delitos_2023 es un data frame, pero no un tibble, se limitan manualmente las filas y columnas que se muestran):\n\n# Despliegue de los primeros registros de delitos en una tabla kable\ndelitos_2023 |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\n\nDelito\nSubDelito\nFecha\nHora\nVictima\nSubVictima\nEdad\nGenero\nNacionalidad\nProvincia\nCanton\nDistrito\n\n\n\n\nASALTO\nARMA BLANCA\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nMERCED\n\n\nASALTO\nARMA BLANCA\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nMORAVIA\nSAN VICENTE\n\n\nHURTO\nARDID PREVIO/DISTRACCION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nTAXISTA [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nDESAMPARADOS\nSAN MIGUEL\n\n\nASALTO\nINMOVILIZACION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nNICARAGUA\nSAN JOSE\nSAN JOSE\nHOSPITAL\n\n\nASALTO\nARMA DE FUEGO\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nHOSPITAL\n\n\nHURTO\nPOR DESCUIDO\n12/31/2023\n21:00:00 - 23:59:59\nVIVIENDA\nNO APLICA [VIVIENDA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nDOTA\nJARDIN\n\n\nASALTO\nARREBATO\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPASAJERO DE TRANSPORTE PUBLICO [PERSONA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nDESCONOCIDO\n\n\nASALTO\nGOLPES\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nPUNTARENAS\nCORREDORES\nCORREDOR\n\n\nASALTO\nINMOVILIZACION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nITALIA\nSAN JOSE\nSAN JOSE\nHATILLO\n\n\nHURTO\nCON LLAVE\n12/31/2023\n21:00:00 - 23:59:59\nVIVIENDA\nNO APLICA [VIVIENDA]\nAdulto Mayor\nMUJER\nCOSTA RICA\nGUANACASTE\nNICOYA\nNICOYA",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#funciones",
    "href": "09-dplyr.html#funciones",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.6 Funciones",
    "text": "9.6 Funciones\nEn esta sección, se describen y ejemplifican las principales funciones de dplyr.\n\n9.6.1 select()\nLa función select() selecciona (y opcionalmente renombra) columnas de un data frame con base en sus nombres.\n\n# Selección de las columnas species, bill_length_mm y sex\npenguins |&gt;\n  select(species, bill_length_mm, sex)\n\n# A tibble: 344 × 3\n   species bill_length_mm sex   \n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt; \n 1 Adelie            39.1 male  \n 2 Adelie            39.5 female\n 3 Adelie            40.3 female\n 4 Adelie            NA   &lt;NA&gt;  \n 5 Adelie            36.7 female\n 6 Adelie            39.3 male  \n 7 Adelie            38.9 female\n 8 Adelie            39.2 male  \n 9 Adelie            34.1 &lt;NA&gt;  \n10 Adelie            42   &lt;NA&gt;  \n# ℹ 334 more rows\n\n\nCambio de nombres de columnas:\n\n# Selección y cambio de nombre de las columnas \n# species, bill_length_mm y sex\npenguins |&gt;\n  select(especie = species,\n         longitud_pico_mm = bill_length_mm,\n         sexo = sex)\n\n# A tibble: 344 × 3\n   especie longitud_pico_mm sexo  \n   &lt;fct&gt;              &lt;dbl&gt; &lt;fct&gt; \n 1 Adelie              39.1 male  \n 2 Adelie              39.5 female\n 3 Adelie              40.3 female\n 4 Adelie              NA   &lt;NA&gt;  \n 5 Adelie              36.7 female\n 6 Adelie              39.3 male  \n 7 Adelie              38.9 female\n 8 Adelie              39.2 male  \n 9 Adelie              34.1 &lt;NA&gt;  \n10 Adelie              42   &lt;NA&gt;  \n# ℹ 334 more rows\n\n\nEl operador : permite seleccionar un rango de columnas continuas:\n\n# Selección de las columnas desde species a flipper_length_mm\npenguins |&gt;\n  select(species:flipper_length_mm)\n\n# A tibble: 344 × 5\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181\n 2 Adelie  Torgersen           39.5          17.4               186\n 3 Adelie  Torgersen           40.3          18                 195\n 4 Adelie  Torgersen           NA            NA                  NA\n 5 Adelie  Torgersen           36.7          19.3               193\n 6 Adelie  Torgersen           39.3          20.6               190\n 7 Adelie  Torgersen           38.9          17.8               181\n 8 Adelie  Torgersen           39.2          19.6               195\n 9 Adelie  Torgersen           34.1          18.1               193\n10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n\n\nSelección de todas las columnas que cumplen una condición:\n\n# Selección de las columnas numéricas\npenguins |&gt;\n  select(where(is.numeric))\n\n# A tibble: 344 × 5\n   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;int&gt;\n 1           39.1          18.7               181        3750  2007\n 2           39.5          17.4               186        3800  2007\n 3           40.3          18                 195        3250  2007\n 4           NA            NA                  NA          NA  2007\n 5           36.7          19.3               193        3450  2007\n 6           39.3          20.6               190        3650  2007\n 7           38.9          17.8               181        3625  2007\n 8           39.2          19.6               195        4675  2007\n 9           34.1          18.1               193        3475  2007\n10           42            20.2               190        4250  2007\n# ℹ 334 more rows\n\n\n\n\n9.6.2 filter()\nLa función filter() retorna un subconjunto de un data frame con todas las filas que satisfacen una condición (i.e. expresión lógica).\nPuede utilizar los operadores relacionales:\n\n== (igual que) Note la diferencia con el operador de asignación (=)\n!= (diferente de)\n&gt; (estrictamente mayor que), &gt;= (mayor o igual que)\n&lt; (estrictamente menor que), &lt;= (menor o igual que)\n\nY los operadores lógicos:\n\n& (AND o Y lógico)\n| (OR u O lógico)\n! (NOT o NO lógico)\n\nEjemplos de uso de expresiones y operadores lógicos:\n\n# Pingüinos de la especie 'Adelie' \n# con longitud del pico mayor o igual a 45 mm\npenguins |&gt;\n  filter(species == 'Adelie' & bill_length_mm &gt;= 45)\n\n# A tibble: 3 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           46            21.5               194        4200\n2 Adelie  Torgersen           45.8          18.9               197        4150\n3 Adelie  Biscoe              45.6          20.3               191        4600\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Pingüinos de las especies 'Adelie' o 'Gentoo'\npenguins |&gt;\n  filter(species == 'Adelie' | species == 'Gentoo')\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 266 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Pingüinos de especies diferentes a 'Chinstrap'\npenguins |&gt;\n  filter(!(species == 'Chinstrap'))\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 266 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Homicidios cometidos en el cantón de Sarapiquí\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\" & Canton == \"SARAPIQUI\") |&gt;\n  select(Canton, SubDelito, Fecha, Edad, Nacionalidad) |&gt;\n  kable()\n\n\n\n\n\n\n\n\n\n\n\nCanton\nSubDelito\nFecha\nEdad\nNacionalidad\n\n\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n12/06/2023\nDesconocido\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/16/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/30/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/07/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/05/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n06/25/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n05/31/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n05/22/2023\nDesconocido\nCOSTA RICA\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n05/16/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n04/12/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nPOR LA COMISION DE OTRO DELITO\n03/18/2023\nMayor de edad\nNICARAGUA\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n03/13/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n02/16/2023\nMayor de edad\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/31/2023\nAdulto Mayor\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/31/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/07/2023\nMayor de edad\nCOSTA RICA\n\n\n\n\n\n\n# Homicidios cometidos en el cantón de Sarapiquí \n# a personas no costarricenses\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\" &\n           Canton == \"SARAPIQUI\" & Nacionalidad != \"COSTA RICA\") |&gt;\n  select(Canton, SubDelito, Fecha, Edad, Nacionalidad) |&gt;\n  kable()\n\n\n\n\n\n\n\n\n\n\n\nCanton\nSubDelito\nFecha\nEdad\nNacionalidad\n\n\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/07/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n06/25/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nPOR LA COMISION DE OTRO DELITO\n03/18/2023\nMayor de edad\nNICARAGUA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n02/16/2023\nMayor de edad\nDesconocido\n\n\n\n\n\n\n# Pingüinos con longitud del pico mayor o igual al promedio\n#   El argumento lógico na.rm de mean() \n#   indica si los valores NA (\"not available\") \n#   deben ser removidos antes del cálculo\npenguins |&gt;\n  filter(bill_length_mm &gt;= mean(bill_length_mm, na.rm = TRUE))\n\n# A tibble: 175 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           46            21.5               194        4200\n 2 Adelie  Dream               44.1          19.7               196        4400\n 3 Adelie  Torgersen           45.8          18.9               197        4150\n 4 Adelie  Biscoe              45.6          20.3               191        4600\n 5 Adelie  Torgersen           44.1          18                 210        4000\n 6 Gentoo  Biscoe              46.1          13.2               211        4500\n 7 Gentoo  Biscoe              50            16.3               230        5700\n 8 Gentoo  Biscoe              48.7          14.1               210        4450\n 9 Gentoo  Biscoe              50            15.2               218        5700\n10 Gentoo  Biscoe              47.6          14.5               215        5400\n# ℹ 165 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nCondiciones relacionadas con valores NA (nulos):\n\n# Filas con valor NA en la columna sex\npenguins |&gt;\n  select(species, island, sex) |&gt;\n  filter(is.na(sex))\n\n# A tibble: 11 × 3\n   species island    sex  \n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;\n 1 Adelie  Torgersen &lt;NA&gt; \n 2 Adelie  Torgersen &lt;NA&gt; \n 3 Adelie  Torgersen &lt;NA&gt; \n 4 Adelie  Torgersen &lt;NA&gt; \n 5 Adelie  Torgersen &lt;NA&gt; \n 6 Adelie  Dream     &lt;NA&gt; \n 7 Gentoo  Biscoe    &lt;NA&gt; \n 8 Gentoo  Biscoe    &lt;NA&gt; \n 9 Gentoo  Biscoe    &lt;NA&gt; \n10 Gentoo  Biscoe    &lt;NA&gt; \n11 Gentoo  Biscoe    &lt;NA&gt; \n\n\nLa función tidyr::drop_na() remueve las filas con valores NA en una o varias columnas.\n\n# Filas con valor diferente a NA en la columna sex\npenguins |&gt;\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) |&gt;\n  drop_na(sex)\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# ℹ 323 more rows\n\n\n\n# Filas con valor diferente a NA en cualquier columna\npenguins |&gt;\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) |&gt;\n  drop_na()\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# ℹ 323 more rows\n\n\n\n\n9.6.3 arrange()\nLa función arrange() cambia el orden de las filas de un data frame de acuerdo con los valores de las columnas seleccionadas.\n\n# Ordenamiento ascendente por las columnas \n# bill_length_mm y bill_depth_mm\npenguins |&gt;\n  arrange(bill_length_mm, bill_depth_mm)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Dream               32.1          15.5               188        3050\n 2 Adelie  Dream               33.1          16.1               178        2900\n 3 Adelie  Torgersen           33.5          19                 190        3600\n 4 Adelie  Dream               34            17.1               185        3400\n 5 Adelie  Torgersen           34.1          18.1               193        3475\n 6 Adelie  Torgersen           34.4          18.4               184        3325\n 7 Adelie  Biscoe              34.5          18.1               187        2900\n 8 Adelie  Torgersen           34.6          17.2               189        3200\n 9 Adelie  Torgersen           34.6          21.1               198        4400\n10 Adelie  Biscoe              35            17.9               190        3450\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nPor defecto, las columnas se ordenan de manera acendente. Si se desea un orden descendente, puede utilizarse la función desc().\n\n# Ordenamiento descendente por las columnas \n# bill_length_mm y bill_depth_mm\npenguins |&gt;\n  arrange(desc(bill_length_mm), desc(bill_depth_mm))\n\n# A tibble: 344 × 8\n   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe           59.6          17                 230        6050\n 2 Chinstrap Dream            58            17.8               181        3700\n 3 Gentoo    Biscoe           55.9          17                 228        5600\n 4 Chinstrap Dream            55.8          19.8               207        4000\n 5 Gentoo    Biscoe           55.1          16                 230        5850\n 6 Gentoo    Biscoe           54.3          15.7               231        5650\n 7 Chinstrap Dream            54.2          20.8               201        4300\n 8 Chinstrap Dream            53.5          19.9               205        4500\n 9 Gentoo    Biscoe           53.4          15.8               219        5500\n10 Chinstrap Dream            52.8          20                 205        4550\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nNótese que los valores NA se ubican al final de cualquier ordenamiento.\n\n\n9.6.4 mutate()\nLa función mutate() crea o modifica columnas en un data frame.\n\n# Creación de la columna body_mass_kg,\n# correspondiente al valor de body_mass_g, pero expresado en kg\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  mutate(body_mass_kg = body_mass_g/1000)\n\n# A tibble: 344 × 3\n   species body_mass_g body_mass_kg\n   &lt;fct&gt;         &lt;int&gt;        &lt;dbl&gt;\n 1 Adelie         3750         3.75\n 2 Adelie         3800         3.8 \n 3 Adelie         3250         3.25\n 4 Adelie           NA        NA   \n 5 Adelie         3450         3.45\n 6 Adelie         3650         3.65\n 7 Adelie         3625         3.62\n 8 Adelie         4675         4.68\n 9 Adelie         3475         3.48\n10 Adelie         4250         4.25\n# ℹ 334 more rows\n\n\n\n# Creación de las columnas body_mass_g_mean (promedio de masa) y\n# body_mass_g_normalized (masa normalizada con respecto al promedio)\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  mutate(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)) |&gt;\n  mutate(body_mass_g_normalized = body_mass_g / body_mass_g_mean)\n\n# A tibble: 344 × 4\n   species body_mass_g body_mass_g_mean body_mass_g_normalized\n   &lt;fct&gt;         &lt;int&gt;            &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Adelie         3750            4202.                  0.892\n 2 Adelie         3800            4202.                  0.904\n 3 Adelie         3250            4202.                  0.773\n 4 Adelie           NA            4202.                 NA    \n 5 Adelie         3450            4202.                  0.821\n 6 Adelie         3650            4202.                  0.869\n 7 Adelie         3625            4202.                  0.863\n 8 Adelie         4675            4202.                  1.11 \n 9 Adelie         3475            4202.                  0.827\n10 Adelie         4250            4202.                  1.01 \n# ℹ 334 more rows\n\n\n\n# Creación de las columnas \n# Fecha_Date (tipo Date), Anio, Mes y Dia (enteros)\ndelitos_2023 |&gt;\n  select(Fecha) |&gt;\n  mutate(Fecha_Date = as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\")) |&gt;\n  mutate(Anio = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%Y\"))) |&gt;  \n  mutate(Dia = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%m\"))) |&gt;\n  mutate(Mes = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%d\"))) |&gt;\n  slice_head(n = 10)\n\n# A tibble: 10 × 5\n   Fecha      Fecha_Date  Anio   Dia   Mes\n   &lt;chr&gt;      &lt;date&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 12/31/2023 2023-12-31  2023    12    31\n 2 12/31/2023 2023-12-31  2023    12    31\n 3 12/31/2023 2023-12-31  2023    12    31\n 4 12/31/2023 2023-12-31  2023    12    31\n 5 12/31/2023 2023-12-31  2023    12    31\n 6 12/31/2023 2023-12-31  2023    12    31\n 7 12/31/2023 2023-12-31  2023    12    31\n 8 12/31/2023 2023-12-31  2023    12    31\n 9 12/31/2023 2023-12-31  2023    12    31\n10 12/31/2023 2023-12-31  2023    12    31\n\n\nLa función group_by() agrupa una o más columnas. Generalmente, esto se hace con el objetivo de rea\n\n# Creación de la columnas \n# body_mass_g_mean_species (promedio de masa de la especie) y\n# body_mass_g_species_normalized (masa normalizada con respecto al promedio de la especie)\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  group_by(species) |&gt;\n  mutate(body_mass_g_mean_species = mean(body_mass_g, na.rm = TRUE)) |&gt;\n  mutate(body_mass_g_species_normalized = body_mass_g / body_mass_g_mean_species)\n\n# A tibble: 344 × 4\n# Groups:   species [3]\n   species body_mass_g body_mass_g_mean_species body_mass_g_species_normalized\n   &lt;fct&gt;         &lt;int&gt;                    &lt;dbl&gt;                          &lt;dbl&gt;\n 1 Adelie         3750                    3701.                          1.01 \n 2 Adelie         3800                    3701.                          1.03 \n 3 Adelie         3250                    3701.                          0.878\n 4 Adelie           NA                    3701.                         NA    \n 5 Adelie         3450                    3701.                          0.932\n 6 Adelie         3650                    3701.                          0.986\n 7 Adelie         3625                    3701.                          0.980\n 8 Adelie         4675                    3701.                          1.26 \n 9 Adelie         3475                    3701.                          0.939\n10 Adelie         4250                    3701.                          1.15 \n# ℹ 334 more rows\n\n\n\n\n9.6.5 summarize()\nLa función summarize() se utiliza generalmente junto con la función group_by() para realizar cálculos en grupos de filas de un data frame. group_by() agrupa las filas y summarize() realiza los cálculos (ej. sumas, promedios) en las columnas, para cada grupo. El resultado es un nuevo data frame con una fila por grupo. Si no hay agrupación, se retorna una sola fila correspondiente a los cálculos para todo el data frame.\nEjemplos de cálculos en grupos:\n\n# Mmínimo, máximo, promedio de masa y cantidad de individuos \n# para cada especie de pingüinos\npenguins |&gt;\n  group_by(species) |&gt;\n  summarize(\n    body_mass_g_min = min(body_mass_g, na.rm = TRUE),\n    body_mass_g_max = max(body_mass_g, na.rm = TRUE),\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 3 × 5\n  species   body_mass_g_min body_mass_g_max body_mass_g_mean     n\n  &lt;fct&gt;               &lt;int&gt;           &lt;int&gt;            &lt;dbl&gt; &lt;int&gt;\n1 Adelie               2850            4775            3701.   152\n2 Chinstrap            2700            4800            3733.    68\n3 Gentoo               3950            6300            5076.   124\n\n\nLa función n() cuenta la cantidad de filas en un grupo.\n\n# Cantidad de homicidios por provincia y cantón\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\") |&gt;\n  group_by(Provincia, Canton) |&gt;\n  summarize(\n    homicidios_2023 = n()\n  ) |&gt;\n  arrange(desc(homicidios_2023)) |&gt;\n  kable()\n\n\n\n\nProvincia\nCanton\nhomicidios_2023\n\n\n\n\nLIMON\nLIMON\n91\n\n\nSAN JOSE\nSAN JOSE\n82\n\n\nPUNTARENAS\nPUNTARENAS\n68\n\n\nLIMON\nMATINA\n50\n\n\nALAJUELA\nALAJUELA\n44\n\n\nLIMON\nPOCOCI\n31\n\n\nGUANACASTE\nNICOYA\n28\n\n\nSAN JOSE\nDESAMPARADOS\n26\n\n\nGUANACASTE\nSANTA CRUZ\n24\n\n\nSAN JOSE\nALAJUELITA\n23\n\n\nCARTAGO\nCARTAGO\n21\n\n\nLIMON\nSIQUIRRES\n21\n\n\nSAN JOSE\nGOICOECHEA\n20\n\n\nALAJUELA\nSAN CARLOS\n19\n\n\nHEREDIA\nSARAPIQUI\n19\n\n\nCARTAGO\nPARAISO\n17\n\n\nHEREDIA\nHEREDIA\n17\n\n\nPUNTARENAS\nPARRITA\n17\n\n\nGUANACASTE\nLIBERIA\n16\n\n\nPUNTARENAS\nCORREDORES\n16\n\n\nCARTAGO\nLA UNION\n15\n\n\nPUNTARENAS\nQUEPOS\n15\n\n\nALAJUELA\nSAN RAMON\n13\n\n\nPUNTARENAS\nGARABITO\n13\n\n\nSAN JOSE\nPEREZ ZELEDON\n13\n\n\nGUANACASTE\nCARRILLO\n11\n\n\nCARTAGO\nTURRIALBA\n10\n\n\nLIMON\nGUACIMO\n10\n\n\nLIMON\nTALAMANCA\n10\n\n\nSAN JOSE\nESCAZU\n8\n\n\nSAN JOSE\nASERRI\n7\n\n\nSAN JOSE\nTIBAS\n7\n\n\nSAN JOSE\nVASQUEZ DE CORONADO\n7\n\n\nALAJUELA\nLOS CHILES\n6\n\n\nGUANACASTE\nCANAS\n6\n\n\nSAN JOSE\nCURRIDABAT\n6\n\n\nSAN JOSE\nMONTES DE OCA\n6\n\n\nGUANACASTE\nABANGARES\n5\n\n\nPUNTARENAS\nESPARZA\n5\n\n\nPUNTARENAS\nGOLFITO\n5\n\n\nPUNTARENAS\nOSA\n5\n\n\nALAJUELA\nGRECIA\n4\n\n\nCARTAGO\nEL GUARCO\n4\n\n\nGUANACASTE\nLA CRUZ\n4\n\n\nHEREDIA\nSAN RAFAEL\n4\n\n\nALAJUELA\nATENAS\n3\n\n\nALAJUELA\nGUATUSO\n3\n\n\nALAJUELA\nNARANJO\n3\n\n\nALAJUELA\nOROTINA\n3\n\n\nCARTAGO\nOREAMUNO\n3\n\n\nGUANACASTE\nBAGACES\n3\n\n\nHEREDIA\nSANTO DOMINGO\n3\n\n\nPUNTARENAS\nMONTES DE ORO\n3\n\n\nSAN JOSE\nLEON CORTES\n3\n\n\nSAN JOSE\nMORAVIA\n3\n\n\nALAJUELA\nPOAS\n2\n\n\nALAJUELA\nUPALA\n2\n\n\nCARTAGO\nALVARADO\n2\n\n\nGUANACASTE\nTILARAN\n2\n\n\nHEREDIA\nSANTA BARBARA\n2\n\n\nPUNTARENAS\nCOTO BRUS\n2\n\n\nSAN JOSE\nMORA\n2\n\n\nALAJUELA\nRIO CUARTO\n1\n\n\nCARTAGO\nJIMENEZ\n1\n\n\nGUANACASTE\nNANDAYURE\n1\n\n\nHEREDIA\nBARVA\n1\n\n\nHEREDIA\nFLORES\n1\n\n\nHEREDIA\nSAN PABLO\n1\n\n\nPUNTARENAS\nBUENOS AIRES\n1\n\n\nSAN JOSE\nPURISCAL\n1\n\n\nSAN JOSE\nSANTA ANA\n1\n\n\nSAN JOSE\nTARRAZU\n1\n\n\n\n\n\n\n# Cantidad de registros por delito y subdelito\ndelitos_2023 |&gt;\n  group_by(Delito, SubDelito) |&gt;\n  summarize(\n    n = n()\n  ) |&gt;\n  arrange(desc(n)) |&gt;\n  kable()\n\n\n\n\nDelito\nSubDelito\nn\n\n\n\n\nHURTO\nPOR DESCUIDO\n8326\n\n\nROBO\nFORZADURA\n6066\n\n\nASALTO\nARMA DE FUEGO\n4915\n\n\nTACHA DE VEHICULO\nTACHA DE VEHICULO\n3863\n\n\nASALTO\nARMA BLANCA\n2925\n\n\nHURTO\nPOR CONFIANZA\n2924\n\n\nHURTO\nCARTERISTA\n2869\n\n\nROBO DE VEHICULO\nDESCUIDO\n2356\n\n\nASALTO\nARREBATO\n1915\n\n\nROBO\nBOQUETE\n1385\n\n\nROBO\nESCALAMIENTO\n1274\n\n\nASALTO\nGOLPES\n1248\n\n\nROBO DE VEHICULO\nASALTO\n1070\n\n\nROBO DE VEHICULO\nCOCHERAZO\n750\n\n\nHURTO\nARDID PREVIO/DISTRACCION\n728\n\n\nROBO\nCORTA CANDADOS\n695\n\n\nROBO\nRUPTURA VENTANA\n682\n\n\nASALTO\nINTIMIDACION VERBAL\n666\n\n\nHOMICIDIO\nAJUSTE DE CUENTAS/VENGANZA\n633\n\n\nHURTO\nOTRO O INDETERMINADO\n633\n\n\nROBO\nQUITAN CELOSIAS\n502\n\n\nHURTO\nCON LLAVE\n484\n\n\nROBO DE VEHICULO\nPOR CONFIANZA\n399\n\n\nASALTO\nCANDADO CHINO\n352\n\n\nROBO\nOTRO O INDETERMINADO\n345\n\n\nASALTO\nINMOVILIZACION\n331\n\n\nHURTO\nPROGRESIVOS\n233\n\n\nASALTO\nARMA CONTUNDENTE\n170\n\n\nASALTO\nOTRO O INDETERMINADO\n149\n\n\nROBO DE VEHICULO\nOTRO O INDETERMINADO\n133\n\n\nHOMICIDIO\nDISCUSION/RIÑA\n118\n\n\nHURTO\nRETIRO DE CAJERO AUTOMATICO\n116\n\n\nHOMICIDIO\nPOR LA COMISION DE OTRO DELITO\n83\n\n\nHURTO\nUSO DE SOMNIFERO\n74\n\n\nROBO DE VEHICULO\nARDID PREVIO\n51\n\n\nHURTO\nGANZUA/VARILLA\n47\n\n\nHOMICIDIO\nVIOLENCIA DOMESTICA\n26\n\n\nASALTO\nUSO DE GAS\n19\n\n\nHOMICIDIO\nOTRO O INDETERMINADO\n16\n\n\nHOMICIDIO\nREPELIENDO ACTIVIDAD CRIMINAL\n12\n\n\nHOMICIDIO\nPROFESIONAL\n9\n\n\nHOMICIDIO\nNO DETERMINADO\n5\n\n\nHURTO\nDESCONOCIDO\n5\n\n\nASALTO\nDESCONOCIDO\n3\n\n\nROBO\nDESCONOCIDO\n3\n\n\nHOMICIDIO\nFEMICIDIO\n1\n\n\n\n\n\nEjemplo de cálculos sin agrupamiento:\n\n# Promedio de masa y n cantidad de registros de pingüinos\npenguins |&gt;\n  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n            n = n())\n\n# A tibble: 1 × 2\n  body_mass_g_mean     n\n             &lt;dbl&gt; &lt;int&gt;\n1            4202.   344\n\n\n\n\n9.6.6 Otras\n\n9.6.6.1 distinct()\nLa función distinct() retorna las combinaciones únicas de filas en un data frame.\n\n# Valores distintos de la columna Victima\n\ndelitos_2023 |&gt;\n  distinct(Victima) |&gt;\n  kable()\n\n\n\n\nVictima\n\n\n\n\nPERSONA\n\n\nVIVIENDA\n\n\nVEHICULO\n\n\nEDIFICACION\n\n\nOTROS\n\n\n\n\n\n\n\n9.6.6.2 count()\nUna forma alternativa a summarize() para realizar un conteo es con la función count():\n\n# Conteo de delitos por tipo de Victima\ndelitos_2023 |&gt;\n  count(Victima)\n\n# A tibble: 5 × 2\n  Victima         n\n  &lt;chr&gt;       &lt;int&gt;\n1 EDIFICACION  6981\n2 OTROS        1946\n3 PERSONA     19448\n4 VEHICULO    11476\n5 VIVIENDA     9758\n\n# Expresión equivalente con summarize\ndelitos_2023 |&gt;\n  group_by(Victima) |&gt;\n  summarize(n = n()) |&gt;\n  kable()\n\n\n\n\nVictima\nn\n\n\n\n\nEDIFICACION\n6981\n\n\nOTROS\n1946\n\n\nPERSONA\n19448\n\n\nVEHICULO\n11476\n\n\nVIVIENDA\n9758",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#ejercicios",
    "href": "09-dplyr.html#ejercicios",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.7 Ejercicios",
    "text": "9.7 Ejercicios\nUtilice las funciones de dplyr para responder a las siguientes preguntas sobre el conjunto de datos penguins:\n\n¿Cuántos individuos de cada sexo hay en cada especie?\n¿Cuál es el mínimo, máximo y promedio de masa corporal (peso) por especie y sexo?\n¿Cuántos individuos se observaron durante cada año?\n¿Cuántos individuos de cada especie se observaron durante cada año?\n¿Cuántos individuos de cada especie y cada sexo se observaron durante cada año?\n¿Cuál es el promedio de masa corporal (peso) por año?\n¿Cuál es el promedio de masa corporal (peso) por año para cada especie?",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-dplyr.html#recursos-de-interés",
    "href": "09-dplyr.html#recursos-de-interés",
    "title": "9  dplyr - gramática para manipulación de datos",
    "section": "9.8 Recursos de interés",
    "text": "9.8 Recursos de interés\nRStudio. (2017). Data transformation with dplyr::Cheat Sheet. https://github.com/rstudio/cheatsheets/blob/45c1e642468695830fd8b724587ccfe8901e2185/data-transformation.pdf",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html",
    "href": "tarea-03-grupo-002.html",
    "title": "Tarea 3 - Grupo 002",
    "section": "",
    "text": "Fecha y hora límite de entrega\nMiércoles 15 de mayo de 2024, 8:00 a.m.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#descripción-general",
    "href": "tarea-03-grupo-002.html#descripción-general",
    "title": "Tarea 3 - Grupo 002",
    "section": "Descripción general",
    "text": "Descripción general\nEsta tarea consiste en desarrollar un documento Quarto con bloques de código en R que utilicen funciones de Tidyverse para consultar un conjunto de datos y presentar los resultados en formato de tablas. El documento debe publicarse como una página web en GitHub Pages.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#objetivos",
    "href": "tarea-03-grupo-002.html#objetivos",
    "title": "Tarea 3 - Grupo 002",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir código fuente en el lenguaje de programación R y utilizar funciones de la colección de paquetes de Tidyverse para leer datos, procesarlos y generar visualizaciones en forma de tablas.\nEscribir documentos en el sistema de publicación científica y técnica Quarto que combinen narrativa en Markdown con bloques de código en R.\nPublicar documentos Quarto como páginas web en GitHub Pages.\nAnalizar y corregir errores de programación.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#acerca-del-conjunto-de-datos",
    "href": "tarea-03-grupo-002.html#acerca-del-conjunto-de-datos",
    "title": "Tarea 3 - Grupo 002",
    "section": "Acerca del conjunto de datos",
    "text": "Acerca del conjunto de datos\nEl conjunto de datos de esta tarea consiste de 299 registros de pacientes que sufrieron insuficiencia cardíaca. Para cada paciente, se consideran 13 características clínicas (edad, sexo, si tenía anemia, si tenía diabetes, si fumaba y otras). Estos datos forman parte del artículo Chicco, D., Jurman, G. Machine learning can predict survival of patients with heart failure from serum creatinine and ejection fraction alone. BMC Med Inform Decis Mak 20, 16 (2020). Se recomienda leer el resumen (abstract) del artículo.\nEl archivo CSV con los datos está disponible en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2024-i/blob/main/datos/bmc/heart_failure_clinical_records_dataset.csv.\nPara más información sobre las variables del conjunto de datos, su significado y sus unidades de medida, puede consultar Meanings, measurement units, and intervals of each feature of the dataset.\nNOTA: hay varias variables booleanas con valor 0 o 1. 0 significa falso (no) y 1 significa verdadero (sí). Por ejemplo, para anaemia un valor de 1 significa que el paciente sí tuvo anemia y un valor de 0 significa que no tuvo anemia. En el caso de sex, un 0 corresponde a una mujer y un 1 a un hombre.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#entregables",
    "href": "tarea-03-grupo-002.html#entregables",
    "title": "Tarea 3 - Grupo 002",
    "section": "Entregables",
    "text": "Entregables\nDebe entregar dos direcciones web:\n\nDirección de un repositorio en GitHub (ej. https://github.com/mfvargas/insuficiencia-cardiaca) con el código fuente y los datos. Específicamente, el repositorio debe contener:\n\nUn documento Quarto llamado index.qmd con el código en R y la sintaxis Markdown necesarios para generar las salidas especificadas en la sección Desarrollo.\nUn documento llamado index.html generado a partir de index.qmd.\nEl archivo de datos heart_failure_clinical_records_dataset.csv.\nEl directorio index_files.\n\nDirección de un sitio web en GitHub Pages publicado a partir del repositorio GitHub del punto 1 (ej. https://mfvargas.github.io/insuficiencia-cardiaca/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#desarrollo",
    "href": "tarea-03-grupo-002.html#desarrollo",
    "title": "Tarea 3 - Grupo 002",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl documento Quarto debe cumplir con las siguientes características generales:\n\nEn general, debe estar ordenado y bien presentado (incluyendo la redacción y la ortografía).\nDebe tener una tabla de contenidos.\nEl lenguaje del documento debe ser español.\nDebe utilizar un estilo (theme) de Quarto para HTML.\n\nEl documento debe contener las siguientes secciones:\n\n1 - Introducción\nBreve explicación del contenido del documento (uno o dos párrafos) y mención de la fuente de los datos originales: el enlace al artículo de Chicco y Jurman.\n\n\n2 - Carga de paquetes\nBloque de código en R para cargar los paquetes.\n\n\n3 - Carga de datos\nBloque de código en R para cargar los datos.\n\n\n4 - Consultas\nDebe escribir cuatro bloques de código en R que consulten el conjunto de datos y presenten los resultados en tablas. Los bloques de código en R deben utilizar funciones del paquete dplyr de Tidyverse (select(), filter(), mutate(), arrange(), group_by(), summarize() y otras). Las tablas deben generarse mediante la función kable() del paquete knitr.\nEn cada caso, debe mostrarse el bloque de código y la tabla que muestra los resultado de la consulta, como se ejemplifica en la siguiente figura:\n\n\nConsulta 1\nTabla que para los hombres mayores de 70 años, diabéticos y no anémicos muestre, en orden descendente de edad, las columnas correspondientes a:\n\nSexo\nEdad\nDiabetes\nAnemia\nPresión arterial alta\n\n\n\nConsulta 2\nTabla que muestre para todas las mujeres con fracción de eyección entre 20 (inclusive) y 25 (inclusive), en orden descendente de fracción de eyección, las columnas correspondientes a:\n\nSexo\nFracción de eyección\nAnemia\nDiabetes\n\n\n\nConsulta 3\nTabla que muestre el promedio de creatinina sérica de pacientes sobrevivientes y de pacientes fallecidos.\n\n\nConsulta 4\nTabla que muestre el valor máximo de creatinina sérica de las mujeres que son anémicas o diabéticas.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#calificación",
    "href": "tarea-03-grupo-002.html#calificación",
    "title": "Tarea 3 - Grupo 002",
    "section": "Calificación",
    "text": "Calificación\n\nPresentación general del documento (uso de un tema, tabla de contenidos, lenguaje, orden, redacción): 20%\nConsulta 1: 20%\nConsulta 2: 20%\nConsulta 3: 20%\nConsulta 4: 20%",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-03-grupo-002.html#consideraciones-adicionales",
    "href": "tarea-03-grupo-002.html#consideraciones-adicionales",
    "title": "Tarea 3 - Grupo 002",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\n\nEsta tarea puede presentarse individualmente o en parejas. En este último caso, solo un estudiante debe presentar la tarea en Mediación Virtual y debe indicar ahí el nombre del otro estudiante.\nSi solo se entrega la dirección del repositorio en GitHub, y no el sitio publicado o este no es consistente con el código fuente del repositorio, se rebajará el 25% del valor de la tarea. RECOMENDACIÓN: genere el sitio web desde el inicio y actualícelo continuamente. No lo deje para última hora.\nNo se aceptarán tareas que se entreguen después de la fecha y hora límite.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 002"
    ]
  },
  {
    "objectID": "parte-vii-evaluaciones.html#tareas",
    "href": "parte-vii-evaluaciones.html#tareas",
    "title": "Evaluaciones",
    "section": "Tareas",
    "text": "Tareas\nTarea 3 - Grupo 001\nTarea 3 - Grupo 002\nTarea 4 - Grupo 001\nTarea 4 - Grupo 002",
    "crumbs": [
      "Evaluaciones"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html",
    "href": "tarea-03-grupo-001.html",
    "title": "Tarea 3 - Grupo 001",
    "section": "",
    "text": "Fecha y hora límite de entrega\nJueves 16 de mayo de 2024, 11:00 a.m.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#descripción-general",
    "href": "tarea-03-grupo-001.html#descripción-general",
    "title": "Tarea 3 - Grupo 001",
    "section": "Descripción general",
    "text": "Descripción general\nEsta tarea consiste en desarrollar un documento Quarto con bloques de código en R que utilicen funciones de Tidyverse para consultar un conjunto de datos y presentar los resultados en formato de tablas. El documento debe publicarse como una página web en GitHub Pages.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#objetivos",
    "href": "tarea-03-grupo-001.html#objetivos",
    "title": "Tarea 3 - Grupo 001",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir código fuente en el lenguaje de programación R y utilizar funciones de la colección de paquetes de Tidyverse para leer datos, procesarlos y generar visualizaciones en forma de tablas.\nEscribir documentos en el sistema de publicación científica y técnica Quarto que combinen narrativa en Markdown con bloques de código en R.\nPublicar documentos Quarto como páginas web en GitHub Pages.\nAnalizar y corregir errores de programación.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#acerca-del-conjunto-de-datos",
    "href": "tarea-03-grupo-001.html#acerca-del-conjunto-de-datos",
    "title": "Tarea 3 - Grupo 001",
    "section": "Acerca del conjunto de datos",
    "text": "Acerca del conjunto de datos\nEl conjunto de datos de esta tarea consiste de 299 registros de pacientes que sufrieron insuficiencia cardíaca. Para cada paciente, se consideran 13 características clínicas (edad, sexo, si tenía anemia, si tenía diabetes, si fumaba y otras). Estos datos forman parte del artículo Chicco, D., Jurman, G. Machine learning can predict survival of patients with heart failure from serum creatinine and ejection fraction alone. BMC Med Inform Decis Mak 20, 16 (2020). Se recomienda leer el resumen (abstract) del artículo.\nEl archivo CSV con los datos está disponible en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2024-i/blob/main/datos/bmc/heart_failure_clinical_records_dataset.csv.\nPara más información sobre las variables del conjunto de datos, su significado y sus unidades de medida, puede consultar Meanings, measurement units, and intervals of each feature of the dataset.\nNOTA: hay varias variables booleanas con valor 0 o 1. 0 significa falso (no) y 1 significa verdadero (sí). Por ejemplo, para anaemia un valor de 1 significa que el paciente sí tuvo anemia y un valor de 0 significa que no tuvo anemia. En el caso de sex, un 0 corresponde a una mujer y un 1 a un hombre.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#entregables",
    "href": "tarea-03-grupo-001.html#entregables",
    "title": "Tarea 3 - Grupo 001",
    "section": "Entregables",
    "text": "Entregables\nDebe entregar dos direcciones web:\n\nDirección de un repositorio en GitHub (ej. https://github.com/mfvargas/insuficiencia-cardiaca) con el código fuente y los datos. Específicamente, el repositorio debe contener:\n\nUn documento Quarto llamado index.qmd con el código en R y la sintaxis Markdown necesarios para generar las salidas especificadas en la sección Desarrollo.\nUn documento llamado index.html generado a partir de index.qmd.\nEl archivo de datos heart_failure_clinical_records_dataset.csv.\nEl directorio index_files.\n\nDirección de un sitio web en GitHub Pages publicado a partir del repositorio GitHub del punto 1 (ej. https://mfvargas.github.io/insuficiencia-cardiaca/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#desarrollo",
    "href": "tarea-03-grupo-001.html#desarrollo",
    "title": "Tarea 3 - Grupo 001",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl documento Quarto debe cumplir con las siguientes características generales:\n\nEn general, debe estar ordenado y bien presentado (incluyendo la redacción y la ortografía).\nDebe tener una tabla de contenidos.\nEl lenguaje del documento debe ser español.\nDebe utilizar un estilo (theme) de Quarto para HTML.\n\nEl documento debe contener las siguientes secciones:\n\n1 - Introducción\nBreve explicación del contenido del documento (uno o dos párrafos) y mención de la fuente de los datos originales: el enlace al artículo de Chicco y Jurman.\n\n\n2 - Carga de paquetes\nBloque de código en R para cargar los paquetes.\n\n\n3 - Carga de datos\nBloque de código en R para cargar los datos.\n\n\n4 - Consultas\nDebe escribir cuatro bloques de código en R que consulten el conjunto de datos y presenten los resultados en tablas. Los bloques de código en R deben utilizar funciones del paquete dplyr de Tidyverse (select(), filter(), mutate(), arrange(), group_by(), summarize() y otras). Las tablas deben generarse mediante la función kable() del paquete knitr.\nEn cada caso, debe mostrarse el bloque de código y la tabla que muestra los resultado de la consulta, como se ejemplifica en la siguiente figura:\n\n\nConsulta 1\nTabla que para las mujeres mayores de 75 años muestre, en orden descendente de edad, las columnas correspondientes a:\n\nSexo\nEdad\nDiabetes\nPresión arterial alta\nCreatinina sérica\n\n\n\nConsulta 2\nTabla que para todos los hombres diabéticos o fumadores muestre, en orden ascendente de edad, las columnas correspondientes a:\n\nSexo\nEdad\nDiabetes\nFumador\nFracción de eyección\n\n\n\nConsulta 3\nTabla que muestre el promedio de fracción de eyección de los pacientes diabéticos y de los pacientes no diabéticos.\n\n\nConsulta 4\nTabla que muestre la menor edad de los hombres fallecidos.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#calificación",
    "href": "tarea-03-grupo-001.html#calificación",
    "title": "Tarea 3 - Grupo 001",
    "section": "Calificación",
    "text": "Calificación\n\nPresentación general del documento (uso de un tema, tabla de contenidos, lenguaje, orden, redacción): 20%\nConsulta 1: 20%\nConsulta 2: 20%\nConsulta 3: 20%\nConsulta 4: 20%",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-03-grupo-001.html#consideraciones-adicionales",
    "href": "tarea-03-grupo-001.html#consideraciones-adicionales",
    "title": "Tarea 3 - Grupo 001",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\n\nEsta tarea puede presentarse individualmente o en parejas. En este último caso, solo un estudiante debe presentar la tarea en Mediación Virtual y debe indicar ahí el nombre del otro estudiante.\nSi solo se entrega la dirección del repositorio en GitHub, y no el sitio publicado o este no es consistente con el código fuente del repositorio, se rebajará el 25% del valor de la tarea. RECOMENDACIÓN: genere el sitio web desde el inicio y actualícelo continuamente. No lo deje para última hora.\nNo se aceptarán tareas que se entreguen después de la fecha y hora límite.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 3 - Grupo 001"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html",
    "href": "10-ggplot2-plotly.html",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "10.1 Resumen\nR proporciona una gran cantidad de funciones para la elaboración de gráficos estadísticos y otros tipos de visualizaciones. El paquete base de R, por ejemplo, contiene un conjunto básico de funciones muy versátiles, especialmente para gráficos simples de conjuntos de datos relativamente pequeños. Sin embargo, para visualizaciones más avanzadas, puede ser conveniente explorar otras bibliotecas.\nggplot2 es una de las bibliotecas más populares de graficación de R. Implementa el concepto de “gramática de gráficos”, que permite crear visualizaciones complejas a partir de capas y componentes simples. Forma parte de Tidyverse, por lo que se comunica muy bien con los demás paquetes de esta familia, enfocada en conjuntos de datos grandes y en ciencia de datos.\nplotly es una biblioteca para crear gráficos interactivos y dinámicos. Contiene capacidades para agregar controles y mecanismos que le permiten al usuario interactuar con los gráficos y realizar operaciones como filtrados, acercamientos y alejamientos, entre otras.\nEl paquete DT, por su parte, permite presentar conjuntos de datos en tablas interactivas en las que se pueden realizar operaciones como ordenamientos, consultas y filtrados.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#trabajo-previo",
    "href": "10-ggplot2-plotly.html#trabajo-previo",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.2 Trabajo previo",
    "text": "10.2 Trabajo previo\n\n10.2.1 Lecturas\nChang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. O’Reilly. https://r-graphics.org/\nWickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (capítulo 3). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos (1era ed.) (capítulo 3). https://es.r4ds.hadley.nz/\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) (capítulo 2). https://r4ds.hadley.nz/\nWickham, H., Navarro, D., & Pedersen, T. L. (s.f.). ggplot2: Elegant graphics for data analysis. https://ggplot2-book.org/",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#instalación-y-carga",
    "href": "10-ggplot2-plotly.html#instalación-y-carga",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.3 Instalación y carga",
    "text": "10.3 Instalación y carga\nLos paquetes necesarios pueden instalarse con la función install.packages(). Ya que se usaron en capítulos anteriores, en este punto se asumen instalados los paquetes de Tidyverse.\n\n# Instalación de plotly\ninstall.packages(\"plotly\")\n\n# Instalación de DT\ninstall.packages(\"DT\")\n\nUna vez instalados, los paquetes pueden cargarse con la función library():\n\n# Carga conjunta de Tidyverse \n# (incluye ggplot2, dplyr, readr y otros)\nlibrary(tidyverse)\n\n# Carga de plotly\nlibrary(plotly)\n\n# Carga de DT\nlibrary(DT)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "href": "10-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.4 Conjuntos de datos de ejemplo",
    "text": "10.4 Conjuntos de datos de ejemplo\n\n10.4.1 mpg\nmpg es uno de los conjuntos de datos de ejemplo que se incluyen junto con el paquete ggplot2. Contiene observaciones para 38 modelos de automóviles, recopiladas por la Agencia de Protección Ambiental de los Estados Unidos, y un conjunto de variables relacionadas con el consumo de combustible.\nEn el siguiente bloque de código, se utiliza la función datatable() del paquete DT, para desplegar las observaciones de mpg en una tabla.\n\n# Tabla de datos de mpg\nmpg |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\nDT es un “envoltorio” (wrapper) de la biblioteca DataTables de JavaScript, un lenguaje ampliamente utilizado en el desarrollo de páginas web interactivas.\n\n\n10.4.2 diamonds\ndiamonds es otro de los conjuntos de datos de ejemplo de ggplot2. Contiene observaciones de más de 50000 diamantes, incluyendo su precio, color, claridad y otros atributos.\n\n# Tabla de datos de diamonds\ndiamonds |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\n\n10.4.3 gapminder\nEste conjunto es un extracto de los datos disponibles en Gapminder.org, una organización son fines de lucro que promueve el desarrollo global y el cumplimiento de los Objetivos de Desarrollo del Milenio de las Naciones Unidas, a través de la estadística y la información general sobre desarrollo social, económico y ambiental a nivel local, nacional y global.\nSe distribuye en el paquete gapminder, el cual contiene el data frame gapminder, que incluye datos de esperanza de vida, producto interno bruto y población de 142 países, para cada cinco años, entre 1952 y 2007.\n\n# Instalación de gapminder\ninstall.packages(\"gapminder\")\n\n\n# Carga de gapminder\nlibrary(gapminder)\n\nLa siguiente tabla muestra los datos de gapminder para el año 2007.\n\n# Tabla de datos de gapminder\ngapminder |&gt;\n  filter(year == 2007) |&gt; # filtro para el año 2007\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\n\n10.4.4 Casos de COVID-19 en Costa Rica\nEstos datos fueron publicados por el Ministerio de Salud de Costa Rica en https://geovision.uned.ac.cr/oges/ (a la fecha de escritura de este documento, el enlace no está funcionando). Se distribuyen en archivos CSV, incluyendo un archivo de datos generales para todo el país y varios archivos con datos por cantón. La fecha de la última actualización es 2022-05-30.\nPuede encontrar el archivo que se necesita para este capítulo en https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/ministerio-salud/covid/05_30_22_CSV_GENERAL.csv.\nEl siguiente bloque de código, carga y transforma los datos generales de COVID-19 con funciones de los paquetes readr y dplyr. La función read_delim() de readr, lee datos de formatos tabulares (ej. CSV, TSV) y, entre otras ventajas, permite cargar solo las columnas especificadas en el argumento col_select. Las funciones read_csv(), read_csv2() y read_tsv() son casos especiales de read_delim().\n\n# Carga del archivo CSV de entrada en un dataframe\n# con la función read_delim() de readr\ncovid_general &lt;-\n  read_delim(\n    file = \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/ministerio-salud/covid/05_30_22_CSV_GENERAL.csv\",\n    col_select = c(\n      \"FECHA\",\n      \"positivos\",\n      \"activos\",\n      \"RECUPERADOS\",\n      \"fallecidos\",\n      \"nue_posi\",\n      \"nue_falleci\",\n      \"salon\",\n      \"UCI\"\n    )\n  )\n\n# Cambio de nombre de columnas\ncovid_general &lt;-\n  covid_general |&gt;\n  rename(\n    fecha = FECHA,\n    recuperados = RECUPERADOS,\n    nuevos_positivos = nue_posi,\n    nuevos_fallecidos = nue_falleci,\n    uci = UCI\n  )\n\n# Cambio de tipo de datos de la columna fecha, de str a date\ncovid_general &lt;-\n  covid_general |&gt;\n  mutate(fecha = as.Date(fecha, format = \"%d/%m/%Y\"))\n\nLa siguiente tabla muestra los datos generales de COVID-19.\n\n# Tabla de datos de COVID generales\ncovid_general |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\n\n10.4.5 Delitos cometidos en 2023 en Costa Rica\nContiene estadísticas policiales de 2022, publicadas en el sitio de datos abiertos del Organismo de Investigación Judicial (OIJ).\nPuede encontrar el archivo que se necesita para este capítulo en https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/oij/estadisticas-policiales/estadisticaspoliciales2023.csv\n\n# Carga de datos\ndelitos_2023 &lt;-\n  read_delim(\n    file = \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/oij/estadisticas-policiales/estadisticaspoliciales2023.csv\"\n  )\n\n# Tabla de datos\ndelitos_2023 |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "examen-corto-03.html",
    "href": "examen-corto-03.html",
    "title": "Examen corto 3",
    "section": "",
    "text": "Fecha",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3"
    ]
  },
  {
    "objectID": "examen-corto-03.html#fecha",
    "href": "examen-corto-03.html#fecha",
    "title": "Examen corto 3",
    "section": "",
    "text": "Grupo 001: jueves 23 de mayo de 2024\nGrupo 002: miércoles 22 de mayo de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3"
    ]
  },
  {
    "objectID": "examen-corto-03.html#temas-a-evaluar",
    "href": "examen-corto-03.html#temas-a-evaluar",
    "title": "Examen corto 3",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n9 dplyr - gramática para manipulación de datos\n10 ggplot2 y plotly - creación declarativa de gráficos interactivos (hasta la sección 10.5.2 “plotly” inclusive)",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3"
    ]
  },
  {
    "objectID": "examen-corto-03-01.html",
    "href": "examen-corto-03-01.html",
    "title": "Examen corto 3 - Grupo 001",
    "section": "",
    "text": "Fecha\nJueves 23 de mayo de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3 - Grupo 001"
    ]
  },
  {
    "objectID": "examen-corto-03-01.html#temas-a-evaluar",
    "href": "examen-corto-03-01.html#temas-a-evaluar",
    "title": "Examen corto 3 - Grupo 001",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n9 dplyr - gramática para manipulación de datos\n10 ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3 - Grupo 001"
    ]
  },
  {
    "objectID": "examen-corto-03-02.html",
    "href": "examen-corto-03-02.html",
    "title": "Examen corto 3 - Grupo 002",
    "section": "",
    "text": "Fecha\nMartes 28 de mayo de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3 - Grupo 002"
    ]
  },
  {
    "objectID": "examen-corto-03-02.html#temas-a-evaluar",
    "href": "examen-corto-03-02.html#temas-a-evaluar",
    "title": "Examen corto 3 - Grupo 002",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n9 dplyr - gramática para manipulación de datos\n10 ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 3 - Grupo 002"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html",
    "href": "11-introduccion-manejo-datos-geoespaciales.html",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "",
    "text": "11.1 Resumen\nEl lenguaje de programación R cuenta con una gran variedad de paquetes para manejo de datos geoespaciales, entre los que están el paquete sf para datos vectoriales, el paquete terra para datos raster y el paquete leaflet para mapas en la Web.\nEl modelo vectorial se basa en puntos localizados en un sistema de referencia de coordenadas. Los puntos pueden representar objetos independientes o pueden agruparse para formar geometrías más complejas como líneas (ej. ríos, caminos) o polígonos (ej. fincas, países, provincias).\nEl modelo de datos raster usualmente consiste de un encabezado y de una matriz con celdas (también llamadas pixeles) de un mismo tamaño. Cada celda tiene una identificación (ID) y almacena un único valor, el cual puede ser numérico o categórico.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#trabajo-previo",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#trabajo-previo",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.2 Trabajo previo",
    "text": "11.2 Trabajo previo\n\n11.2.1 Lecturas\nLovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulos 1 y 2). CRC Press. https://geocompr.robinlovelace.net/",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#introducción",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#introducción",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.3 Introducción",
    "text": "11.3 Introducción\nLa comunidad de programadores de R ha desarrollado un conjunto de paquetes para el manejo de datos geoespaciales, tanto en formatos vectoriales como raster. Algunos de los principales de estos paquetes son:\n\nEl paquete sf. Ofrece un conjunto de funciones para el manejo de datos vectoriales, de acuerdo con el estándar Simple Features.\nEl paquete terra. Implementa un conjunto de funciones para el manejo de datos raster. Es una reimplementación del paquete raster.\nEl paquete leaflet. Es una implementación en R de la biblioteca Leaflet para el lenguaje JavaScript para la programación de mapas interactivos en páginas web.\n\nAlgunos paquetes de graficación estadística, como ggplot2 y plotly, también cuentan con capacidades para visualización de datos geoespaciales.\nEn CRAN Task View: Analysis of Spatial Data, puede encontrarse un resumen detallado de los paquetes de R con funciones geoespaciales.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.4 Datos vectoriales",
    "text": "11.4 Datos vectoriales\n\n11.4.1 El modelo vectorial\nEl modelo vectorial de datos está basado en puntos localizados en un sistema de referencia de coordenadas (CRS). Los puntos individuales pueden representar objetos independientes (ej. postes eléctricos, cabinas telefónicas) o pueden también agruparse para formar geometrías más complejas como líneas (ej. ríos, caminos) o polígonos (ej. fincas, países, provincias). Por lo general, los puntos tienen solo dos dimensiones (x, y), a las que se les puede agregar una tercera dimensión z, usualmente correspondiente a la altitud sobre el nivel del mar.\n\n\n11.4.2 El estándar Simple Features\nSimple Features (o Simple Feature Access) es un estándar abierto de la Organización Internacional de Estandarización (ISO) y del Open Geospatial Consortium (OGC) que especifica un modelo común de almacenamiento y acceso para geometrías de dos dimensiones (líneas, polígonos, multilíneas, multipolígonos, etc.). El estándar es implementado por muchas bibliotecas y bases de datos geoespaciales como sf, Fiona, GDAL, PostgreSQL/PostGIS, SQLite/SpatiaLite, Oracle Spatial y Microsoft SQL Server, entre muchas otras.\nLa especificación define 17 tipos de geometrías, de las cuales siete son las más comúnmente utilizadas. Estas últimas se muestran en la Figura 11.1.\n\n\n\n\n\n\n\n\nFigura 11.1: Tipos de geometrías de Simple Features más usadas. Imagen de Robin Lovelace et al..\n\n\n\n\n\n\n\n11.4.3 El paquete sf\nEl paquete sf (de Simple Features) de R implementa los modelos de datos de las geometrías de tipo vectorial: puntos, líneas, polígonos, sus versiones múltiples y las colecciones de geometrías. Está basado en bibliotecas de sofware ampliamente utilizadas en aplicaciones geoespaciales:\n\nGeospatial Data Abstraction Library (GDAL): es una biblioteca para leer y escribir datos geoespaciales en varios formatos raster y vectoriales. Implementa un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato que se utilice (GeoTIFF, NetCDF, ESRI Shapefile, GeoJSON, etc.). A pesar de que GDAL está programada en C/C++, cuenta con una interfaz de programación de aplicaciones (API) para varios lenguajes de programación, incluyendo C, C++, Python y Java. Además, ofrece un conjunto de utilitarios de línea de comandos cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux.\nGeometry Engine, Open Source (GEOS): es una implementación en C++ de la biblioteca JTS Topology Suite (desarrollada en Java) y que implementa un conjunto de operaciones y predicados geoespaciales (ej. unión, intersección, distancia, área).\nPROJ: es una biblioteca que transforma coordenadas entre diferentes CRS, incluyendo tanto proyecciones cartográficas como transformaciones geodésicas.\n\nsf provee acceso, desde un mismo paquete de R, a la funcionalidad de estas tres bibliotecas, proporcionando así una interfaz unificada para leer y escribir datos geoespaciales mediante GDAL, realizar operaciones con geometrías mediante GEOS y efectuar transformaciones entre sistemas de coordenadas mediante PROJ.\nEn sf, los conjuntos de datos geoespaciales se almacenan en objetos de una clase también llamada sf, los cuales son data frames que contiene una columna especial para las geometrías. Esta columna se denomina generalmente geom o geometry (aunque pueden tener cualquier otro nombre). El manejo de datos geoespaciales como data frames permite manipularlos con las funciones ya desarrolladas para este tipo de datos y con la misma forma de referenciar las filas (observaciones) y las columnas (variables).\n\n11.4.3.1 Instalación y carga\n\n# Instalación de sf\ninstall.packages(\"sf\")\n\n\n# Carga de sf\nlibrary(sf)\n\n\n\n11.4.3.2 Métodos\nLa lista de métodos (i.e. funciones) de la clase sf puede obtenerse a través de la función methods():\n\n# Métodos de la clase sf\nmethods(class = \"sf\")\n\n [1] [                            [[&lt;-                        \n [3] [&lt;-                          $&lt;-                         \n [5] aggregate                    as.data.frame               \n [7] cbind                        coerce                      \n [9] dbDataType                   dbWriteTable                \n[11] duplicated                   identify                    \n[13] initialize                   merge                       \n[15] plot                         print                       \n[17] rbind                        show                        \n[19] slotsFromS3                  st_agr                      \n[21] st_agr&lt;-                     st_area                     \n[23] st_as_s2                     st_as_sf                    \n[25] st_as_sfc                    st_bbox                     \n[27] st_boundary                  st_break_antimeridian       \n[29] st_buffer                    st_cast                     \n[31] st_centroid                  st_collection_extract       \n[33] st_concave_hull              st_convex_hull              \n[35] st_coordinates               st_crop                     \n[37] st_crs                       st_crs&lt;-                    \n[39] st_difference                st_drop_geometry            \n[41] st_filter                    st_geometry                 \n[43] st_geometry&lt;-                st_inscribed_circle         \n[45] st_interpolate_aw            st_intersection             \n[47] st_intersects                st_is_valid                 \n[49] st_is                        st_join                     \n[51] st_line_merge                st_m_range                  \n[53] st_make_valid                st_minimum_rotated_rectangle\n[55] st_nearest_points            st_node                     \n[57] st_normalize                 st_point_on_surface         \n[59] st_polygonize                st_precision                \n[61] st_reverse                   st_sample                   \n[63] st_segmentize                st_set_precision            \n[65] st_shift_longitude           st_simplify                 \n[67] st_snap                      st_sym_difference           \n[69] st_transform                 st_triangulate_constrained  \n[71] st_triangulate               st_union                    \n[73] st_voronoi                   st_wrap_dateline            \n[75] st_write                     st_z_range                  \n[77] st_zm                        transform                   \nsee '?methods' for accessing help and source code\n\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos de la clase sf.\n\n11.4.3.2.1 st_read() - lectura de datos\nEl método st_read() lee datos vectoriales de una fuente en formato geoespacial (ej. shapefiles, archivos GeoJSON, bases de datos geoespaciales) y los recupera en un objeto sf.\nEn el siguiente bloque de código en R, se utiliza el método st_read() para leer un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura de una capa vectorial (GeoJSON) de provincias de Costa Rica\nprovincias &lt;-\n  st_read(\n    \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE # para evitar el despliegue de mensajes\n  )\n\nst_read() también puede crear objetos sf a partir de archivos de texto. Esta variante se utiliza principalmente cuando el archivo contiene coordenadas correspondientes a geometrías de puntos.\nEn el siguiente bloque de código, se utiliza st_read() para leer un archivo CSV con registros de presencia de félidos de Costa Rica, el cual contiene dos columnas llamadas decimalLongitude y decimalLatitude correspondientes a la longitud decimal y latitud decimal en las que fue observado cada felino. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\n\n# Lectura de un archivo CSV con registros de presencia de félidos en Costa Rica\nfelidos &lt;-\n  st_read(\n    \"datos/gbif/felidos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\nTanto provincias como felidos son objetos de la clase sf (y además de data.frame).\n\n# Clase del objeto provincias\nclass(provincias)\n\n[1] \"sf\"         \"data.frame\"\n\n# Clase del objeto felidos\nclass(felidos)\n\n[1] \"sf\"         \"data.frame\"\n\n\nAl escribirse el nombre de un objeto sf en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto provincias\nprovincias\n\nSimple feature collection with 7 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 156152 ymin: 608833.8 xmax: 658879.5 ymax: 1241118\nProjected CRS: CR05 / CRTM05\n  cod_catalo cod_provin  provincia\n1     160103          6 Puntarenas\n2     160103          1   San José\n3     160103          7      Limón\n4     160103          3    Cartago\n5     160103          2   Alajuela\n6     160103          5 Guanacaste\n7     160103          4    Heredia\n                                                                                                                                                                                                                 ori_toponi\n1 En documento de 1720, se menciona la llegada del pirata Chipperton a la zona, en el cual aparece la descripcíon referente a una embarcación pequeña en la Punta de Arena, adoptando con el tiempo el nombre de Puntarenas\n2                                                                                                                                              Se remonta a la creación de la ermita dedicada al Patriarca San José en 1737\n3                                                                                         El origen del nombre de la provincia se remonta a 1852, cuando por primera vez se cita en un documento oficial el puerto de Limón\n4                                         Don Juan Vázques de Coronado escogió el sitio en el valle del Guarco para trasladar a la ciudad de Garcimuños, en 1563, bautizando al nuevo asentamiento con el nombre de Cartago\n5                                                                                                                  Se remonta al paraje llamado La Lajuela que por primera vez se cita en los Protocolos de Cartago de 1657\n6        En alegoria a un frondoso árbol de Guanacaste ubicado en la intersección de los caminos que se dirigían a Nicoya, Bagaces y Rivas, en lo que hoy día es el parque de Liberia. Esta referencia data del siglo XVIII\n7                                        En correspondiencia al Presidente  de la Real Audiencia de Guatemala, Capitán General don Alonso Fernández de Heredia, de la Inmaculada Concepción de Cubujuquí a Villa de Heredia\n      area  version                       geometry\n1 11298.51 20201222 MULTIPOLYGON (((159917.7 60...\n2  4969.73 20201222 MULTIPOLYGON (((505765.3 11...\n3  9176.96 20201222 MULTIPOLYGON (((532516.6 12...\n4  3093.23 20201222 MULTIPOLYGON (((556146.1 10...\n5  9772.27 20201222 MULTIPOLYGON (((427195 1224...\n6 10196.32 20201222 MULTIPOLYGON (((380807.3 11...\n7  2663.46 20201222 MULTIPOLYGON (((497345.1 11...\n\n\n\n\n11.4.3.2.2 st_crs() y st_transform() - manejo de sistemas de coordenadas\nEl método st_crs() retorna el CRS de un objeto sf.\n\n# Despliegue del CRS del objeto provincias\nst_crs(provincias)\n\nCoordinate Reference System:\n  User input: CR05 / CRTM05 \n  wkt:\nPROJCRS[\"CR05 / CRTM05\",\n    BASEGEOGCRS[\"CR05\",\n        DATUM[\"Costa Rica 2005\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",5365]],\n    CONVERSION[\"Costa Rica TM 2005\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-84,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9999,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping (large and medium scale).\"],\n        AREA[\"Costa Rica - onshore and offshore east of 86°30'W.\"],\n        BBOX[2.21,-86.5,11.77,-81.43]],\n    ID[\"EPSG\",5367]]\n\n# Despliegue CRS del objeto felidos\nst_crs(felidos)\n\nCoordinate Reference System: NA\n\n\nst_crs() también puede asignar un CRS a un objeto sf que no lo tiene.\n\n# Asignación de un CRS al objeto felidos\nst_crs(felidos) &lt;- 4326\n\nEl método st_transform() transforma un objeto sf a un nuevo CRS.\n\n# Transformación del CRS del objeto provincias a WGS84 (EPSG = 4326)\nprovincias &lt;-\n  provincias |&gt;\n  st_transform(4326)\n\n\n\n11.4.3.2.3 plot() - mapeo\nEl método plot() grafica objetos sf en un mapa.\n\n# Mapeo de las geometrías del objeto provincias\nplot(provincias$geometry)\n\n\n\n\n\n\n\n# Mapeo con argumentos adicionales de plot()\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Registros de presencia de félidos en Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa\nplot(felidos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")\n\n\n\n\n\n\n\n\nPara conocer los valores del argumento pch, puede consultar R plot pch symbols.\n\n\n11.4.3.2.4 st_write() - escritura de datos\nEl método st_write() guarda en el disco un objeto sf en los diferentes formatos vectoriales de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto provincias en formato GPKG\nprovincias |&gt;\n  st_write(\"provincias.gpkg\")\n\n# Escritura del objeto felidos en formato KML\nfelidos |&gt;\n  st_write(\"felidos.kml\")\n\n\n\n11.4.3.2.5 Otros\n\n# Cantidad de filas de un objeto sf\nnrow(provincias)\n\n[1] 7\n\n# Cantidad de columnas de un objeto sf\nncol(provincias)\n\n[1] 7\n\n# Resumen de la columna de geometría\nsummary(provincias$geometry)\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n            7             0             0 \n\n\n\n\n\n\n11.4.4 Mapeo de objetos sf con otros paquetes\n\n11.4.4.1 leaflet\nEl paquete leaflet genera mapas interactivos en lenguaje de marcado de hipertexto (HTML), el lenguaje de marcado utilizado para desarrollar páginas web.\n\n11.4.4.1.1 Instalación y carga\n\n# Instalación de leaflet\ninstall.packages(\"leaflet\")\n\n# Instalación de leaflet.extras (funciones adicionales de leaflet)\ninstall.packages(\"leaflet.extras\")\n\n# Instalación de leaflem (funciones adicionales de leaflet)\ninstall.packages(\"leafem\")\n\n\n# Carga de leaflet\nlibrary(leaflet)\n\n# Carga de leaflet.extras\nlibrary(leaflet.extras)\n\n# Carga de leafem\nlibrary(leafem)\n\nEl siguiente bloque de código muestra las capas de provincias (polígonos) y de registros de presencia de félidos (puntos) sobre una capa base de OpenStreetMap (OSM) y otra de ESRI.\n\n# Mapa leaflet básico de provincias y registros de presencia de félidos\nleaflet() |&gt;\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |&gt;\n  addTiles(group = \"Mapa general (OpenStreetMap)\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales (ESRI World Imagery)\"\n  ) |&gt;\n  addPolygons(\n    # capa de provincias (polígonos)\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n    group = \"Provincias\"\n  ) |&gt;\n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = felidos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos$institutionCode),\n      paste0(\"&lt;a href='\", felidos$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Félidos\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\n      \"Mapa general (OpenStreetMap)\", \n      \"Imágenes satelitales (ESRI World Imagery)\"\n    ),\n    overlayGroups = c(\"Provincias\", \"Félidos\")) |&gt; # control de capas\n  addResetMapButton() |&gt; # botón de reinicio\n  addSearchOSM() |&gt; # búsqueda en OSM\n  addMouseCoordinates() |&gt; # coordenadas del puntero del ratón\n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt; # barra de escala\n  addMiniMap(position = \"bottomright\") |&gt; # mapa de ubicación\n  addFullscreenControl() # mapa de pantalla completa",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.5 Datos raster",
    "text": "11.5 Datos raster\n\n11.5.1 El modelo raster\nEl modelo de datos raster usualmente consiste de un encabezado y de una matriz con celdas (también llamadas pixeles) de un mismo tamaño. El encabezado define el CRS, la extensión y el punto de origen de una capa raster. Por lo general, el origen se ubica en la esquina inferior izquierda o en la esquina superior izquierda de la matriz. La extensión se define mediante el número de filas, el número de columnas y el tamaño (resolución) de la celda.\nCada celda tiene una identificación (ID) y almacena un único valor, el cual puede ser numérico o categórico, como se muestra en la Figura 11.2.\n\n\n\n\n\n\n\n\nFigura 11.2: El modelo raster: (A) ID de las celdas, (B) valores de las celdas, (C) mapa raster de colores. Imagen de Robin Lovelace et al.\n\n\n\n\n\nA diferencia del modelo vectorial, el modelo raster no necesita almacenar todas las coordenadas de cada geometría (i.e. las esquinas de las celdas), debido a que la ubicación de cada celda puede calcularse a partir de la información contenida en el encabezado. Esta simplicidad, en conjunto con el álgebra de mapas, permiten que el procesamiento de datos raster sea mucho más eficiente que el procesamiento de datos vectoriales. Por otra parte, el modelo vectorial es mucho más flexible en cuanto a las posibilidades de representación de geometrías y almacenamiento de valores, por medio de múltiples elementos de datos.\nLos mapas raster generalmente almacenan fenómenos continuos como elevación, precipitación, temperatura, densidad de población y datos espectrales. También es posible representar mediante raster datos discretos, tales como tipos de suelo o clases de cobertura de la tierra, como se muestra en la Figura 11.3.\n\n\n\n\n\n\n\n\nFigura 11.3: Ejemplos de mapas raster continuos y categóricos. Imagen de Robin Lovelace et al.\n\n\n\n\n\n\n\n11.5.2 El paquete terra\nEl paquete terra implementa un conjunto de funciones para la lectura, escritura, manipulación, análisis y modelado de datos raster y vectoriales. Implementa la clase SpatRaster para manejar los objetos raster.\n\n11.5.2.1 Instalación y carga\n\n# Instalación de terra\ninstall.packages(\"terra\")\n\n\n# Carga de terra\nlibrary(terra)\n\n\n\n11.5.2.2 Métodos\nLa función help() presenta la documentación del paquete terra, incluyendo sus métodos.\n\n# Ayuda sobre el paquete terra\nhelp(\"terra-package\")\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos para manejo de datos raster del paquete terra.\n\n11.5.2.2.1 rast() - lectura de datos\nEl método rast() lee datos raster.\nEn el siguiente bloque de código en R, se utiliza el método rast() para leer un archivo GeoTIFF correspondiente a la altitud de Costa Rica. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.\n\n# Lectura de una capa raster de altitud\naltitud &lt;-\n  rast(\n    \"datos/worldclim/cr/altitud.tif\"\n  )\n\naltitud es un objeto de la clase SpatRaster.\n\n# Clase del objeto altitud\nclass(altitud)\n\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n\n\nAl escribirse el nombre de un objeto SpatRaster en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto altitud\naltitud\n\nclass       : SpatRaster \ndimensions  : 687, 546, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : -87.10189, -82.55189, 5.494651, 11.21965  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : altitud.tif \nname        : altitud \n\n\n\n\n11.5.2.2.2 crs() y project() - manejo de sistemas de coordenadas\nEl método crs() retorna el CRS de un objeto SpatRaster.\n\n# CRS del objeto altitud\ncrs(altitud)\n\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\n\ncrs() también puede asignar un CRS a un objeto SpatRaster.\n\n# Asignación de un CRS a una copia del objeto altitud\naltitud_crtm05 &lt;- altitud\ncrs(altitud_crtm05) &lt;- \"EPSG:5367\"\n\n# Consulta\ncrs(altitud_crtm05)\n\n[1] \"PROJCRS[\\\"CR05 / CRTM05\\\",\\n    BASEGEOGCRS[\\\"CR05\\\",\\n        DATUM[\\\"Costa Rica 2005\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",5365]],\\n    CONVERSION[\\\"Costa Rica TM 2005\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-84,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9999,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"northing (N)\\\",north,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"easting (E)\\\",east,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Cadastre, engineering survey, topographic mapping (large and medium scale).\\\"],\\n        AREA[\\\"Costa Rica - onshore and offshore east of 86°30'W.\\\"],\\n        BBOX[2.21,-86.5,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",5367]]\"\n\n\nEl método project() reproyecta un objeto SpatRaster a un nuevo CRS.\n\n# Transformación del CRS del objeto altitud\naltitud_utm17N &lt;-\n  altitud |&gt;\n  project(\"EPSG:8910\")\n\n# Consulta\ncrs(altitud_utm17N)\n\n[1] \"PROJCRS[\\\"CR-SIRGAS / UTM zone 17N\\\",\\n    BASEGEOGCRS[\\\"CR-SIRGAS\\\",\\n        DATUM[\\\"CR-SIRGAS\\\",\\n            ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",8907]],\\n    CONVERSION[\\\"UTM zone 17N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-81,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Oil and gas exploration and production.\\\"],\\n        AREA[\\\"Costa Rica - offshore - Caribbean sea.\\\"],\\n        BBOX[9.6,-83.6,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",8910]]\"\n\n\n\n\n11.5.2.2.3 plot() - mapeo\nEl método plot() muestra objetos SpatRaster en un mapa.\n\n# Mapa de la capa de altitud\nplot(altitud)\n\n\n\n\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa (raster)\nplot(\n  altitud,\n  main = \"Registros de presencia de félidos en Costa Rica\",\n  axes = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa (vectorial)\nplot(felidos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n11.5.2.2.4 writeRaster() - escritura de datos\nLa función writeRaster() guarda en el disco un objeto SpatRaster en los diferentes formatos raster de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto altitud\naltitud |&gt;\n  writeRaster(\"altitud.asc\")\n\n\n\n11.5.2.2.5 Otros\n\n# Cantidad de filas de un objeto SpatRaster\nnrow(altitud)\n\n[1] 687\n\n# Cantidad de columnas de un objeto SpatRaster\nncol(altitud)\n\n[1] 546\n\n# Resolución de un objeto SpatRaster\nres(altitud)\n\n[1] 0.008333333 0.008333333\n\n\n\n\n\n11.5.2.3 leaflet\nA la fecha de escritura de este documento (2023-05-21), el paquete leaflet no cuenta con soporte para combinar en un mapa objetos sf con objetos SpatRaster, pero sí puede hacerlo con objetos de tipo RasterLayer del paquete raster (antecesor de terra). Por este motivo, se utiliza aquí el método raster() de raster para realizar la conversión de SpatRaster a RasterLayer y así mapear el objeto altitud con el método addRasterImage() de leaflet. Para más información sobre el tema de conversiones entre las diferentes clases espaciales de R, puede consultarse Conversions between different spatial classes in R.\nEntonces, seguidamente se instala y carga el paquete raster.\n\n# Instalación de raster\ninstall.packages(\"raster\")\n\n\n# Carga de raster\nlibrary(raster)\n\nSe muestran en un mapa leaflet las capas de altitud (raster), provincias (polígonos) y registros de presencia de félidos (puntos) sobre una capa base de OpenStreetMap (OSM) y otra de ESRI.\n\n# Paleta de colores de altitud de Costa Rica\ncolores_altitud &lt;-\n  colorNumeric(terrain.colors(25),\n               values(altitud),\n               na.color = \"transparent\")\n\n# Mapa leaflet básico con capas de altitud, provincias y registros de presencia de félidos\nleaflet() %&gt;%\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |&gt;  \n  addTiles(group = \"Mapa general (OpenStreetMap)\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales (ESRI World Imagery)\"\n  ) |&gt;\n  addRasterImage( # capa raster\n    raster(altitud), # conversión de SpatRaster a RasterLayer \n    colors = colores_altitud, # paleta de colores\n    opacity = 0.6,\n    group = \"Altitud\",\n  ) |&gt;\n  addLegend(\n    title = \"Altitud\",\n    values = values(altitud),\n    pal = colores_altitud,\n    position = \"bottomleft\",\n    group = \"Altitud\"\n  ) |&gt;\n  addPolygons(\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n    group = \"Provincias\"\n  ) |&gt;\n  addCircleMarkers(\n    data = felidos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos$institutionCode),\n      paste0(\"&lt;a href='\", felidos$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Félidos\"    \n  ) |&gt;\n  addLayersControl(\n    # control de capas\n    baseGroups = c(\n      \"Mapa general (OpenStreetMap)\", \n      \"Imágenes satelitales (ESRI World Imagery)\"\n    ),\n    overlayGroups = c(\"Altitud\", \"Provincias\", \"Félidos\")\n  ) |&gt;\n  addResetMapButton() |&gt; # botón de reinicio\n  addSearchOSM() |&gt; # búsqueda en OSM\n  addMouseCoordinates() |&gt; # coordenadas del puntero del ratón\n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt; # barra de escala\n  addMiniMap(position = \"bottomright\") |&gt; # mapa de ubicación\n  addFullscreenControl() # mapa de pantalla completa",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#ejercicios-1",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#ejercicios-1",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.6 Ejercicios",
    "text": "11.6 Ejercicios\nEn un documento Quarto incluya:\n\nUna tabla DT con las columnas del conjunto de datos de félidos de Costa Rica correspondientes a especie (species), fecha (eventDate), provincia (stateProvince), localidad (locality), longitud (decimalLongitude) y latitud (decimalLatitude).\n\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).\nLos encabezados de las columnas en la tabla deben desplegarse en español, pero no deben alterarse los nombres de las columnas. Sugerencia: utilice el argumento colnames de la función datatable().\nLos controles de la tabla deben estar en español.\n\nUn gráfico de barras, generado con gglot2 y traducido a plotly con ggplotly(), que muestre la cantidad de registros para cada especie de félidos.\n\nLas barras deben estar ordenadas de mayor a menor.\nTodos los controles y etiquetas del gráfico deben estar en español.\n\nUn mapa leaflet con las siguientes capas:\n\nCapa base de OpenStreetMap (OSM).\nProvincias de Costa Rica (polígonos).\nRegistros de presencia de félidos (puntos).\n\n\nPublique el documento como un sitio web en GitHub Pages.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "11-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "href": "11-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "title": "11  Introducción al manejo de datos geoespaciales con R",
    "section": "11.7 Recursos de interés",
    "text": "11.7 Recursos de interés\nBivand, R. (2022). CRAN Task View: Analysis of Spatial Data. https://CRAN.R-project.org/view=Spatial\nR-Ladies Madrid. (2021). R-Ladies Madrid (español)—Analiza datos espaciales—Stephanie Orellana. https://www.youtube.com/watch?v=59tO2ARvVVU",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "parte-v-ecosistema-espacial-r.html",
    "href": "parte-v-ecosistema-espacial-r.html",
    "title": "V - El ecosistema espacial de R",
    "section": "",
    "text": "11 Introducción al manejo de datos geoespaciales con R\n12 Operaciones con datos de atributos\n13 Operaciones con datos espaciales\n14 Operaciones con geometrías",
    "crumbs": [
      "V - El ecosistema espacial de R"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html",
    "href": "12-operaciones-datos-atributos.html",
    "title": "12  Operaciones con datos de atributos",
    "section": "",
    "text": "12.1 Resumen\nSe les llama atributos a los elementos de datos no espaciales o geométricos de un conjunto de datos geoespaciales. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.\nLas operaciones con atributos en datos vectoriales incluyen creación de subconjuntos, agregación y unión (join). Estas operaciones pueden ejecutarse con funciones del paquete base de R o con las de paquetes de Tidyverse, como dplyr. Por su parte, las operaciones con atributos en datos raster incluyen creación de subconjuntos y resumen de información.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#trabajo-previo",
    "href": "12-operaciones-datos-atributos.html#trabajo-previo",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.2 Trabajo previo",
    "text": "12.2 Trabajo previo\n\n12.2.1 Lecturas\nLovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulo 3). CRC Press. https://geocompr.robinlovelace.net/",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#carga-de-paquetes",
    "href": "12-operaciones-datos-atributos.html#carga-de-paquetes",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.3 Carga de paquetes",
    "text": "12.3 Carga de paquetes\n\n# Carga de paquetes\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(sf)\nlibrary(terra)\nlibrary(leaflet)\nlibrary(leaflet.extras)\nlibrary(leafem)",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#carga-de-datos-para-ejemplos",
    "href": "12-operaciones-datos-atributos.html#carga-de-datos-para-ejemplos",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.4 Carga de datos para ejemplos",
    "text": "12.4 Carga de datos para ejemplos\n\n12.4.1 Cantones de Costa Rica\nEste archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se utiliza una versión del año 2020 (con 82 cantones), debido a que esa es la que corresponde con los datos de COVID-19 que publicó el Ministerio de Salud durante la pandemia.\nArchivo GeoJSON de cantones de Costa Rica (del año 2020)\n\n\nCódigo\n# Carga de datos de cantones de Costa Rica\n# El argumento dsn debe tener la ruta a la fuente de datos\ncantones &lt;-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones_2020.geojson\",\n    quiet = TRUE\n  )\n\n\n\nCódigo\n# Mapa leaflet de cantones\nleaflet() |&gt;\n  setView(\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7\n  ) |&gt;  \n  addTiles() |&gt;\n  addPolygons(\n    data = st_transform(cantones, 4326),\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Código de cantón: &lt;/strong&gt;\", cantones$cod_canton),\n      paste0(\"&lt;strong&gt;Cantón: &lt;/strong&gt;\", cantones$canton),\n      sep = '&lt;br/&gt;'\n    )\n  ) |&gt;\n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt;\n  addFullscreenControl(position = \"topright\")\n# Tabla DT de cantones\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(cod_canton, canton) |&gt;\n  arrange(cod_canton) |&gt;\n  datatable(\n    rownames = FALSE,\n    options = list(\n      dom = 'ft',\n      pageLength = 8,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )    \n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapa y tabla de cantones de Costa Rica\n\n\n\n\n\n12.4.2 Casos positivos de COVID-19 en cantones de Costa Rica\nEstos datos fueron publicados por el Ministerio de Salud de Costa Rica en https://geovision.uned.ac.cr/oges/ (a la fecha de escritura de este documento, el enlace no está funcionando). Se distribuyen en archivos CSV, incluyendo un archivo de datos generales para todo el país y varios archivos con datos por cantón. La fecha de la última actualización es 2022-05-30.\nArchivo CSV de casos positivos de COVID-19 en cantones de Costa Rica\nEl archivo contiene una columna por cada fecha en la que se tomaron datos en el nivel de cantón. Se carga solamente la columna de la última fecha (2022-05-30).\n\n\nCódigo\n# Carga de datos de casos positivos de COVID-19 en cantones de Costa Rica\n# El argumento file debe tener la ruta al archivo de datos\ncovid_positivos_cantones &lt;-\n  read_delim(\n    file = \"datos/ministerio-salud/covid/05_30_22_CSV_POSITIVOS.csv\",\n    delim = \";\",\n    locale = locale(encoding = \"WINDOWS-1252\"), # para desplegar correctamente acentos y otros caracteres\n    col_select = c(\"cod_provin\", \"provincia\", \"cod_canton\", \"canton\", \"30/05/2022\") # 30/05/2022 contiene los datos para la última fecha disponible\n)\n\n# Se remueve la fila con canton == \"Otros\"\ncovid_positivos_cantones &lt;-\n  covid_positivos_cantones |&gt;\n  filter(canton != \"Otros\")\n\n# Cambio de nombre de columnas\ncovid_positivos_cantones &lt;-\n  covid_positivos_cantones %&gt;%\n  rename(positivos_20220530 = '30/05/2022')\n\n\n\nCódigo\n# Tabla DT de casos positivos de COVID-19 en cantones de Costa Rica\ncovid_positivos_cantones |&gt;\n  arrange(cod_canton) |&gt;\n  datatable(\n    rownames = FALSE,\n    options = list(\n      pageLength = 7,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )    \n  )\n\n\n\n\n\n\n\n\n\n\n\n\nTabla de casos positivos de COVID-19 en cantones de Costa Rica",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#introducción",
    "href": "12-operaciones-datos-atributos.html#introducción",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.5 Introducción",
    "text": "12.5 Introducción\nSe les llama atributos a los elementos de datos no espaciales o geométricos de un conjunto de datos geográficos. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#datos-vectoriales",
    "href": "12-operaciones-datos-atributos.html#datos-vectoriales",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.6 Datos vectoriales",
    "text": "12.6 Datos vectoriales\nLas operaciones con atributos en datos vectoriales incluyen:\n\nCreación de subconjuntos (subsetting).\n\nAgregación (aggregation).\n\nUnión (joining).\n\nSeguidamente, se explica como maneja estas operaciones el paquete sf.\n\n12.6.1 Manejo de datos de atributos con el paquete sf\nComo se mencionó en capítulos anteriores, el paquete sf define una clase, llamada sf, la cual extiende la clase data.frame del paquete base de R. Los objetos de la clase sf tienen una fila (o feature) por cada observación y una columna por cada atributo. También tienen una columna especial para almacenar las geometrías (puntos, líneas, polígonos, etc.), la cual generalmente se denomina geometry o geom (pero puede tener cualquier otro nombre). Esto permite que sf utilice métodos (i.e. funciones) de la clase data.frame, tales como plot() y summary(), entre otros.\nAdemás de data.frame, sf es compatible con la clase tibble, la cual también puede manipularse mediante los métodos de dplyr. Esto que permite un manejo tidy (i.e. ordenado, organizado) de los datos geoespaciales, de acuerdo con el enfoque de Tidyverse.\nEn la secciones siguientes, se explicará el manejo de datos de atributos en conjuntos de datos geoespaciales, mediante Tidyverse.\n\n12.6.1.1 El método st_drop_geometry()\nst_drop_geometry() es un método que remueve las geometrías de un objeto sf. Esto puede ser útil cuando se desea operar solamente con las variables no espaciales.\nSecuencia de operaciones que no incluye st_drop_geometry()\n\n\nCódigo\n# Operaciones sin st_drop_geometry()\ncantones |&gt;\n  dplyr::select(canton, area) |&gt;\n  filter(area &gt;= 2000)\n\n\nSimple feature collection with 5 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 405620.8 ymin: 970393.7 xmax: 658879.5 ymax: 1215901\nProjected CRS: CR05 / CRTM05\n        canton    area                       geometry\n1 Buenos Aires 2382.94 MULTIPOLYGON (((574574.2 10...\n2    Talamanca 2792.23 MULTIPOLYGON (((621284.1 10...\n3       Pococí 2408.76 MULTIPOLYGON (((535055.5 12...\n4   San Carlos 3352.31 MULTIPOLYGON (((460739 1215...\n5    Sarapiquí 2144.38 MULTIPOLYGON (((482356.4 11...\n\n\nSecuencia de operaciones que incluye st_drop_geometry()\n\n\nCódigo\n# Operaciones con st_drop_geometry()\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(canton, area) |&gt;\n  filter(area &gt;= 2000)\n\n\n        canton    area\n1 Buenos Aires 2382.94\n2    Talamanca 2792.23\n3       Pococí 2408.76\n4   San Carlos 3352.31\n5    Sarapiquí 2144.38\n\n\nComo puede verse, la columna de geometrías se incluye como resultado de cualquier operación, a menos que se remueva explícitamente.\n\n\n12.6.1.2 Creación de subconjuntos\nFrecuentemente, es necesario extrer subconjuntos del conjunto de datos original, para facilidad de manejo y para atender requerimientos específicos de un análisis.\nEl paquete dplyr permite crear flujos de trabajo intuitivos y rápidos, debido a que se apoya en código escrito en el lenguaje C++. Esto es útil, por ejemplo, cuando se trabaja con conjuntos de datos grandes (big data) y cuando se necesita integración con bases de datos. Los principales métodos de dplyr para creación de subconjuntos son select(), slice() y filter().\n\n12.6.1.2.1 El método select()\nselect() permite seleccionar y renombrar columnas de un conjunto de datos.\nSelección y cambio de nombre de columnas\n\n\nCódigo\n# Selección de columnas canton, area (renombrada a area_km2) y provincia\ncantones |&gt;\n  head(10) |&gt; # para mostrar solo las 10 primeras filas\n  st_drop_geometry() |&gt; # para remover la columna de geometrías\n  dplyr::select(canton, area_km2 = area, provincia)\n\n\n          canton area_km2  provincia\n1     Corredores   623.61 Puntarenas\n2        Golfito  1753.42 Puntarenas\n3      Coto Brus   944.24 Puntarenas\n4            Osa  1932.03 Puntarenas\n5   Buenos Aires  2382.94 Puntarenas\n6  Pérez Zeledón  1901.08   San José\n7         Quepos   557.85 Puntarenas\n8      Talamanca  2792.23      Limón\n9        Parrita   483.22 Puntarenas\n10       Tarrazú   291.27   San José\n\n\n\n\n12.6.1.2.2 El método slice()\nslice() crea un subconjunto con base en las posiciones de las filas.\nSubconjunto especificado mediante un rango de posiciones de filas\n\n\nCódigo\n# Subconjunto de filas entre las posiciones 1 y 10 del conjunto de datos de COVID-19\ncovid_positivos_cantones |&gt;\n  slice(1:10)\n\n\n# A tibble: 10 × 5\n   cod_provin provincia cod_canton canton             positivos_20220530\n        &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt;\n 1          1 San José         112 Acosta                           4104\n 2          1 San José         110 Alajuelita                      18973\n 3          1 San José         106 Aserrí                          10880\n 4          1 San José         118 Curridabat                      14518\n 5          1 San José         103 Desamparados                    43283\n 6          1 San José         117 Dota                              834\n 7          1 San José         102 Escazú                          15134\n 8          1 San José         108 Goicoechea                      25497\n 9          1 San José         120 León Cortés Castro               1339\n10          1 San José         115 Montes de Oca                    9987\n\n\n\n\n12.6.1.2.3 El método filter()\nfilter() filtra filas que cumplen una expresión lógica.\nFiltrado de filas que cumplen una expresión lógica\n\n\nCódigo\n# Filtrado de cantones de la provincia de Heredia\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(provincia, canton) |&gt;\n  filter(provincia == \"Heredia\")\n\n\n   provincia        canton\n1    Heredia Santo Domingo\n2    Heredia         Belén\n3    Heredia     San Pablo\n4    Heredia       Heredia\n5    Heredia        Flores\n6    Heredia    San Rafael\n7    Heredia         Barva\n8    Heredia    San Isidro\n9    Heredia Santa Bárbara\n10   Heredia     Sarapiquí\n\n\n\n\n\n12.6.1.3 Agregación\nLas operaciones de agregación realizan cálculos (ej. sumas, promedios, mínimos, máximos) a partir de la agrupaciones de datos. En Tidyverse y dplyr, las agregaciones de datos se realizan con las funciones group_by() y summarize().\n\n12.6.1.3.1 Las funciones group_by() y summarize()\ngroup_by() crea grupos de filas de un conjunto de datos, de acuerdo con los valores de una o varias columnas. summarize() crea columnas adicionales con cálculos para cada grupo, tales como promedios, sumas, mínimos, máximos y otros. Si summarize() se ejecuta sin group_by(), crea una única fila para todo el conjunto de datos.\nPor ejemplo, en un conjunto de datos de ventas de una cadena de tiendas, se podría usar group_by() para hacer un grupo por cada ciudad en la que una o varias tiendas. Luego con summarize(), se podría crear una columna con el total de ventas para cada ciudad (i.e. para cada grupo).\nAgrupación y sumarización\n\n\nCódigo\n# Suma de áreas de cantones por provincia\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  group_by(provincia) |&gt;\n  summarize(area_km2 = sum(area, na.rm = TRUE))\n\n\n# A tibble: 7 × 2\n  provincia  area_km2\n  &lt;chr&gt;         &lt;dbl&gt;\n1 Alajuela      9772.\n2 Cartago       3093.\n3 Guanacaste   10190.\n4 Heredia       2663.\n5 Limón         9177.\n6 Puntarenas   11299.\n7 San José      4970.\n\n\nCódigo\n# Suma de áreas de cantones para todo el país\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  summarize(area_km2 = sum(area, na.rm = TRUE))\n\n\n  area_km2\n1    51164\n\n\nCódigo\n# Las tres provincias más grandes con sus respectivas áreas y cantidad de cantones\ncantones |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(area, provincia) |&gt;\n  group_by(provincia) %&gt;%\n  summarize(\n    area = sum(area, na.rm = TRUE),\n    cantidad_cantones = n()\n  ) |&gt;\n  arrange(desc(area)) |&gt; # orden descendente por área\n  top_n(n = 3, wt = area) # se separan los primeros 3\n\n\n# A tibble: 3 × 3\n  provincia    area cantidad_cantones\n  &lt;chr&gt;       &lt;dbl&gt;             &lt;int&gt;\n1 Puntarenas 11299.                11\n2 Guanacaste 10190.                11\n3 Alajuela    9772.                16\n\n\nCódigo\n# Suma de casos positivos de COVID-19 por provincia\ncovid_positivos_cantones |&gt;\n  group_by(provincia) |&gt;\n  summarize(positivos_20220530 = sum(positivos_20220530, na.rm = TRUE))\n\n\n# A tibble: 7 × 2\n  provincia  positivos_20220530\n  &lt;chr&gt;                   &lt;dbl&gt;\n1 Alajuela               179754\n2 Cartago                 92933\n3 Guanacaste              61470\n4 Heredia                100766\n5 Limón                   66752\n6 Puntarenas              86938\n7 San José               315969\n\n\n\n\n\n12.6.1.4 Unión (join)\nLa unión (en inglés, join) de datos ubicados en diferentes fuentes (ej. archivos) es una tarea común en análisis de información. Este tipo de operaciones se realizan con base en columnas que son comunes en los conjuntos de datos que se desea unir.\nEl paquete dplyr proporciona varios métodos para realizar uniones de datos, los cuales se ilustran en la Figura 12.1.\n\n\n\n\n\n\n\n\nFigura 12.1: Tipos de uniones (join) de datos. Imagen de hostingplus.\n\n\n\n\n\nLas funciones que los implementan son:\n\nleft_join(): mantiene todas las filas del conjunto de datos del lado izquierdo y les agrega las columnas del conjunto de datos del lado derecho, en las filas en las que hay coincidencia.\ninner_join(): incluye las filas que coinciden en ambos conjuntos de datos.\nright_join(): mantiene todas las filas del conjunto de datos del lado derecho y agrega las columnas del conjunto de datos del lado izquierdo, en las filas en las que hay coincidencia.\nfull_join(): incluye todas las filas de ambos conjuntos de datos.\n\nTodos los tipos de joins requieren de una o varias columnas que sean comunes a ambos conjuntos de datos, llamadas llaves de unión o join keys, en inglés. Esas columnas se especifican con el argumento by. Por ejemplo, by = codigo, si la columna común se llama codigo en ambos conjuntos de datos. Si tienen diferentes nombres, se utiliza un vector (ej. by = c(\"codigo_1\" = \"codigo_2\"), en donde codigo_1 es el nombre de la columna en el conjunto de datos de la izquierda y codigo_2 en el de la derecha. Si hay columnas con nombres iguales en ambos conjuntos de datos, by utiliza esos nombres por defecto.\n\n12.6.1.4.1 Ejemplo: unión de los datos geoespaciales de cantones con los datos tabulares de COVID-19\nSe desea crear un mapa de coropletas de los cantones de Costa Rica, coloreado de acuerdo con la cantidad de casos positivos de COVID-19 acumulados al 2022-05-30. Para esto se necesita unir, a través de un left join, el conjunto de datos cantones (con las geometrías y otros datos de los cantones) con el conjunto de datos de covid_positivos_cantones (con la cantidad de casos positivos para cada cantón). Para ambas tablas, la llave de unión es un campo llamado cod_canton, que contiene el código de cantón asignado por el IGN. Se utiliza un left join porque se desea incluir en la unión todos las filas del conjunto de datos de cantones, ya sea que tengan o no tengan datos de COVID-19 asociados.\nEl siguiente bloque de código realiza el left join y almacena el resultado en un objeto sf llamado cantones_union_covid.\n\n\nCódigo\ncantones_union_covid &lt;-\n  cantones |&gt;\n  left_join(\n    dplyr::select(covid_positivos_cantones, cod_canton, positivos_20220530), # este select() es para no llevar columnas innecesarias a la unión\n    by = \"cod_canton\" # llave para realizar la unión\n  )\n\n\nEl siguiente bloque de código genera el mapa leaflet de coropletas.\n\n\nCódigo\n# Paleta de colores\ncolores_cantones_union_covid &lt;-\n  colorNumeric(\n    palette = \"Reds\",\n    domain = cantones_union_covid$positivos_20220530,\n    na.color = \"transparent\"\n  )\n\n# Mapa leaflet\nleaflet() |&gt;\n  setView(\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |&gt;\n  addTiles(group = \"OSM\") |&gt;\n  addPolygons(\n    data = st_transform(cantones_union_covid, 4326), # se reproyecta a WGS84\n    fillColor = ~ colores_cantones_union_covid(cantones_union_covid$positivos_20220530),\n    fillOpacity = 0.8,\n    color = \"black\",\n    stroke = TRUE,\n    weight = 1.0,\n    popup = paste(\n      paste(\"&lt;strong&gt;Cantón:&lt;/strong&gt;\", cantones_union_covid$canton),\n      paste(\"&lt;strong&gt;Casos positivos al 2022-05-30:&lt;/strong&gt;\", cantones_union_covid$positivos_20220530),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Casos positivos al 2022-05-30\"\n  ) |&gt;\n  addLegend(\n    position = \"bottomleft\",\n    pal = colores_cantones_union_covid,\n    values = cantones_union_covid$positivos_20220530,\n    group = \"Casos positivos al 2022-05-30\",\n    title = \"Cantidad de casos\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\"OSM\"),\n    overlayGroups = c(\"Casos positivos al 2022-05-30\")\n  )\n\n\n\n\n\n\n\n\n\n\n12.6.2 Ejercicios\n\nCree un mapa leaflet de coropletas de las provincias de Costa Rica, coloreado de acuerdo con la cantidad de casos positivos de COVID-19 acumulados al 2022-05-30. Se sugiere seguir los siguientes pasos:\n\n\nCree un data frame con la suma, por provincia, de casos positivos de cantones (para realizar la agrupación, use el código de la provincia, no el nombre).\nCon un left join, una la capa de provincias (del año 2020) y el dataframe que creó en el punto a.\nGenere el mapa leaflet de coropletas con el objeto sf que creó en el punto b.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "12-operaciones-datos-atributos.html#datos-raster",
    "href": "12-operaciones-datos-atributos.html#datos-raster",
    "title": "12  Operaciones con datos de atributos",
    "section": "12.7 Datos raster",
    "text": "12.7 Datos raster\nLas operaciones con atributos en datos raster incluyen:\n\nCreación de subconjuntos (subsetting).\n\nResumen de información (summarizing).\n\nSeguidamente, se explicará como maneja estas operaciones el paquete terra.\n\n12.7.1 Manejo de datos de atributos con el paquete terra\n\n12.7.1.1 Funciones básicas para manejo de objetos SpatRaster\nEl siguiente bloque de código crea y mapea un objeto SpatRaster llamado elevacion.\n\n\nCódigo\n# Creación de un objeto SpatRaster\nelevacion &lt;- rast(\n  nrows = 6,\n  ncols = 6,\n  resolution = 0.5,\n  xmin = -1.5,\n  xmax = 1.5,\n  ymin = -1.5,\n  ymax = 1.5,\n  vals = 1:36\n)\n\n# Mapeo\nplot(elevacion)\n\n\n\n\n\n\n\n\n\nLos objetos SpatRaster también pueden contener valores categóricos de tipo logical o factor. El siguiente bloque de código crea y mapea un objeto SpatRaster con información sobre tipos de granos (i.e. partículas) de una porción de suelo.\n\n\nCódigo\n# Tipos de granos\ngrano_tipo &lt;- c(\"arcilla\", \"limo\", \"arena\")\n\n# Lista de granos generada aleatoriamente\nlista_granos &lt;- sample(grano_tipo, 36, replace = TRUE)\nlista_granos\n\n\n [1] \"limo\"    \"limo\"    \"arcilla\" \"arcilla\" \"limo\"    \"arena\"   \"arcilla\"\n [8] \"arena\"   \"arcilla\" \"arcilla\" \"limo\"    \"arcilla\" \"arena\"   \"arena\"  \n[15] \"arcilla\" \"arena\"   \"limo\"    \"limo\"    \"limo\"    \"limo\"    \"arcilla\"\n[22] \"arcilla\" \"limo\"    \"limo\"    \"limo\"    \"arcilla\" \"arena\"   \"arena\"  \n[29] \"arcilla\" \"arcilla\" \"arena\"   \"arena\"   \"limo\"    \"arcilla\" \"arcilla\"\n[36] \"arena\"  \n\n\nCódigo\n# Factor de tipos de granos\ngrano_factor &lt;- factor(lista_granos, levels = grano_tipo)\n\n# Objeto SpatRaster de tipos de granos\ngrano &lt;- rast(\n  nrows = 6,\n  ncols = 6,\n  resolution = 0.5,\n  xmin = -1.5,\n  xmax = 1.5,\n  ymin = -1.5,\n  ymax = 1.5,\n  vals = grano_factor\n)\n\n# Mapeo\nplot(grano)\n\n\n\n\n\n\n\n\n\nAmbos objetos pueden guardados en el disco con la función writeRaster().\n\n\nCódigo\n# Especificación del directorio de trabajo (debe ser una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura de los objetos raster\nwriteRaster(elevacion, \"elevacion.asc\")\nwriteRaster(grano, \"grano.asc\")\n\n\nLa función levels() puede utilizarse para consultar la Raster Attribute Table (RAT) de un objeto SpatRaster, la cual contiene información sobre sus factores y niveles. También puede emplearse para asignar nuevos factores a un objeto.\n\n\nCódigo\n# Consulta de la RAT\nlevels(grano)\n\n\n[[1]]\n  value   label\n1     1 arcilla\n2     2    limo\n3     3   arena\n\n\nCódigo\n# Nuevo factor\nlevels(grano) = data.frame(value = c(0, 1, 2), wetness = c(\"mojado\", \"húmedo\", \"seco\"))\n\n# Consulta de la RAT\nlevels(grano)\n\n\n[[1]]\n  value wetness\n1     0  mojado\n2     1  húmedo\n3     2    seco\n\n\nLos raster categóricos también pueden almacenar información relacionada con los colores de cada valor, mediante una tabla. La tabla de colores es un data frame con tres (red, green, blue) o cuatro (alpha) columnas, en la que cada fila corresponde a un valor. Las tablas de colores en terra pueden consultarse o modificarse con la función coltab().\n\n\n12.7.1.2 Creación de subconjuntos\nLos subconjuntos se crean en objetos SpatRaster con el operador [, el cual acepta varios tipos de entradas.\n\nÍndices de filas y columnas.\nID de celdas.\nCoordenadas.\nOtros objetos espaciales.\n\nEn este capítulo, solo se tratarán las dos primeras opciones. Las restantes se cubrirán en las secciones sobre operaciones espaciales.\nLas dos primeras opciones se ilustran en el siguiente bloque de código, en el que se consulta la celda (también llamada pixel) ubicada en la esquina superior izquierda del objeto de elevación.\n\n\nCódigo\n# Celda en la fila 1, columna 1\nelevacion[1, 1]\n\n\n  lyr.1\n1     1\n\n\nCódigo\nelevacion[]\n\n\n      lyr.1\n [1,]     1\n [2,]     2\n [3,]     3\n [4,]     4\n [5,]     5\n [6,]     6\n [7,]     7\n [8,]     8\n [9,]     9\n[10,]    10\n[11,]    11\n[12,]    12\n[13,]    13\n[14,]    14\n[15,]    15\n[16,]    16\n[17,]    17\n[18,]    18\n[19,]    19\n[20,]    20\n[21,]    21\n[22,]    22\n[23,]    23\n[24,]    24\n[25,]    25\n[26,]    26\n[27,]    27\n[28,]    28\n[29,]    29\n[30,]    30\n[31,]    31\n[32,]    32\n[33,]    33\n[34,]    34\n[35,]    35\n[36,]    36\n\n\nCódigo\n# Celda con ID = 1\nelevacion[1]\n\n\n  lyr.1\n1     1\n\n\nLa totalidad de los valores de un objeto SpatRaster puede consultarse con las función values().\n\n\nCódigo\n# Valores de un objeto raster\nvalues(elevacion)\n\n\n      lyr.1\n [1,]     1\n [2,]     2\n [3,]     3\n [4,]     4\n [5,]     5\n [6,]     6\n [7,]     7\n [8,]     8\n [9,]     9\n[10,]    10\n[11,]    11\n[12,]    12\n[13,]    13\n[14,]    14\n[15,]    15\n[16,]    16\n[17,]    17\n[18,]    18\n[19,]    19\n[20,]    20\n[21,]    21\n[22,]    22\n[23,]    23\n[24,]    24\n[25,]    25\n[26,]    26\n[27,]    27\n[28,]    28\n[29,]    29\n[30,]    30\n[31,]    31\n[32,]    32\n[33,]    33\n[34,]    34\n[35,]    35\n[36,]    36\n\n\nEl operador [ también puede utilizarse para modificar los valores de las celdas un objeto SpatRaster.\n\n\nCódigo\n# Modificación de una celda\nelevacion[1, 1] = 0\n\n# Consulta de todos los valores del raster (equivalente a values())\nelevacion[]\n\n\n      lyr.1\n [1,]     0\n [2,]     2\n [3,]     3\n [4,]     4\n [5,]     5\n [6,]     6\n [7,]     7\n [8,]     8\n [9,]     9\n[10,]    10\n[11,]    11\n[12,]    12\n[13,]    13\n[14,]    14\n[15,]    15\n[16,]    16\n[17,]    17\n[18,]    18\n[19,]    19\n[20,]    20\n[21,]    21\n[22,]    22\n[23,]    23\n[24,]    24\n[25,]    25\n[26,]    26\n[27,]    27\n[28,]    28\n[29,]    29\n[30,]    30\n[31,]    31\n[32,]    32\n[33,]    33\n[34,]    34\n[35,]    35\n[36,]    36\n\n\nCódigo\n# Modificación de rangos de celdas\nelevacion[1, c(1, 2)] = 0\n\nelevacion[1, 1:6] = 0\nelevacion[2, 1:6] = 10\nelevacion[3, 1:6] = 15\nelevacion[4, 1:6] = 15\nelevacion[5, 1:6] = 20\nelevacion[6, 1:6] = 35\n\n# Consulta de los valores\nelevacion[]\n\n\n      lyr.1\n [1,]     0\n [2,]     0\n [3,]     0\n [4,]     0\n [5,]     0\n [6,]     0\n [7,]    10\n [8,]    10\n [9,]    10\n[10,]    10\n[11,]    10\n[12,]    10\n[13,]    15\n[14,]    15\n[15,]    15\n[16,]    15\n[17,]    15\n[18,]    15\n[19,]    15\n[20,]    15\n[21,]    15\n[22,]    15\n[23,]    15\n[24,]    15\n[25,]    20\n[26,]    20\n[27,]    20\n[28,]    20\n[29,]    20\n[30,]    20\n[31,]    35\n[32,]    35\n[33,]    35\n[34,]    35\n[35,]    35\n[36,]    35\n\n\n\n\n12.7.1.3 Resumen y sumarización de información\nLa escritura del nombre de un objeto SpatRaster en la consola imprime información general sobre ese objeto. La función summary() proporciona algunas estadísticas descriptivas (mínimo, máximo, cuartiles, etc.). Otras estadísticas pueden ser calculadas con la función global().\n\n\nCódigo\n# Información general\nelevacion\n\n\nclass       : SpatRaster \ndimensions  : 6, 6, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 \nsource(s)   : memory\nname        : lyr.1 \nmin value   :     0 \nmax value   :    35 \n\n\nCódigo\n# Resumen de un raster de una capa\nsummary(elevacion)\n\n\n     lyr.1      \n Min.   : 0.00  \n 1st Qu.:10.00  \n Median :15.00  \n Mean   :15.83  \n 3rd Qu.:20.00  \n Max.   :35.00  \n\n\nCódigo\n# Desviación estándar\nglobal(elevacion, sd)\n\n\n            sd\nlyr.1 10.72381\n\n\nAdicionalmente, la función freq() retorna la tabla de frecuencias de valores categóricos.\n\n\nCódigo\n# Tabla de frecuencias\nfreq(grano)\n\n\n  layer  value count\n1     1 húmedo    14\n2     1   seco    12\n3     1   &lt;NA&gt;    10\n\n\nLas estadísticas pueden ser visualizadas con funciones como hist() y density().\n\n\nCódigo\n# Histograma\nhist(elevacion)\n\n\n\n\n\n\n\n\n\nCódigo\n# Densidad\ndensity(elevacion)",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Operaciones con datos de atributos</span>"
    ]
  },
  {
    "objectID": "13-operaciones-datos-espaciales.html",
    "href": "13-operaciones-datos-espaciales.html",
    "title": "13  Operaciones con datos espaciales",
    "section": "",
    "text": "13.1 Resumen\nLas operaciones espaciales, tales como las basadas en relaciones topológicas (ej. intersección, traslape, contención, cobertura), en el caso de los datos vectoriales, y el álgebra de mapas, en el caso de los datos raster, constituyen un componente esencial del procesamiento de datos geoespaciales. Varias de las operaciones con datos de atributos estudiadas en el capítulo anterior tienen contrapartes espaciales.\nLas operaciones espaciales para datos vectoriales incluyen creación de subconjuntos espaciales, unión de datos espaciales, agregación de datos espaciales y relaciones de distancia, entre otras. Por su parte, las operaciones espaciales para datos raster incluyen creación de subconjuntos espaciales y álgebra de mapas, entre otras.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operaciones con datos espaciales</span>"
    ]
  },
  {
    "objectID": "13-operaciones-datos-espaciales.html#trabajo-previo",
    "href": "13-operaciones-datos-espaciales.html#trabajo-previo",
    "title": "13  Operaciones con datos espaciales",
    "section": "13.2 Trabajo previo",
    "text": "13.2 Trabajo previo\n\n13.2.1 Lecturas\nLovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulo 4). CRC Press. https://geocompr.robinlovelace.net/\n\n\n13.2.2 Carga de paquetes\n\n# Carga de paquetes\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(sf)\nlibrary(terra)\nlibrary(leaflet)\nlibrary(leaflet.extras)\nlibrary(leafem)\nlibrary(viridisLite)\n\n\n\n13.2.3 Conjuntos de datos para ejemplos\n\n13.2.3.1 Carga de datos\n\n13.2.3.1.1 Cantones de Costa Rica\nEste archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se utiliza una versión del año 2020 (con 82 cantones). Las geometrías se simplificaron con el método st_simplify(), para reducir el tamaño del archivo.\n\n\nCódigo para simplificar las geometrías de cantones (no es necesario ejecutarlo)\n# Simplificación de geometrías de la capa de cantones de Costa Rica\nst_read(\n  dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones_2020.geojson\",\n  quiet = TRUE\n) |&gt;\nst_simplify(dTolerance = 10, preserveTopology = TRUE) |&gt;\nst_write(\"datos/ign/delimitacion-territorial-administrativa/cantones_2020_simp_10m.geojson\")\n\n\nArchivo GeoJSON de cantones de Costa Rica (del año 2020) con geometrías simplificadas\n\n\nCódigo para cargar los datos de cantones\n# Carga de datos de cantones de Costa Rica\n# El argumento dsn debe tener la ruta a la fuente de datos\ncantones &lt;-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones_2020_simp_10m.geojson\",\n    quiet = TRUE\n  ) |&gt;\n  st_transform(4326) # reproyección a WGS84\n\n\n\n\n13.2.3.1.2 Registros de presencia de félidos de Costa Rica\nEste archivo, con registros de presencia de especies silvestres de la familia Felidae en Costa Rica, proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\nArchivo CSV de registros de presencia de félidos silvestres de Costa Rica)\n\n\nCódigo para cargar los datos de félidos\n# Carga de datos de félidos de Costa Rica\nfelidos &lt;-\n  st_read(\n    \"datos/gbif/felidos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\n# Asignación del CRS WGS84\nst_crs(felidos) &lt;- 4326\n\n\n\n\n\n13.2.3.2 Visualización\n\nCódigo para generar el mapa leaflet de cantones y registros de presencia de félidos\n# Factor de color basado en los valores únicos de especies\ncolores_especies &lt;- colorFactor(\n  palette = viridis(length(unique(felidos$species))), \n  domain = felidos$species\n)\n\n# Mapa leaflet de cantones y registros de presencia de félidos\nleaflet() |&gt;\n  setView(\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7\n  ) |&gt;  \n  addTiles(group = \"Mapa general (OpenStreetMap)\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales (ESRI World Imagery)\"\n  ) |&gt;  \n  addPolygons(\n    data = cantones,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.5,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Código del cantón: &lt;/strong&gt;\", cantones$cod_canton),\n      paste0(\"&lt;strong&gt;Cantón: &lt;/strong&gt;\", cantones$canton),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Cantones\"\n  ) |&gt;  \n  addCircleMarkers(\n    data = felidos,\n    stroke = F,\n    radius = 4,\n    fillColor = ~colores_especies(felidos$species),\n    fillOpacity = 1.0,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos$institutionCode),\n      paste0(\"&lt;a href='\", felidos$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),    \n    group = \"Félidos\"\n  ) |&gt;\n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt;  \n  addLegend(\n    position = \"bottomleft\",    \n    pal = colores_especies,\n    values = felidos$species,\n    title = \"Especies de félidos\",\n    group = \"Félidos\"    \n  ) |&gt;  \n  addLayersControl(\n    baseGroups = c(\n      \"Mapa general (OpenStreetMap)\", \n      \"Imágenes satelitales (ESRI World Imagery)\"\n    ),\n    overlayGroups = c(\"Cantones\", \"Félidos\")\n  ) |&gt;\n  addResetMapButton() |&gt;\n  addSearchOSM() |&gt;\n  addMouseCoordinates() |&gt;\n  addMiniMap(position = \"bottomright\") |&gt;\n  addFullscreenControl()\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de cantones y registros de presencia de félidos de Costa Rica",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operaciones con datos espaciales</span>"
    ]
  },
  {
    "objectID": "13-operaciones-datos-espaciales.html#introducción",
    "href": "13-operaciones-datos-espaciales.html#introducción",
    "title": "13  Operaciones con datos espaciales",
    "section": "13.3 Introducción",
    "text": "13.3 Introducción\nEste capítulo brinda una visión general de las operaciones espaciales para datos vectoriales implementadas en el paquete sf, y para datos raster implementadas en el paquete terra.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operaciones con datos espaciales</span>"
    ]
  },
  {
    "objectID": "13-operaciones-datos-espaciales.html#datos-vectoriales",
    "href": "13-operaciones-datos-espaciales.html#datos-vectoriales",
    "title": "13  Operaciones con datos espaciales",
    "section": "13.4 Datos vectoriales",
    "text": "13.4 Datos vectoriales\nLas operaciones espaciales para datos vectoriales incluyen:\n\nCreación de subconjuntos espaciales (spatial subsetting).\nUnión de datos espaciales (spatial joining).\nAgregación de datos espaciales (spatial aggregation).\nRelaciones de distancia.\n\nSeguidamente, se explica como maneja estas operaciones el paquete sf. Antes, se cubre el tema de las relaciones topológicas, el cual es importante en varias operaciones espaciales.\n\n13.4.1 Relaciones topológicas\nLas relaciones topológicas o relaciones topológicas binarias son expresiones lógicas (verdaderas o falsas) sobre las relaciones espaciales entre dos objetos. Por ejemplo, si a y b son dos objetos espaciales (ej. puntos, líneas, polígonos), se pueden considerar relaciones topológicas como las siguientes:\na interseca a b\na es adyacente a b\na está dentro de b\nb está contenido en a\nLos diferentes tipos de relaciones topológicas están estandarizados en el modelo DE-9IM (Dimensionally Extended 9-Intersection Model) y se ilustran en la Figura 13.1. Esta figura muestra también los métodos del paquete sf que implementan las relaciones topológicas (ej. st_intersects(), st_overlaps(), st_winthin(), st_contains()).\n\n\n\n\n\n\n\n\nFigura 13.1: Relaciones topológicas entre geometrías vectoriales. Imagen de Robin Lovelace et al., basada en Egenhofer and Herring (1990).\n\n\n\n\n\nNótese que para algunas relaciones topológicas (ej. intersección, traslape), el orden no es importante, mientras que para otras sí lo es (ej. contención).\nA las relaciones topológicas se les conoce también como predicados espaciales y así se les denomina en la documentación de sf.\n\n\n13.4.2 Manejo de datos espaciales con el paquete sf\n\n13.4.2.1 Creación de subconjuntos espaciales\nLa creación de subconjuntos espaciales consiste en retornar objetos espaciales que cumplen con algún predicado espacial. Es análoga a la creación de subconjuntos por datos de atributos. Puede realizarse a través de los operadores [ y $ del paquete base de R o por medio de la función filter() de dplyr. Esta última opción es la que se usa en los siguiente ejemplos.\nEn este caso, la función filter() usa tres argumentos: x, y y .predicate, en donde x e y son dos conjuntos de datos espaciales y .predicate el predicado espacial que los relaciona.\n\n13.4.2.1.1 Ejemplo: registros de presencia de félidos en el cantón de Sarapiquí y sus alrededores\nEl siguiente bloque de código crea dos subconjuntos espaciales del conjunto de registros de presencia de félidos, al relacionarlo con el polígono del cantón de Sarapiquí mediante los predicados espaciales st_within() y st_is_within_distance().\n\n\nCódigo\n# Polígono del cantón de Sarapiquí\nsarapiqui &lt;- filter(cantones, canton == \"Sarapiquí\")\n\n# Puntos de félidos ubicados dentro del cantón de Sarapiquí\nfelidos_dentro_sarapiqui &lt;-\n  st_filter(\n    x = felidos,\n    y = sarapiqui, \n    .predicate = st_within\n  )\n\n# Puntos de félidos ubicados dentro de una distancia\n# de hasta 10 km del cantón de Sarapiquí\nfelidos_10km_sarapiqui &lt;- st_filter(\n  x = felidos, \n  y = sarapiqui, \n  .predicate = function(a, b) st_is_within_distance(a, b, 10000)\n)\n\n\nLos subconjuntos espaciales creados se despliegan en los mapas que se muestran seguidamente.\n\nCódigo\n# Mapa leaflet\nleaflet() |&gt;\n  addTiles() |&gt;\n  addPolygons(\n    data = sarapiqui,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 2.0\n  ) |&gt;\n  addCircleMarkers(\n    data = felidos_dentro_sarapiqui,\n    stroke = F,\n    radius = 4,\n    fillColor = \"blue\",\n    fillOpacity = 1.0,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos_dentro_sarapiqui$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos_dentro_sarapiqui$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos_dentro_sarapiqui$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos_dentro_sarapiqui$institutionCode),\n      paste0(\"&lt;a href='\", felidos$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),    \n    group = \"Félidos\"\n  ) |&gt;  \n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt;\n  addFullscreenControl(position = \"topright\")\n# Mapa leaflet\nleaflet() |&gt;\n  addTiles() |&gt;\n  addPolygons(\n    data = sarapiqui,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 2.0\n  ) |&gt;\n  addCircleMarkers(\n    data = felidos_10km_sarapiqui,\n    stroke = F,\n    radius = 4,\n    fillColor = \"blue\",\n    fillOpacity = 1.0,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos_10km_sarapiqui$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos_10km_sarapiqui$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos_10km_sarapiqui$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos_10km_sarapiqui$institutionCode),\n      paste0(\"&lt;a href='\", felidos_10km_sarapiqui$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),    \n    group = \"Félidos\"\n  ) |&gt;  \n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt;\n  addFullscreenControl(position = \"topright\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de registros de presencia de félidos localizados dentro del cantón de Sarapiquí.\n\n\nMapa de registros de presencia de félidos localizados dentro de una distancia de hasta 10 km del cantón de Sarapiquí.\n\n\n\n\n\n\n13.4.2.2 Unión (join) de datos espaciales\nComo se estudió en el capítulo sobre operaciones de datos de atributos, la unión (join) “no espacial” de dos conjuntos de datos se basa en una o varias columnas (llamadas llaves o keys) que están presentes en ambos conjuntos. Las uniones espaciales se basan en un principio similar pero, en lugar de columnas, la relación entre los conjuntos se realiza a través de un predicado espacial.\nEn sf, la unión de datos espaciales se implementa a través de la función st_join(), la cual tiene tres argumentos principales: x, y y join, en donde x e y son dos conjuntos de datos espaciales y join un predicado espacial que, por defecto, es st_intersects. st_join() agrega una o varias columnas a x, provenientes de y, para las filas que satisfacen el predicado.\n\n13.4.2.2.1 Ejemplo: riqueza de especies de félidos en los cantones de Costa Rica\nLos siguientes bloques de código calculan la riqueza de especies de félidos en los cantones de Costa Rica, esto es, la cantidad de especies en cada cantón.\nEl proceso se divide en los siguientes pasos:\n\nUnión espacial de félidos y cantones (esto le agrega a cada registros de félidos el código de cantón correspondiente a su ubicación).\nConteo de la cantidad de especies de félidos en cada cantón (por código de cantón).\nUnión no espacial de cantones con el dataframe con el conteo de especies en cantones (esto le agrega a cada cantón la cantidad de especies de félidos).\nGeneración del mapa de riqueza de especies.\n\n1. Unión espacial de félidos y cantones\nCon st_join(), al conjunto de registros de presencia de félidos, se le agrega la columna cod_canton del conjunto de cantones, mediante el predicado espacial st_within().\n\n\nCódigo\n# Unión espacial de félidos y cantones (solo la columna cod_canton),\n# mediante el predicado st_within().\n# Como resultado, cod_canton se une al conjunto de datos de félidos.\nfelidos_union_cantones &lt;- \n  st_join(\n    x = felidos,\n    y = dplyr::select(cantones, cod_canton), # selección de columna cod_canton\n    join = st_within\n  )\n\n# Despliegue de los datos unidos de félidos y la columna cod_canton de cantones\nfelidos_union_cantones |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(species, locality, cod_canton) |&gt;\n  datatable(\n    colnames = c(\"Especie\", \"Localidad\", \"Código de cantón\"),\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\n2. Conteo de la cantidad de especies de félidos en cada cantón\nSe realiza una agrupación por código de cantón con group_by(cod_canton) y se crea la columna riqueza_especies_felidos con summarize(riqueza_especies_felidos = n_distinct(species, na.rm = TRUE)). La función n_distinct() cuenta la cantidad de valores diferentes de una columna; en este caso, la cantidad de especies en cada cantón.\n\n\nCódigo\n# Conteo de la cantidad de especies de félidos en cantones\nriqueza_especies_felidos_cantones &lt;-\n  felidos_union_cantones |&gt;\n  st_drop_geometry() |&gt;\n  group_by(cod_canton) |&gt;\n  summarize(riqueza_especies_felidos = n_distinct(species, na.rm = TRUE))\n\n# Despliegue de la cantidad de especies de félidos en cada cantón\nriqueza_especies_felidos_cantones |&gt;\n  arrange(desc(riqueza_especies_felidos)) |&gt;\n  datatable(\n    colnames = c(\"Código de cantón\", \"Riqueza de especies de félidos\"),\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\nNótese que hay registros que no están dentro del polígono de ningún cantón y tienen un valor NA en cod_canton. Esto puede deberse a errores de georreferenciación o a políticas de los publicadores de datos para no revelar la ubicación exacta de especies amenazadas.\n3. Unión no espacial de cantones con el dataframe de riqueza de especies en cantones\nCon left_join(), al conjunto de datos de cantones (incluyendo sus geometrías), se le agrega la columna riqueza_especies_felidos, con el conteo de especies por cantón. La función replace_na() se utiliza para reemplazar con 0 los registros de riqueza_especies_felidos que contienen NA.\n\n\nCódigo\n# Unión (no espacial) de cantones y riqueza de especies\ncantones_union_riqueza &lt;-\n  left_join(\n    x = cantones,\n    y = dplyr::select(riqueza_especies_felidos_cantones, cod_canton, riqueza_especies_felidos),\n    by = \"cod_canton\"\n  ) |&gt;\n  replace_na(list(riqueza_especies_felidos = 0))\n\n# Despliegue de los datos de riqueza de especies en cantones\ncantones_union_riqueza |&gt;\n  st_drop_geometry() |&gt;\n  dplyr::select(canton, riqueza_especies_felidos) |&gt;\n  arrange(desc(riqueza_especies_felidos)) |&gt;\n  datatable(\n    colnames = c(\"Cantón\", \"Riqueza de especies de félidos\"),\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\n\n4. Generación del mapa de riqueza de especies\nCon las geometrías de cantones y la riqueza de especies en el mismo conjunto de datos, puede generarse un mapa de coropletas.\n\nCódigo\n# Paleta de colores de riqueza de especies\ncolores_riqueza_especies &lt;-\n  colorNumeric(\n    palette = \"Reds\",\n    domain = cantones_union_riqueza$riqueza_especies_felidos,\n    na.color = \"transparent\"\n  )\n\n# Paleta de colores de especies\ncolores_especies &lt;- colorFactor(\n  palette = viridis(length(unique(felidos$species))), \n  domain = felidos$species\n)\n\n# Mapa leaflet\nleaflet() |&gt;\n  setView(\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |&gt;\n  addTiles(group = \"Mapa general (OpenStreetMap)\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales (ESRI World Imagery)\"\n  ) |&gt; \n  addPolygons(\n    data = cantones_union_riqueza,\n    fillColor = ~ colores_riqueza_especies(cantones_union_riqueza$riqueza_especies_felidos),\n    fillOpacity = 0.8,\n    color = \"black\",\n    stroke = TRUE,\n    weight = 1.0,\n    popup = paste(\n      paste(\"&lt;strong&gt;Cantón:&lt;/strong&gt;\", cantones_union_riqueza$canton),\n      paste(\"&lt;strong&gt;Riqueza de especies:&lt;/strong&gt;\", cantones_union_riqueza$riqueza_especies_felidos),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Riqueza de especies\"\n  ) |&gt;\n  addScaleBar(\n    position = \"bottomleft\", \n    options = scaleBarOptions(imperial = FALSE)\n  ) |&gt;    \n  addLegend(\n    position = \"bottomleft\",\n    pal = colores_riqueza_especies,\n    values = cantones_union_riqueza$riqueza_especies_felidos,\n    group = \"Riqueza de especies\",\n    title = \"Riqueza de especies\"\n  ) |&gt;\n  addCircleMarkers(\n    data = felidos,\n    stroke = F,\n    radius = 4,\n    fillColor = ~colores_especies(felidos$species),\n    fillOpacity = 1.0,\n    popup = paste(\n      paste0(\"&lt;strong&gt;Especie: &lt;/strong&gt;\", felidos$species),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", felidos$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", felidos$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", felidos$institutionCode),\n      paste0(\"&lt;a href='\", felidos$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),    \n    group = \"Registros de presencia\"\n  ) |&gt;  \n  addLegend(\n    position = \"bottomright\",    \n    pal = colores_especies,\n    values = felidos$species,\n    title = \"Especies\",\n    group = \"Registros de presencia\"    \n  ) |&gt;  \n  addLayersControl(\n    baseGroups = c(\n      \"Mapa general (OpenStreetMap)\", \n      \"Imágenes satelitales (ESRI World Imagery)\"\n    ),\n    overlayGroups = c(\n      \"Riqueza de especies\",\n      \"Registros de presencia\"\n    )\n  ) |&gt;\n  addResetMapButton() |&gt;\n  addSearchOSM() |&gt;\n  addMouseCoordinates() |&gt;\n  addFullscreenControl() |&gt;\n  hideGroup(\"Registros de presencia\") \n\n\n\n\n\n\n\n\n\n\n\n\nMapa de riqueza de especies de félidos en cantones de Costa Rica\n\n\n\n\n\n\n\n13.4.3 Ejercicios\n\nElabore un mapa de riqueza de especies de vipéridos en las provincias de Costa Rica. Impleméntelo como un mapa de coropletas en Leaflet.\n\nUtilice las siguientes fuentes de datos:\n\nArchivo GeoJSON de provincias de Costa Rica con geometrías simplificadas\nArchivo CSV de registros de presencia de vipéridos de Costa Rica",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operaciones con datos espaciales</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#introducción",
    "href": "10-ggplot2-plotly.html#introducción",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.5 Introducción",
    "text": "10.5 Introducción\nSe introducen los paquetes de graficación estadística ggplot2 y plotly. Se utiliza ggplot2 para elaborar los gráficos y plotly para hacerlos interactivos.\n\n10.5.1 ggplot2\nggplot2 es un sistema para la creación declarativa de gráficos, creado por Hadley Wickham en 2005. Está basado en el libro The Grammar of Graphics, de Leland Wilkinson, un esquema general para visualización de datos que descompone un gráfico en sus principales componentes semánticos, tales como capas y geometrías.\n\n10.5.1.1 Principales componentes de un gráfico\nDe acuerdo con The Grammar of Graphics, los tres principales componentes de un gráfico son:\n\nDatos (observaciones y variables).\nConjunto de mapeos de las variables del conjunto de datos a propiedades visuales (aesthetics) del gráfico, tales como posición en el eje x, posición en el eje y, color, tamaño y forma, entre otras.\nAl menos una capa, la cual describe como graficar cada observación. Por lo general, las capas se crean con funciones de geometrías (ej. puntos, líneas, barras).\n\n\n\n10.5.1.2 Opciones básicas\nggplot2 implementa un gráfico estadístico por medio de la función ggplot(), cuya sintaxis básica puede resumirse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n    &lt;FUNCION_GEOMETRIA&gt;(mapping = aes(&lt;MAPEOS&gt;))\nEl llamado a ggplot() crea un sistema de coordenadas (i.e. un “canvas”), al cual se le agregan capas. Su primer argumento es &lt;DATOS&gt;, el cual es usualmente un dataframe o un tibble.\nLa función aes() realiza los mapeos (&lt;MAPEOS&gt;) de las variables del conjunto de datos a las propiedades visuales del gráfico. Las capas se crean con funciones de geometrías (&lt;FUNCION_GEOMETRIA&gt;) como geom_point(), geom_bar() o geom_histogram(), entre muchas otras. Note el uso del operador + para agregar las capas al gráfico.\nComo ejemplo, seguidamente se crea un gráfico de dispersión que muestra la variable engine displacement o cilindrada (displ) en el eje X, y la variable highway miles per gallon o millas por galón en autopista (hwy) en el eje Y.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\nEl bloque de código anterior puede reescribirse mediante un pipe, para pasar el conjunto de datos a ggplot(). También puede llamarse a aes() como un argumento de ggplot() y no de la función de geometría. Esto último acostumbra hacerse cuando los mapeos de las variables a las propiedades estéticas son los mismos en todas las capas del gráfico.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point()\n\n\n\n\n\n\n\n\nEl gráfico muestra una relación negativa entre el tamaño del motor (displ) y la eficiencia en el uso del combustible (hwy). En otras palabras, los vehículos con motores grandes usan más combustible.\n\n\n10.5.1.3 Variables adicionales\nSe pueden incluir variables adicionales en el gráfico mediante su mapeo a otras propiedades visuales. En el siguiente bloque de código, la variable correspondiente al tipo de automóvil (class), se mapea a la propiedad color.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de automóvil\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa misma variable puede mapearse a la propiedad visual shape (forma).\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# con formas de puntos correspondientes al tipo de automóvil\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa categoría de los SUV no se incluye en el gráfico debido a que ggplot() solo muestra, por defecto, seis formas diferentes cuando se asignan de manera automática. Esto puede solucionarse si se asigna explícitamente una forma a cada categoría. En el siguiente bloque de código, se asignan manualmente tanto formas como colores a cada categoría de vehículo, mediante las funciones scale_shape_manual() y scale_color_manual().\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# con formas y colores correspondientes al tipo de automóvil\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, shape = class, color = class)) +\n  geom_point() +\n  scale_shape_manual(values = c(0, 1, 2, 3, 4, 5, 6)) +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\", \"pink\"))\n\n\n\n\n\n\n\n\nEl siguiente bloque de código mapea la variable de la cilindrada con la propiedad visual tamaño (size) y compara el rendimiento en autopista de los automóviles con el rendimiento en ciudad.\n\n# Gráfico de dispersión de rendimiento en autopista vs rendimiento en ciudad\n# con tamaño de puntos correspondiente a la cilindrada\nmpg |&gt;\n  ggplot(aes(x = hwy, y = cty, size = displ)) +\n  geom_point()\n\n\n\n\n\n\n\n\nEl gráfico muestra que, ya sea en autopista o en ciudad, los motores con mayor cilindrada requieren de más combustible que los motores de menor cilindrada.\n\n\n10.5.1.4 Capas adicionales\nUn mismo gráfico puede contener múltiples capas, cada una con su propia función de geometría. El siguiente bloque de código agrega una capa con la función geom_smooth(), la cual muestra una curva de tendencia.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + curva de tendencia\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\n\n\n\nEn el siguiente ejemplo, se mapea la variable tipo de tracción (drv) a la propiedad visual del color, tanto para la capa de puntos como para la de la curva de tendencia.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción\n# + curva de tendencia\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\n10.5.1.5 Paneles\nComo se mostró anteriormente, una forma de mostrar variables adicionales en un gráfico es mediante propiedades visuales (color, forma, tamaño, etc.). Otra forma es mediante el uso de paneles (facets), los cuales dividen un gráfico en subgráficos, de acuerdo con los valores de una variable. Este método es particularmente apropiado cuando la variable adicional es categórica.\nLa función facet_wrap() divide un gráfico en paneles de acuerdo con una sola variable. El primer argumento es una fórmula, la cual se crea con el caracter ~ (tilde) seguido por el nombre de la variable.\nEn el siguiente bloque de código, se generan paneles para el gráfico de dispersión de cilindrada vs millas por galón en autopista, de acuerdo con el tipo de automóvil. Es decir, un panel (subgráfico) por cada tipo de automóvil.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + paneles por tipo de automóvil\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_wrap(~ class, nrow = 2)\n\n\n\n\n\n\n\n\nLa función facet_grid() genera paneles con la combinación de dos variables. El primer argumento es también una fórmula, la cual contiene dos variables separadas por ~.\nEn el siguiente bloque de código, se generan paneles para el gráfico de dispersión de cilindrada vs millas por galón en autopista, de acuerdo con el tipo de automóvil y el tipo de tracción.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + paneles por tipo de automóvil y tipo de tracción\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_grid(class ~ drv)\n\n\n\n\n\n\n\n\n\n\n10.5.1.6 Títulos, etiquetas, estilos y colores\n\n10.5.1.6.1 Titulos, subtítulos y etiquetas\nggplot2 incluye las funciones ggtitle(), xlab(), ylab() y labs(), las cuales permiten agregar títulos, subtítulos, etiquetas en los ejes y de otros tipos a un gráfico.\nAlgunas de las opciones que ofrecen estas funciones se ilustran en el siguiente gráfico.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo y etiquetas\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista por tipo de tracción\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\")\n\n\n\n\n\n\n\n\nEl títulos y las etiquetas de los ejes se pueden agregar también mediante argumentos de labs().\n\n\n10.5.1.6.2 Estilos\nggplot2 incluye un conjunto de estilos (themes) que pueden ayudar a mejorar el aspecto visual de los gráficos.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y estilo\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_bw() # tema de ggplot2\n\n\n\n\n\n\n\n\nExisten paquetes que ofrecen estilos adicionales como, por ejemplo, ggthemes.\n\n# Instalación de ggthemes\ninstall.packages(\"ggthemes\")\n\n\n# Carga de ggthemes\nlibrary(ggthemes)\n\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y estilo de ggthemes\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_economist() # estilo de ggthemes\n\n\n\n\n\n\n\n\nOtro paquete de estilos y recursos relacionados (escalas de colores, fuentes, etc.) es hrbrthemes.\n\n# Instalación de hbrthemes\ninstall.packages(\"hrbrthemes\")\n\n\n# Carga de hbrthemes\nlibrary(hrbrthemes)\n\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y estilo de hbrthemes\nmpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_ipsum() # tema de hrbrthemes\n\n\n\n\n\n\n\n\n\n\n10.5.1.6.3 Colores\nggplot2 incluye múltiples funciones para escalas de colores, entre las que pueden mencionarse:\n\nscale_color_brewer(): para escalas de colores secuenciales, divergentes y cualitativas de ColorBrewer.\nscale_color_viridis_d(): para escalas viridis, diseñadas para mejorar la legibilidad de gráficos para lectores con formas comunes de daltonismo y discapacidades relacionadas con la percepción de colores.\nscale_color_manual(): para especificar directamente los colores a utilizar.\n\nEl siguiente bloque de código genera un gráfico de dispersión para los datos de diamonds. Muestra el peso en quilates (carat) de los diamantes en el eje X y su precio (price) en el eje Y. La variable correspondiente a su claridad (clarity) se muestra mediante el color de los puntos, de acuerdo con una escala de ColorBrewer.\n\n# Gráfico de dispersión de peso vs precio de diamantes\n# coloreado por claridad\ndiamonds |&gt;\n  ggplot(aes(x = carat, y = price, color = clarity)) +\n  geom_point() +\n  ggtitle(\"Peso vs precio de diamantes\") +\n  xlab(\"Peso (quilates)\") +\n  ylab(\"Precio ($ EE.UU.)\") +\n  labs(color = \"Claridad\\n(I1=peor IF=mejor)\") +\n  scale_colour_brewer(palette = \"YlOrBr\", direction = -1) +\n  theme_ipsum() # estilo de hrbrthemes\n\n\n\n\n\n\n\n\nPara más información sobre etiquetas, estilos, colores y otros temas relacionados en ggplot2, se recomienda leer ggplot2: Elegant Graphics for Data Analysis - Themes.\n\n\n\n10.5.1.7 Opciones avanzadas\nEn las secciones y ejemplos anteriores, se han estudiado las opciones básicas para crear un gráfico en ggplot2: datos, mapeos de variables a propiedades visuales y capas. También se mostró la forma de implementar paneles, como un mecanismo para visualizar variables adicionales y algunos recursos para mejorar la apariencia de los gráficos.\nggplot2 incluye otras opciones para la creación de gráficos, como transformaciones estadísticas, transformaciones de sistemas de coordenadas y posicionamiento de las geometrías, las cuales pueden esquematizarse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n  &lt;FUNCION_GEOMETRIA&gt;(\n    mapping = aes(&lt;MAPEOS&gt;),\n    stat = &lt;ESTADISTICA&gt;,\n    position = &lt;POSICION&gt;\n  ) +\n  &lt;FUNCION_COORDENADAS&gt; +\n  &lt;FUNCION_FACET&gt;\nEn las secciones siguientes, se explicarán y ejemplificarán alguna de estas opciones.\n\n\n\n10.5.2 plotly\nplotly R es una biblioteca para gráficos interactivos que forma parte del grupo de bibliotecas de graficación de Plotly, el cual también incluye bibliotecas para otros lenguajes como Python, Julia, F# y MATLAB. Plotly fue originalmente escrita en JavaScript, por lo que es particularmente adecuada para gráficos interactivos en la Web.\nplotly implementa la función ggplotly(), la cual convierte graficos de ggplot2 a plotly, haciéndolos interactivos.\nEl siguiente bloque de código muestra un gráfico generado con ggplot2 y convertido a plotly con la función ggplotly().\n\n# Gráfico ggplot2\ngrafico_ggplot2 &lt;-\n  mpg |&gt;\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point(aes(\n    # datos que se muestran al colocar el ratón sobre un punto\n    text = paste0(\n      \"Modelo: \", manufacturer, \" \", model, \" \", year, \"\\n\",\n      \"Cilindrada: \", displ, \" l\", \"\\n\",\n      \"Rendimiento en autopista: \", hwy, \" mpg\", \"\\n\",\n      \"Tipo de tracción: \", drv\n    )\n  )) +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\",\n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_ipsum()\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es') # para mostrar los controles en español",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#tipos-de-gráficos",
    "href": "10-ggplot2-plotly.html#tipos-de-gráficos",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.6 Tipos de gráficos",
    "text": "10.6 Tipos de gráficos\nEn esta sección, se ejemplifican varios tipos de gráficos, los cuales se construyen con ggplot2 y luego se convierten a plotly.\n\n10.6.1 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable. La graficación de la distribución de las variables es, frecuentemente, una de las primeras tareas que se realiza cuando se explora un conjunto de datos.\nEn ggplot2, los histogramas se implementan con la función geom_histogram().\nEl siguiente bloque de código muestra, mediante un histograma, la distribución del producto interno bruto (PIB) per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007\nhistograma_ggplot2 &lt;- \n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      )\n    ), \n    bins = 10\n  ) + \n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 14o países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nLa función geom_density() permite crear una estimación de densidad del kernel (Kernel Density Estimation o KDE), una curva que muestra la densidad de los datos.\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007\nhistograma_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      ),\n      y = after_stat(density) # argumento necesario para crear la curva KDE\n    ),\n    bins = 10\n  ) +\n  geom_density() +\n  scale_y_continuous(labels = scales::label_comma()) + # para formatear el eje y en notación decimal\n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Densidad\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nEn el siguiente bloque, se incluye en el gráfico anterior la variable continent a través de la propiedad visual relleno (fill).\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007 por continente\nhistograma_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap, fill = continent)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"Continente: \", after_stat(fill), \"\\n\",\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      ),      \n      y = after_stat(density)\n    ),    \n    bins = 10\n  ) +\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Densidad\") +\n  labs(subtitle = \"Datos de 140 países\",\n       caption = \"Fuente: Gapminder.org\",\n       fill = \"Continente\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nEl gráfico anterior muestra como el PIB per cápita varía considerablemente entre continentes. La misma información puede mostrarse mediante paneles.\n\n# Histogramas ggplot2 de distribución del PIB per cápita en 2007 por continente\nhistograma_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      )\n    ),\n    bins = 10\n  ) +\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 140 países\",\n       caption = \"Fuente: Gapminder.org\",\n       fill = \"Continente\") +\n  facet_wrap(~ continent, nrow = 2) +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.2 Gráficos de caja\nUn gráfico de caja (boxplot) muestra información de una variable numérica a través de su mediana, sus cuartiles (Q1, Q2 y Q3) y sus valores atípicos.\nLa figura Figura 10.1 muestra los componentes de un gráfico de caja.\n\n\n\n\n\n\n\n\nFigura 10.1: Componentes de un diagrama de caja. Imagen de Onkel Dagobert.\n\n\n\n\n\nEn ggplot2, los gráficos de caja se implementan con la función geom_boxplot().\nEl siguiente bloque de código muestra, mediante un gráfico de caja, la distribución del PIB per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Gráfico de caja ggplot2 de distribución del PIB per cápita en 2007\ngrafico_caja_ggplot2 &lt;-\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(y = gdpPercap)) +\n  geom_boxplot() +\n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  ylab(\"PIB per cápita ($ EE.UU.)\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de caja plotly\nggplotly(grafico_caja_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\nEn el siguiente bloque, se utiliza la posición en el eje X para mostrar la variable continent y apreciar la distribución del PIB per cápita en cada continente.\n\n# Gráfico de caja ggplot2 de distribución del PIB per cápita en 2007 por continente\ngrafico_caja_ggplot2 &lt;-\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = continent, y = gdpPercap)) +\n  geom_boxplot() +\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  ylab(\"PIB per cápita ($ EE.UU.)\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de caja plotly\nggplotly(grafico_caja_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.3 Gráficos de barras\nUn gráfico de barras se compone de barras rectangulares con longitud proporcional a estadísticas (ej. frecuencias, promedios, mínimos, máximos) asociadas a una variable categórica o discreta. Las barras pueden ser horizontales o verticales y se recomienda que estén ordenadas según su longitud, a menos que exista un orden inherente a la variable (ej. el orden de los días de la semana). Es uno de los tipos de gráficos estadísticos más antiguos y comunes y tiene la ventaja de ser muy fácil de comprender.\nEn ggplot2, los gráficos de barras se implementan con las funciones geom_bar(), que se utiliza en gráficos que requieren transformaciones estadísticas, y geom_col(), para gráficos que no requieren estas transformaciones.\n\n10.6.3.1 Barras con transformaciones estadísticas\nLos gráficos de barras y otros tipos de gráficos (ej. histogramas, gráficos de caja, líneas de ajuste) pueden requerir de alguna transformación estadística antes de presentar la información. Esta transformación estadística puede ser un conteo, el cálculo de un promedio, un mínimo o un máximo, entre otras opciones.\nPor ejemplo, el siguiente gráfico muestra la cantidad de países por continente presentes en el conjunto de datos gapminder para el año 2007. Nótese que este conteo no está presente en ninguna de las variables del conjunto de datos.\n\n# Gráfico de barras con conteo de países por continente para el año 2007\ngrafico_barras_ggplot2 &lt;-\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = continent)) +\n  geom_bar(\n    aes(\n      text = paste0(\n        \"Cantidad de países: \", after_stat(count)\n      )\n    ),    \n  ) +\n  ggtitle(\"Cantidad de países por continente\") +\n  xlab(\"Continente\") +\n  ylab(\"Cantidad de países\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nPara ordenar las barras de acuerdo con el conteo, puede utilizarse la función fct_infreq() del paquete forcats de Tidyerse, para manejo de factores. Tenga en cuenta que la columna continent está definida como un factor.\n\n# Gráfico de barras con conteo de países por continente para el año 2007\ngrafico_barras_ggplot2 &lt;-\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = fct_infreq(continent))) +\n  geom_bar(\n    aes(\n      text = paste0(\n        \"Cantidad de países: \", after_stat(count)\n      )\n    )    \n  ) +\n  ggtitle(\"Cantidad de países por continente\") +\n  xlab(\"Continente\") +\n  ylab(\"Cantidad de países\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nSi se prefiere el orden inverso, puede utilizarse la función fct_rev() (ej. fct_rev(fct_infreq(continent))). Para más información sobre el ordenamiento en gráficos, se recomienda consultar FAQ: Reordering - ggplot2.\nEn un ejemplo similar, se cuenta la cantidad de diamantes por tipo de corte (cut), para el conjunto de datos diamonds.\n\n# Gráfico de barras con conteo de diamantes por corte\ngrafico_barras_ggplot2 &lt;-\ndiamonds |&gt;\n  ggplot(aes(x = fct_rev(cut))) +\n  geom_bar(\n    aes(\n      text = paste0(\n        \"Cantidad de diamantes: \", after_stat(count)\n      )\n    )\n  ) +\n  ggtitle(\"Cantidad de diamantes por corte\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad de diamantes\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nEl cálculo de la cantidad de países por continente o el de la cantidad de diamantes por corte, son ejemplos de transformaciones estadísticas. La Figura 10.2 muestra como se realiza este proceso para el gráfico anterior.\n\n\n\n\n\n\n\n\nFigura 10.2: Transformación estadística para un gráfico de barras de ggplot2. Imagen de Hadley Wickham.\n\n\n\n\n\nLas barras pueden mostrar otras transformaciones estadísticas a través del uso de los argumentos stat y fun.y de geom_bar(). Por ejemplo, stat = \"summary\" y fun.y = \"mean\"generan un gráfico que muestra el promedio de esperanza de vida (lifeExp) para cada continente para el año 2007.\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada continente para el año 2007\ngrafico_barras_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = fct_infreq(continent), y = lifeExp)) +\n  geom_bar(\n    stat = \"summary\", \n    fun.y = \"mean\",\n    aes(\n      text = paste0(\n        \"Promedio de esperanza de vida: \", round(after_stat(y), 2)\n      )\n    )\n  ) +\n  ggtitle(\"Promedio de esperanza de vida por continente en 2007\") +\n  xlab(\"Continente\") +\n  ylab(\"Promedio de esperanza de vida\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nNota:  la función fct_infreq() no está ordenando en este caso las columnas (se desconoce la razón). El ordenamiento aún puede conseguirse si se realiza primero el cálculo del promedio y luego se grafica la columna correspondiente, como en el siguiente bloque de código.\n\n# Cálculo del promedio de esperanza de vida por continente\ngapminder_mean_lifeExp_continent &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  group_by(continent) |&gt;\n  summarize(lifeExp_mean = mean(lifeExp))\n\n# Despliegue por orden descendente del promedio de esperanza de vida\ngapminder_mean_lifeExp_continent |&gt;\n  arrange(desc(lifeExp_mean))\n\n# A tibble: 5 × 2\n  continent lifeExp_mean\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Oceania           80.7\n2 Europe            77.6\n3 Americas          73.6\n4 Asia              70.7\n5 Africa            54.8\n\n\nLuego se dibuja luego el gráfico con geom_col() y se ordenan las barras con la función reorder().\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada continente para el año 2007\ngrafico_barras_ggplot2 &lt;-\n  gapminder_mean_lifeExp_continent |&gt;\n  ggplot(aes(x = reorder(continent,-lifeExp_mean), y = lifeExp_mean)) +\n  geom_col(\n    aes(\n      text = paste0(\n        \"Promedio de esperanza de vida: \", round(after_stat(y), 2)\n      )\n    )    \n  ) +\n  ggtitle(\"Promedio de esperanza de vida por continente en 2007\") +\n  xlab(\"Continente\") +\n  ylab(\"Promedio de esperanza de vida\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nEl uso de geom_col() se ampliará en la sección siguiente.\n\n\n10.6.3.2 Barras sin transformaciones estadísticas\nEn algunos conjuntos de datos, el valor que se quiere representar en la longitud de las barras ya está presente como una variable en el conjunto de datos, por lo que no es necesario que ggplot2 realice una transformación estadística. En estos casos, se utiliza la función geom_col().\nNota:  para dibujar barras sin transformaciones estadísticas, tambien es posible utilizar la función geom_bar(). En este caso, al argumento stat se le asigna el valor \"identity\" y al argumento y de aes() la variable que contiene el valor que quiere mostrarse en las barras.\nEl siguiente gráfico de barras muestra la población de los países de los países de América en 2007. Nótese que este valor se puede tomar directamente de la variable pop, después de realizar los filtros correspondientes.\n\n# Gráfico de barras con población de países \n# de América para el año 2007\ngrafico_barras_ggplot2 &lt;-\ngapminder |&gt;\n  filter(year == 2007 & continent == \"Americas\") |&gt;\n  ggplot(aes(x = reorder(country, pop), y = pop/1000000)) +\n  geom_col(\n    aes(\n      text = paste0(\n        \"País: \", country, \"\\n\",\n        \"Población (millones de habitantes): \", round(pop/1000000, 2)\n      )\n    )\n  ) +\n  coord_flip() + # para mostrar barras horizontales\n  ggtitle(\"Población de países de América en 2007\") +\n  xlab(\"País\") +\n  ylab(\"Población (millones de habitantes)\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.3.3 Barras apiladas\nAl usar el argumento fill de aes(), las barras de un gráfico pueden dividirse de acuerdo con una variable adicional, produciendo el efecto de barras apiladas (i.e. unas sobre otras).\nEn el siguiente bloque de código, se genera un gráfico de barras apiladas que, para el conjunto de datos diamonds, muestra las cantidades de diamantes por corte (cut) subdivididas por claridad (clarity).\n\n# Gráfico de barras apiladas por tipo de corte y claridad \ngrafico_barras_ggplot2 &lt;-\ndiamonds |&gt;\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de diamantes por corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad de diamantes\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\nEl argumento position = \"fill\" de geom_bar() también genera barras apiladas, pero le asigna a todas las barras la misma longitud, facilitando así la comparación de proporciones.\n\n# Gráfico de barras apiladas por tipo de corte y claridad \ngrafico_barras_ggplot2 &lt;-\ndiamonds |&gt;\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  ggtitle(\"Proporción de tipos de claridad en cortes de diamantes\") +\n  xlab(\"Corte\") +\n  ylab(\"Proporción\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.3.4 Barras agrupadas\nEl argumento position = \"dodge\" de geom_bar() genera barras agrupadas (i.e. unas al lado de otras), facilitando así la comparación de valores individuales.\n\n# Gráfico de barras agrupadas por tipo de corte y claridad \ngrafico_barras_ggplot2 &lt;-\ndiamonds |&gt;\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"dodge\") +\n  ggtitle(\"Cantidad de diamantes por corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad de diamantes\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n\n10.6.4 Gráficos de dispersión\nUn gráfico de dispersión (scatterplot) despliega los valores de dos variables numéricas, como puntos en un sistema de coordenadas. El valor de una variable se despliega en el eje X y el de la otra variable en el eje Y. Variables adicionales pueden ser mostradas mediante atributos de los puntos, tales como su tamaño, color o forma.\nEn ggplot2, los gráficos de dispersión se implementan con la función de geometría geom_point().\nEl siguiente bloque de código muestra la relación entre el PIB per cápita y la esperanza de vida de los países en el conjunto de datos gapminder, para el año 2007.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida en 2007\n# + línea de tendencia\ngrafico_dispersion_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \", country, \"\\n\",\n      \"PIB per cápita: $\", round(gdpPercap, 2), \"\\n\",\n      \"Esperanza de vida: \", round(lifeExp, 2), \" años\"\n    )\n  )) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"PIB per cápita vs esperanza de vida en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nComo se explicó anteriormente, se pueden agregar al gráfico variables adicionales mediante su mapeo a propiedades visuales. En el siguiente ejemplo, se agrega la variable de continente al gráfico anterior, mediante su mapeo a la propiedad correspondiente al color.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida por continente en 2007\ngrafico_dispersion_ggplot2 &lt;-\n  gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \", country, \"\\n\",\n      \"Continente: \", continent, \"\\n\",\n      \"PIB per cápita: $\", round(gdpPercap, 2), \"\\n\",\n      \"Esperanza de vida: \", round(lifeExp, 2), \" años\"      \n    )\n  )) +\n  ggtitle(\"PIB per cápita vs esperanza de vida por continente en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuente: Gapminder.org\", color = \"Continente\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.5 Gráficos de líneas\nUn gráfico de líneas muestra información en la forma de puntos de datos, llamados marcadores (markers), conectados por segmentos de líneas rectas. Es similar a un gráfico de dispersión pero, además del uso de segmentos de línea, tiene la particularidad de que los datos están ordenados, usualmente con respecto al eje X. Los gráficos de línea son usados frecuentemente para mostrar tendencias a través del tiempo.\nEn ggplot2, los gráficos de líneas se implementan con la función de geometría geom_line().\nEl siguiente gráfico de línea muestran la evolución en el tiempo de los casos positivos, fallecidos, recuperados y activos de COVID-19 en Costa Rica.\n\n# Gráfico de líneas con la evolución de los casos de COVID\ngrafico_lineas_ggplot2 &lt;-\n  covid_general |&gt;\n  ggplot(aes(x = fecha, y = value, color = variable)) +\n  geom_line(aes(y = positivos, color = \"Positivos\")) +\n  geom_line(aes(y = recuperados, color = \"Recuperados\")) +\n  geom_line(aes(y = activos, color = \"Activos\")) +\n  geom_line(aes(y = fallecidos, color = \"Fallecidos\")) +\n  scale_color_manual( # colores\n    \"\",\n    values = c(\n      \"Positivos\" = \"blue\",\n      \"Recuperados\" = \"green\",\n      \"Activos\" = \"red\",\n      \"Fallecidos\" = \"black\"\n    )\n  ) +\n  ggtitle(\"Casos acumulados de COVID en Costa Rica al 2022-05-30\") +\n  xlab(\"Fecha\") +\n  ylab(\"Casos\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_lineas_ggplot2) |&gt;\n  config(locale = 'es')\n\n\n\n\n\n\n\n10.6.6 Gráficos de pastel\nUn gráfico de pastel representa porcentajes y porciones en secciones (slices) de un círculo. Son muy populares, pero también criticados debido a la dificultad del cerebro humano de comparar áreas de sectores circulares, por lo que algunos expertos recomiendan sustituirlos por otros tipos de gráficos como, por ejemplo, gráficos de barras.\nEn ggplot2, los gráficos de pastel se implementan con la función de geometría geom_bar(stat = \"identity\", width = 1) y la función coord_polar(), la cual implementa un sistema de coordenadas polares.\nEl siguiente gráfico de pastel muestra la distribución de los delitos cometidos en 2022 en las provincias de Costa Rica.\n\n# Crear tabla de frecuencias\ntabla_frecuencias_delitos_2023_provincias &lt;- table(delitos_2023$Provincia)\n\n# Convertir la tabla en un data frame\ndelitos_2023_provincias &lt;- as.data.frame(tabla_frecuencias_delitos_2023_provincias)\n\n# Cambiar nombres de columnas del data frame\ndelitos_2023_provincias &lt;-\n  delitos_2023_provincias |&gt;\n  rename(Provincia = Var1, Frecuencia = Freq)\n\n# Calcular porcentajes por provincia\ndelitos_2023_provincias$Porcentaje &lt;-\n  100 * delitos_2023_provincias$Frecuencia / sum(delitos_2023_provincias$Frecuencia)\n\n# Crear gráfico de pastel utilizando ggplot2\ngrafico_pastel_ggplot2 &lt;-\n  delitos_2023_provincias |&gt;\n  ggplot(aes(x = \"\", y = Porcentaje, fill = Provincia)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\", start = 0) +\n  theme_void() +\n  labs(title = \"Porcentaje de delitos cometidos en 2022 por provincia\",\n    subtitle = \"Fuente: OIJ\") +\n  scale_fill_discrete(name = \"Provincia\") +\n  geom_text(\n    aes(label = paste0(round(Porcentaje, 1), \"%\")),\n    position = position_stack(vjust = 0.5),\n    color = \"white\",\n    size = 4\n  ) \n\n# Despliegue del gráfico\ngrafico_pastel_ggplot2\n\n\n\n\n\n\n\n# Gráfico de pastel plotly (está generando un error)\n# ggplotly(grafico_pastel_ggplot2) |&gt;\n#   config(locale = 'es')\n\nEl gráfico interactivo no se presenta en este caso, debido a que la función ggplotly() produce un error al procesar el gráfico de pastel generado por ggplot2.\n\n\n10.6.7 Otros tipos de gráficos\nggplot2 provee más de 40 tipos de geometrías para gráficos (puntos, líneas, barras, histogramas, cajas, etc.) y los paquetes de extensión proporcionan aún más (ej. https://exts.ggplot2.tidyverse.org/gallery/).\nPara una explicación resumida de ggplot2, se recomienda leer Data visualization with ggplot2::Cheat Sheet.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "10-ggplot2-plotly.html#recursos-de-interés",
    "href": "10-ggplot2-plotly.html#recursos-de-interés",
    "title": "10  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "10.7 Recursos de interés",
    "text": "10.7 Recursos de interés\nDT: An R interface to the DataTables library. (s. f.). Recuperado 21 de mayo de 2022, de https://rstudio.github.io/DT/\nHealy, Y. H. and C. (s. f.). From data to Viz | Find the graphic you need. Recuperado 20 de marzo de 2022, de https://www.data-to-viz.com/\nRStudio. (2017). Data visualization with ggplot2::Cheat Sheet. https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf\nWickham, H. (2010). A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, 19(1), 3-28. https://doi.org/10.1198/jcgs.2009.07098",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "14-operaciones-datos-geometrias.html",
    "href": "14-operaciones-datos-geometrias.html",
    "title": "14  Operaciones con geometrías",
    "section": "",
    "text": "14.1 Resumen\nLas operaciones con geometrías para datos vectoriales incluyen simplificación, creación de centroides, creación de áreas de amortiguamiento (buffers), recortes (clipping) y uniones de geometrías, entre otras. Por su parte, las operaciones con geometrías para datos raster incluyen intersecciones geométricas, agregación y desagregación, entre otras.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Operaciones con geometrías</span>"
    ]
  },
  {
    "objectID": "14-operaciones-datos-geometrias.html#trabajo-previo",
    "href": "14-operaciones-datos-geometrias.html#trabajo-previo",
    "title": "14  Operaciones con geometrías",
    "section": "14.2 Trabajo previo",
    "text": "14.2 Trabajo previo\n\n14.2.1 Lecturas\nLovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulo 5). CRC Press. https://geocompr.robinlovelace.net/\n\n\n14.2.2 Carga de paquetes\n\n# Carga de paquetes\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leaflet.extras)\nlibrary(leafem)\n\n\n\n14.2.3 Carga de datos para ejemplos\n\n14.2.3.1 Provincias de Costa Rica\nEs un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura y visualización de datos geoespaciales de provincias\n\n# Lectura\nprovincias &lt;-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n14.2.3.2 Red vial de Costa Rica\nEs un archivo GeoJSON con las líneas de la red vial de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura y visualización de datos geoespaciales de la red vial\n\n# Lectura\nred_vial &lt;-\n  st_read(\n    dsn = \"datos/ign/infraestructura/redvial.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  red_vial$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Red vial de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n14.2.3.3 Mamíferos de Costa Rica\nEs un archivo CSV con registros de presencia de la clase Mammalia (mamíferos) de Costa Rica. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\n\n# Lectura y visualización de datos geoespaciales de mamíferos\n\n# Lectura\nmamiferos &lt;-\n  st_read(\n    \"datos/gbif/mamiferos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\n# Asignación del CRS WGS84\nst_crs(mamiferos) &lt;- 4326\n\n# Visualización en un mapa\nplot(\n  mamiferos$geometry,\n  pch = 16,\n  main = \"Mamíferos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Operaciones con geometrías</span>"
    ]
  },
  {
    "objectID": "14-operaciones-datos-geometrias.html#introducción",
    "href": "14-operaciones-datos-geometrias.html#introducción",
    "title": "14  Operaciones con geometrías",
    "section": "14.3 Introducción",
    "text": "14.3 Introducción\nEsta lección brinda una visión general de las operaciones con geometrías en datos vectoriales implementadas en el paquete sf y en datos raster implementadas en el paquete terra. Estas operaciones trabajan con la columna de geometrías (ej. geometry, geom) del paquete sf, para el caso de los datos vectoriales, y con la localización geográfica de los pixeles para el caso de los datos raster. En la sección final, se muestran varias operaciones de interacción entre los modelos raster y vectorial.",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Operaciones con geometrías</span>"
    ]
  },
  {
    "objectID": "14-operaciones-datos-geometrias.html#datos-vectoriales",
    "href": "14-operaciones-datos-geometrias.html#datos-vectoriales",
    "title": "14  Operaciones con geometrías",
    "section": "14.4 Datos vectoriales",
    "text": "14.4 Datos vectoriales\nLas operaciones con geometrías en datos vectoriales incluyen:\n\nSimplificación.\n\nCentroides.\nÁreas de amortiguamiento (buffers).\n\n\n14.4.1 Simplificación\nLa simplificación puede realizarse en geometrías de líneas y polígonos. Reduce la cantidad de memoria, disco y ancho de banda que utilizan las geometrías. Para simplificar geometrías, el paquete sf incluye el método st_simplify(), basado en el algoritmo de Douglas-Peucker, el cual recibe el argumento dTolerance para controlar el nivel de generalización de las unidades del mapa. Este argumento se expresa en las unidades de medida del CRS de la capa, por lo que es conveniente utilizar un CRS con unidades de medida de distancias (ej. metros).\nEl siguiente bloque de código simplifica la capa de provincias, primero sin preservar su topología y luego preservándola.\n\n# Simplificación de la capa de provincias\n\n# Simplificación sin preservación de topología\nprovincias_simplificado &lt;-\n  provincias |&gt;\n  st_simplify(dTolerance = 5000, preserveTopology = FALSE)\n\n# Mapa de la capa de provincias con simplificación y sin preservación de topología\nplot(\n  provincias_simplificado$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas sin preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n\n\n\n\n\n\n# Simplificación con preservación de topología\nprovincias_simplificado_topologia &lt;-\n  provincias |&gt;\n  st_simplify(dTolerance = 5000, preserveTopology = TRUE)\n\n# Mapa de la capa de provincias con simplificación y con preservación de topología\nplot(\n  provincias_simplificado_topologia$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas con preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n\n\n\n\n\n\n# Tamaño de la capa original\nobject.size(provincias)\n\n12259912 bytes\n\n# Tamaño de la capa simplificada sin preservación de topología\nobject.size(provincias_simplificado)\n\n17872 bytes\n\n# Tamaño de la capa simplificada con preservación de topología\nobject.size(provincias_simplificado_topologia)\n\n69840 bytes\n\n\nLa función ms_simplify() del paquete `rmapshaper`` proporciona un método alternativo para la simplificación de geometrías, el cual preserva la topología.\n\n\n14.4.2 Centroides\nUn centroide es un punto que identifica el centro de un objeto geográfico. Puede calcularse para geometrías de líneas y de polígonos y se utilizan para brindar una representación simplificada de geometrías más complejas. Existen varios métodos para calcularlos.\nEl paquete sf incluye la función st_centroid(), la cual calcula el centroide geográfico (comúnmente llamado “el centroide”). Es posible que el centroide geográfico se ubique fuera de la geometría “padre” (ej. en el caso de una geometría con forma de anillo). Para evitar este resultado, la función st_point_on_surface() se asegura de que el centroide esté siempre dentro de la geometría “padre”.\nEl siguiente bloque de código calcula los centroides para Costa Rica, mediante las dos funciones mencionadas.\n\n# Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  st_union(provincias), # unión de los polígonos de provincias\n  main = \"Centroides de CR: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa del centroide calculado con st_centroid()\nplot(st_centroid(st_union(provincias)),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(provincias)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n# Coordenadas del centroide calculado con st_centroid()\n# CRTM05\nst_coordinates(st_centroid(st_union(provincias)))\n\n            X       Y\n[1,] 478674.4 1102734\n\n# WGS84\nst_coordinates(st_transform(st_centroid(st_union(provincias)), crs = 4326))\n\n             X        Y\n[1,] -84.19451 9.972725\n\n# Coordenadas del centroide calculado con st_point_on_surface()\n# CRTM05\nst_coordinates(st_point_on_surface(st_union(provincias)))\n\n            X       Y\n[1,] 539373.5 1065147\n\n# WGS84\nst_coordinates(st_transform(st_point_on_surface(st_union(provincias)), crs = 4326))\n\n             X        Y\n[1,] -83.64124 9.632735\n\n\nEl siguiente bloque de código calcula los centroides de las provincias de Costa Rica, mediante las dos funciones mencionadas.\n\n# Provincias de Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Centroides de provincias: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de los centroides calculados con st_centroid()\nplot(st_centroid(provincias),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa de los centroides calculados con st_point_on_surface()\nplot(\n  st_point_on_surface(provincias),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n\nEl siguiente bloque de código calcula los centroides para la ruta 32, mediante las dos funciones mencionadas.\n\n# Ruta 32 y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Polígonos de San José, Heredia y Limón\nsanjose_heredia_limon &lt;-\n  provincias |&gt;\n  filter(provincia == \"San José\" | provincia == \"Heredia\" | provincia == \"Limón\")\n\n# Línea de la ruta 32\nruta_32 &lt;-\n  red_vial |&gt;\n  filter(num_ruta == \"32\")\n\n# Mapa de San José, Heredia y Limón\nplot(\n  sanjose_heredia_limon$geometry,\n  main = \"Centroides de la ruta 32: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de la ruta 32\nplot(\n  ruta_32$geometry,\n  add = TRUE,\n  lwd = 2,\n  col = \"blue\")\n\n# Mapa del centroide calculado con st_centroid()\nplot(\n  st_centroid(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n\n\n\n14.4.3 Áreas de amortiguamiento (buffers)\nLos buffers son polígonos creados alrededor de otra geometría, ya sea otro polígono, una línea o un punto. El paquete sf incluye la función st_buffer() para la generación de buffers.\n\n# Buffer alrededor de la ruta 32\n\n# Buffer que rodea la ruta 32\nplot(\n  st_buffer(st_union(ruta_32), 5000),\n  main = \"Buffer que rodea la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Línea de la ruta 32\nplot(\n  ruta_32$geometry,\n  col = \"blue\",\n  add = TRUE\n)\n\n\n\n\n\n\n\n\nEspecies de mamíferos en riesgo de atropello en las cercanías de la ruta 32\nEs común el uso de buffers en análisis de datos, para responder preguntas como, por ejemplo, “¿cuántos puntos hay alrededor de una línea?” o “¿cuáles especies pueden encontrarse en las márgenes de un río?”. En este ejemplo, se utiliza un buffer para identificar las especies de mamíferos en riesgo de ser atropellados en las cercanías de la ruta 32.\n\n# Registros de presencia de mamíferos no voladores ubicados alrededor de la ruta 32\n\n# Registros de presencia de mamíferos no voladores\nmamiferos_no_voladores &lt;-\n  mamiferos |&gt;\n  filter(taxonRank == \"SPECIES\" | taxonRank == \"SUBSPECIES\") |&gt; # para excluir identificaciones a género o superiores\n  filter(order != \"Chiroptera\") # se excluyen los murciélagos\n\n# Línea de la ruta 32\nruta_32 &lt;-\n  red_vial |&gt;\n  filter(num_ruta == \"32\") |&gt;\n  st_transform(4326)\n\n# Buffer de la ruta 32\nbuffer_ruta_32 &lt;-\n  ruta_32 |&gt;\n  st_buffer(dist = 5000) |&gt;\n  st_transform(4326)\n\n# Registros de presencia dentro del buffer\nmamiferos_buffer_ruta_32 &lt;-\n  st_join(mamiferos_no_voladores, buffer_ruta_32) |&gt;\n  filter(!is.na(codigo))\n\n# Mapa\nplot(\n  st_union(buffer_ruta_32),\n  main = \"Mamíferos terrestres alrededor de la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\nplot(ruta_32$geometry,\n     col = \"blue\",\n     add = TRUE)\n\nplot(\n  mamiferos_buffer_ruta_32,\n  pch = 16,\n  col = \"orange\",\n  add = TRUE\n)\n\nWarning in plot.sf(mamiferos_buffer_ruta_32, pch = 16, col = \"orange\", add =\nTRUE): ignoring all but the first attribute\n\n\n\n\n\n\n\n\n\nLista de especies y cantidad de registros de presencia:\n\n# Lista de especies\nlista_especies &lt;-\n  mamiferos_buffer_ruta_32 |&gt;\n  st_drop_geometry() |&gt;\n  filter(!is.na(species) & species != \"\") |&gt;\n  group_by(species) |&gt;\n  summarise(registros = n()) |&gt;\n  arrange(desc(registros)) |&gt;\n  rename(especie = species)\n\n# Tabla\nlista_especies %&gt;%\n  datatable(options = list(\n    pageLength = 10,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\nMapa leaflet:\n\n# Mapa de mamíferos cerca de la ruta 32\nleaflet() |&gt;\n  addTiles(group = \"OpenStreetMap\") |&gt;\n  addPolygons(data = st_union(buffer_ruta_32),\n              group = \"Buffer\") |&gt;\n  addHeatmap(\n    data = mamiferos_buffer_ruta_32,\n    lng = ~ decimalLongitude,\n    lat = ~ decimalLatitude,\n    radius = 10,\n    blur = 20,\n    group = \"Mapa de calor\"\n  ) |&gt;\n  addPolylines(data = ruta_32,\n               group = \"Ruta 32\") |&gt;\n  addCircleMarkers(\n    data = mamiferos_buffer_ruta_32,\n    radius = 1,\n    color = \"black\",\n    popup = paste(\n      mamiferos_buffer_ruta_32$species,\n      paste0(\n        \"&lt;a href='\",\n        mamiferos_buffer_ruta_32$occurrenceID,\n        \"'&gt;Más información&lt;/a&gt;\"\n      ),\n      sep = '&lt;br/&gt;'\n    ),\n    clusterOptions = markerClusterOptions(),\n    group = \"Registros de presencia\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Buffer\", \"Mapa de calor\", \"Ruta 32\", \"Registros de presencia\")\n  ) |&gt;\n  addScaleBar(position = \"bottomright\", options = scaleBarOptions(imperial = FALSE))",
    "crumbs": [
      "V - El ecosistema espacial de R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Operaciones con geometrías</span>"
    ]
  },
  {
    "objectID": "examen-corto-04.html",
    "href": "examen-corto-04.html",
    "title": "Examen corto 4",
    "section": "",
    "text": "Fecha",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 4"
    ]
  },
  {
    "objectID": "examen-corto-04.html#fecha",
    "href": "examen-corto-04.html#fecha",
    "title": "Examen corto 4",
    "section": "",
    "text": "Grupo 001: jueves 20 de junio de 2024\nGrupo 002: miércoles 19 de junio de 2024",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 4"
    ]
  },
  {
    "objectID": "examen-corto-04.html#temas-a-evaluar",
    "href": "examen-corto-04.html#temas-a-evaluar",
    "title": "Examen corto 4",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n11 Introducción al manejo de datos geoespaciales con R\n12 Operaciones con datos de atributos\n13 Operaciones con datos espaciales\n14 Operaciones con geometrías",
    "crumbs": [
      "Evaluaciones",
      "Examen corto 4"
    ]
  },
  {
    "objectID": "parte-vi-visualizacion-avanzada.html",
    "href": "parte-vi-visualizacion-avanzada.html",
    "title": "VI - Visualización avanzada",
    "section": "",
    "text": "15 Tableros de control\n16 shiny - desarrollo de aplicaciones web interactivas",
    "crumbs": [
      "VI - Visualización avanzada"
    ]
  },
  {
    "objectID": "15-tableros-control.html",
    "href": "15-tableros-control.html",
    "title": "15  Tableros de control",
    "section": "",
    "text": "15.1 Resumen",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#trabajo-previo",
    "href": "15-tableros-control.html#trabajo-previo",
    "title": "15  Tableros de control",
    "section": "15.2 Trabajo previo",
    "text": "15.2 Trabajo previo\n\n15.2.1 Lecturas\nQuarto - Quarto Dashboards. (s.f.). https://quarto.org/docs/dashboards/\n\n\n15.2.2 Carga de paquetes\n\n# Carga de paquetes\nlibrary(tidyverse)\nlibrary(plotly)\nlibrary(DT)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(leaflet.extras)\nlibrary(leafem)\n\n\n\n15.2.3 Carga de datos para ejemplos\n\n15.2.3.1 Provincias de Costa Rica\nEs un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura y visualización de datos geoespaciales de provincias\n\n# Lectura\nprovincias &lt;-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n15.2.3.2 Red vial de Costa Rica\nEs un archivo GeoJSON con las líneas de la red vial de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura y visualización de datos geoespaciales de la red vial\n\n# Lectura\nred_vial &lt;-\n  st_read(\n    dsn = \"datos/ign/infraestructura/redvial.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  red_vial$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Red vial de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n15.2.3.3 Mamíferos de Costa Rica\nEs un archivo CSV con registros de presencia de la clase Mammalia (mamíferos) de Costa Rica. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\n\n# Lectura y visualización de datos geoespaciales de mamíferos\n\n# Lectura\nmamiferos &lt;-\n  st_read(\n    \"datos/gbif/mamiferos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\n# Asignación del CRS WGS84\nst_crs(mamiferos) &lt;- 4326\n\n# Visualización en un mapa\nplot(\n  mamiferos$geometry,\n  pch = 16,\n  main = \"Mamíferos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#introducción",
    "href": "15-tableros-control.html#introducción",
    "title": "15  Tableros de control",
    "section": "15.3 Introducción",
    "text": "15.3 Introducción\nUn tablero de control, también llamado cuadro de mando o dashboard, es un tipo de interfaz gráfica de usuario que reúne visualizaciones de datos e información resumida relevantes para una temática, objetivo o proceso particular. Estas visualizaciones se presentan principalmente en formato de tablas, gráficos estadísticos y mapas (ej. Tablero de control de la Universidad Johns Hopkins sobre la epidemia de Covid-19). El término dashboard proviene del tablero de instrumentos de un automóvil, el cual le permite al conductor monitorear rápidamente las funciones principales del vehículo.\nLos tableros de control son usualmente accesibles mediante un navegador web y pueden estar vinculados a fuentes de datos que se actualizan regularmente. Se caracterizan por ser interactivos y facilitar la exploración de datos a los usuarios.\nQuarto facilita el desarrollo de tableros de control a través de Quarto Dashboards](https://quarto.org/docs/dashboards/.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#datos-vectoriales",
    "href": "15-tableros-control.html#datos-vectoriales",
    "title": "15  Tableros de control",
    "section": "15.4 Datos vectoriales",
    "text": "15.4 Datos vectoriales\nLas operaciones con geometrías en datos vectoriales incluyen:\n\nSimplificación.\n\nCentroides.\nÁreas de amortiguamiento (buffers).\n\n\n15.4.1 Simplificación\nLa simplificación puede realizarse en geometrías de líneas y polígonos. Reduce la cantidad de memoria, disco y ancho de banda que utilizan las geometrías. Para simplificar geometrías, el paquete sf incluye el método st_simplify(), basado en el algoritmo de Douglas-Peucker, el cual recibe el argumento dTolerance para controlar el nivel de generalización de las unidades del mapa. Este argumento se expresa en las unidades de medida del CRS de la capa, por lo que es conveniente utilizar un CRS con unidades de medida de distancias (ej. metros).\nEl siguiente bloque de código simplifica la capa de provincias, primero sin preservar su topología y luego preservándola.\n\n# Simplificación de la capa de provincias\n\n# Simplificación sin preservación de topología\nprovincias_simplificado &lt;-\n  provincias |&gt;\n  st_simplify(dTolerance = 5000, preserveTopology = FALSE)\n\n# Mapa de la capa de provincias con simplificación y sin preservación de topología\nplot(\n  provincias_simplificado$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas sin preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n\n\n\n\n\n\n# Simplificación con preservación de topología\nprovincias_simplificado_topologia &lt;-\n  provincias |&gt;\n  st_simplify(dTolerance = 5000, preserveTopology = TRUE)\n\n# Mapa de la capa de provincias con simplificación y con preservación de topología\nplot(\n  provincias_simplificado_topologia$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas con preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n\n\n\n\n\n\n# Tamaño de la capa original\nobject.size(provincias)\n\n12259912 bytes\n\n# Tamaño de la capa simplificada sin preservación de topología\nobject.size(provincias_simplificado)\n\n17872 bytes\n\n# Tamaño de la capa simplificada con preservación de topología\nobject.size(provincias_simplificado_topologia)\n\n69840 bytes\n\n\nLa función ms_simplify() del paquete `rmapshaper`` proporciona un método alternativo para la simplificación de geometrías, el cual preserva la topología.\n\n\n15.4.2 Centroides\nUn centroide es un punto que identifica el centro de un objeto geográfico. Puede calcularse para geometrías de líneas y de polígonos y se utilizan para brindar una representación simplificada de geometrías más complejas. Existen varios métodos para calcularlos.\nEl paquete sf incluye la función st_centroid(), la cual calcula el centroide geográfico (comúnmente llamado “el centroide”). Es posible que el centroide geográfico se ubique fuera de la geometría “padre” (ej. en el caso de una geometría con forma de anillo). Para evitar este resultado, la función st_point_on_surface() se asegura de que el centroide esté siempre dentro de la geometría “padre”.\nEl siguiente bloque de código calcula los centroides para Costa Rica, mediante las dos funciones mencionadas.\n\n# Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  st_union(provincias), # unión de los polígonos de provincias\n  main = \"Centroides de CR: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa del centroide calculado con st_centroid()\nplot(st_centroid(st_union(provincias)),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(provincias)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n# Coordenadas del centroide calculado con st_centroid()\n# CRTM05\nst_coordinates(st_centroid(st_union(provincias)))\n\n            X       Y\n[1,] 478674.4 1102734\n\n# WGS84\nst_coordinates(st_transform(st_centroid(st_union(provincias)), crs = 4326))\n\n             X        Y\n[1,] -84.19451 9.972725\n\n# Coordenadas del centroide calculado con st_point_on_surface()\n# CRTM05\nst_coordinates(st_point_on_surface(st_union(provincias)))\n\n            X       Y\n[1,] 539373.5 1065147\n\n# WGS84\nst_coordinates(st_transform(st_point_on_surface(st_union(provincias)), crs = 4326))\n\n             X        Y\n[1,] -83.64124 9.632735\n\n\nEl siguiente bloque de código calcula los centroides de las provincias de Costa Rica, mediante las dos funciones mencionadas.\n\n# Provincias de Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Centroides de provincias: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de los centroides calculados con st_centroid()\nplot(st_centroid(provincias),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa de los centroides calculados con st_point_on_surface()\nplot(\n  st_point_on_surface(provincias),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n\nEl siguiente bloque de código calcula los centroides para la ruta 32, mediante las dos funciones mencionadas.\n\n# Ruta 32 y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Polígonos de San José, Heredia y Limón\nsanjose_heredia_limon &lt;-\n  provincias |&gt;\n  filter(provincia == \"San José\" | provincia == \"Heredia\" | provincia == \"Limón\")\n\n# Línea de la ruta 32\nruta_32 &lt;-\n  red_vial |&gt;\n  filter(num_ruta == \"32\")\n\n# Mapa de San José, Heredia y Limón\nplot(\n  sanjose_heredia_limon$geometry,\n  main = \"Centroides de la ruta 32: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de la ruta 32\nplot(\n  ruta_32$geometry,\n  add = TRUE,\n  lwd = 2,\n  col = \"blue\")\n\n# Mapa del centroide calculado con st_centroid()\nplot(\n  st_centroid(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n\n\n\n\n\n\n\n\n\n15.4.3 Áreas de amortiguamiento (buffers)\nLos buffers son polígonos creados alrededor de otra geometría, ya sea otro polígono, una línea o un punto. El paquete sf incluye la función st_buffer() para la generación de buffers.\n\n# Buffer alrededor de la ruta 32\n\n# Buffer que rodea la ruta 32\nplot(\n  st_buffer(st_union(ruta_32), 5000),\n  main = \"Buffer que rodea la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Línea de la ruta 32\nplot(\n  ruta_32$geometry,\n  col = \"blue\",\n  add = TRUE\n)\n\n\n\n\n\n\n\n\nEspecies de mamíferos en riesgo de atropello en las cercanías de la ruta 32\nEs común el uso de buffers en análisis de datos, para responder preguntas como, por ejemplo, “¿cuántos puntos hay alrededor de una línea?” o “¿cuáles especies pueden encontrarse en las márgenes de un río?”. En este ejemplo, se utiliza un buffer para identificar las especies de mamíferos en riesgo de ser atropellados en las cercanías de la ruta 32.\n\n# Registros de presencia de mamíferos no voladores ubicados alrededor de la ruta 32\n\n# Registros de presencia de mamíferos no voladores\nmamiferos_no_voladores &lt;-\n  mamiferos |&gt;\n  filter(taxonRank == \"SPECIES\" | taxonRank == \"SUBSPECIES\") |&gt; # para excluir identificaciones a género o superiores\n  filter(order != \"Chiroptera\") # se excluyen los murciélagos\n\n# Línea de la ruta 32\nruta_32 &lt;-\n  red_vial |&gt;\n  filter(num_ruta == \"32\") |&gt;\n  st_transform(4326)\n\n# Buffer de la ruta 32\nbuffer_ruta_32 &lt;-\n  ruta_32 |&gt;\n  st_buffer(dist = 5000) |&gt;\n  st_transform(4326)\n\n# Registros de presencia dentro del buffer\nmamiferos_buffer_ruta_32 &lt;-\n  st_join(mamiferos_no_voladores, buffer_ruta_32) |&gt;\n  filter(!is.na(codigo))\n\n# Mapa\nplot(\n  st_union(buffer_ruta_32),\n  main = \"Mamíferos terrestres alrededor de la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\nplot(ruta_32$geometry,\n     col = \"blue\",\n     add = TRUE)\n\nplot(\n  mamiferos_buffer_ruta_32,\n  pch = 16,\n  col = \"orange\",\n  add = TRUE\n)\n\nWarning in plot.sf(mamiferos_buffer_ruta_32, pch = 16, col = \"orange\", add =\nTRUE): ignoring all but the first attribute\n\n\n\n\n\n\n\n\n\nLista de especies y cantidad de registros de presencia:\n\n# Lista de especies\nlista_especies &lt;-\n  mamiferos_buffer_ruta_32 |&gt;\n  st_drop_geometry() |&gt;\n  filter(!is.na(species) & species != \"\") |&gt;\n  group_by(species) |&gt;\n  summarise(registros = n()) |&gt;\n  arrange(desc(registros)) |&gt;\n  rename(especie = species)\n\n# Tabla\nlista_especies %&gt;%\n  datatable(options = list(\n    pageLength = 10,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\nMapa leaflet:\n\n# Mapa de mamíferos cerca de la ruta 32\nleaflet() |&gt;\n  addTiles(group = \"OpenStreetMap\") |&gt;\n  addPolygons(data = st_union(buffer_ruta_32),\n              group = \"Buffer\") |&gt;\n  addHeatmap(\n    data = mamiferos_buffer_ruta_32,\n    lng = ~ decimalLongitude,\n    lat = ~ decimalLatitude,\n    radius = 10,\n    blur = 20,\n    group = \"Mapa de calor\"\n  ) |&gt;\n  addPolylines(data = ruta_32,\n               group = \"Ruta 32\") |&gt;\n  addCircleMarkers(\n    data = mamiferos_buffer_ruta_32,\n    radius = 1,\n    color = \"black\",\n    popup = paste(\n      mamiferos_buffer_ruta_32$species,\n      paste0(\n        \"&lt;a href='\",\n        mamiferos_buffer_ruta_32$occurrenceID,\n        \"'&gt;Más información&lt;/a&gt;\"\n      ),\n      sep = '&lt;br/&gt;'\n    ),\n    clusterOptions = markerClusterOptions(),\n    group = \"Registros de presencia\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Buffer\", \"Mapa de calor\", \"Ruta 32\", \"Registros de presencia\")\n  ) |&gt;\n  addScaleBar(position = \"bottomright\", options = scaleBarOptions(imperial = FALSE))",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#el-paquete-dashboards",
    "href": "15-tableros-control.html#el-paquete-dashboards",
    "title": "15  Tableros de control",
    "section": "15.4 El paquete dashboards",
    "text": "15.4 El paquete dashboards",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#quarto-dashboards",
    "href": "15-tableros-control.html#quarto-dashboards",
    "title": "15  Tableros de control",
    "section": "15.4 Quarto Dashboards",
    "text": "15.4 Quarto Dashboards\nQuarto Dashboards es una capacidad de Quarto (introducida en la versión 1.4) que permite crear tableros de control mediante los lenguajes de programación R, Python, Julia y Observable. Estos tableros de control pueden incluir componentes desarrollados en DT, Ggplot2, Plotly y Leaflet, entre otros paquetes de R. Pueden publicarse como páginas estáticas (ej. en GitHub Pages) o en un servidor Shiny para proporcionar mayor interactividad al usuario.\nLa Figura 15.1 muestra un tablero de control desarrollado con Quarto Dashboards.\n\n\n\n\n\n\nFigura 15.1: Tablero de control desarrollado con Quarto Dashboards. Fuente: Quarto Dashboards.\n\n\n\n\n15.4.1 Componentes\nUn tablero de control desarrollado con Quarto Dashboards tiene los siguientes componentes:\n\nBarra de navegación: incluye el título, íconos y autor junto con enlaces a páginas (si se definen más de una página).\nPáginas, filas, columnas y pestañas (tabs): Las páginas, filas y columnas se definen utilizando encabezados de Markdown (con atributos opcionales para controlar la altura, el ancho y otras propiedades). Las pestañas pueden usarse para dividir aún más el contenido de una fila o columna.\nTarjetas, barras laterales y barras de herramientas: Las tarjetas son contenedores para visualizaciones de datos como tablas, gráficos estadísticos, mapas y otras. Las barras laterales y barras de herramientas se utilizan para el ingreso de datos en tableros de control interactivos.\n\n\n\n15.4.2 Configuración\nLos tableros de control son arreglos de componentes que se utilizan para proporcionar navegación y presentar datos. A continuación, se describen los elementos que se utilizan para estructurar la navegación y el diseño de los tableros de control.\n\n15.4.2.1 Navegación\nTodos los tableros de control tienen una barra de navegación que muestra el título y, opcionalmente, un logotipo, el nombre del autor e íconos con enlaces a redes sociales y otros sitios de interés. Los tableros de control con múltiples páginas también contienen un enlace a cada página en la barra de navegación.\n\n\n15.4.2.2 Organización\nDentro de una página, los componentes del tablero de control se organizan mediante conjuntos alternos de filas y columnas. Las filas y columnas, a su vez, se definen mediante encabezados de Markdown y celdas computacionales (bloques de código).\n\n\n15.4.2.3 Páginas\nPara introducir múltiples páginas, se utilizan encabezados de nivel 1 sobre los encabezados de nivel 2, los cuales se usan para definir filas y columnas. El texto de los encabezados de nivel 1 se usa para enlazar a las páginas en la barra de navegación.\n\n\n15.4.2.4 Pestañas\nLas pestañas (tabs) se utilizan para incluir múltiples vistas de datos o contenido de importancia secundaria sin que interfiera con la visualización principal. Las pestañas se crean añadiendo la clase .tabset a una fila o columna.\n\n\n15.4.2.5 Tarjetas\nLas tarjetas son la unidad fundamental de visualización en un tablero de control. Constituyen el contenido de las filas y las columnas.\nPara más información sobre la configuración de los tableros de control, se recomienda consultar Dashboard Layout.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#recursos-adicionales",
    "href": "15-tableros-control.html#recursos-adicionales",
    "title": "15  Tableros de control",
    "section": "15.6 Recursos adicionales",
    "text": "15.6 Recursos adicionales\nQuarto Dashboards | Charles Teague | Posit\nEjemplos de tableros de control desarrollados con Quarto Dashboards\n\n\n\nFigura 15.1: Tablero de control desarrollado con Quarto Dashboards. Fuente: Quarto Dashboards.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "15-tableros-control.html#ejercicios",
    "href": "15-tableros-control.html#ejercicios",
    "title": "15  Tableros de control",
    "section": "15.5 Ejercicios",
    "text": "15.5 Ejercicios\n\nOrganice en un tablero de control las visualizaciones de datos sobre riesgo de atropello de especies de mamíferos alrededor de la ruta 32. Incluya:\n\nUna tabla DT con las especies en mayor riesgo y la cantidad de registros.\nUn gráfico Plotly que muestre la misma información que el punto a.\nUn mapa Leaflet que muestre la zona de riesgo y los registros de presencia.\n\nAgregue tablas, gráficos y mapas adicionales que considere de impoortancia.\nPublique el tablero de control como un sitio en GitHub Pages.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tableros de control</span>"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html",
    "href": "tarea-04-grupo-002.html",
    "title": "Tarea 4 - Grupo 002",
    "section": "",
    "text": "Fecha y hora límite de entrega\nMiércoles 26 de junio de 2024, 8:00 a.m.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#descripción-general",
    "href": "tarea-04-grupo-002.html#descripción-general",
    "title": "Tarea 4 - Grupo 002",
    "section": "Descripción general",
    "text": "Descripción general\nEsta tarea consiste en desarrollar un tablero de control en Quarto Dashboards que presente tablas, gráficos estadísticos y mapas sobre registros de presencia y especies de anfibios de Costa Rica. El tablero debe publicarse como un sitio web en GitHub Pages.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#objetivos",
    "href": "tarea-04-grupo-002.html#objetivos",
    "title": "Tarea 4 - Grupo 002",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir código fuente en el lenguaje de programación R y utilizar funciones de los paquetes DT, Tidyverse, Plotly, Leaflet y otros para leer datos, procesarlos y generar visualizaciones en forma de tablas, gráficos estadísticos y mapas.\nDesarrollar tableros de control con Quarto Dashboards que presenten las visualizaciones de datos en una forma organizada y atractiva para el usuario final.\nPublicar documentos Quarto como páginas web en GitHub Pages.\nAnalizar y corregir errores de programación.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#acerca-del-conjunto-de-datos",
    "href": "tarea-04-grupo-002.html#acerca-del-conjunto-de-datos",
    "title": "Tarea 4 - Grupo 002",
    "section": "Acerca del conjunto de datos",
    "text": "Acerca del conjunto de datos\nEl conjunto de datos de esta tarea consiste de 299 registros de pacientes que sufrieron insuficiencia cardíaca. Para cada paciente, se consideran 13 características clínicas (edad, sexo, si tenía anemia, si tenía diabetes, si fumaba y otras). Estos datos forman parte del artículo Chicco, D., Jurman, G. Machine learning can predict survival of patients with heart failure from serum creatinine and ejection fraction alone. BMC Med Inform Decis Mak 20, 16 (2020). Se recomienda leer el resumen (abstract) del artículo.\nEl archivo CSV con los datos está disponible en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2024-i/blob/main/datos/bmc/heart_failure_clinical_records_dataset.csv.\nPara más información sobre las variables del conjunto de datos, su significado y sus unidades de medida, puede consultar Meanings, measurement units, and intervals of each feature of the dataset.\nNOTA: hay varias variables booleanas con valor 0 o 1. 0 significa falso (no) y 1 significa verdadero (sí). Por ejemplo, para anaemia un valor de 1 significa que el paciente sí tuvo anemia y un valor de 0 significa que no tuvo anemia. En el caso de sex, un 0 corresponde a una mujer y un 1 a un hombre.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#entregables",
    "href": "tarea-04-grupo-002.html#entregables",
    "title": "Tarea 4 - Grupo 002",
    "section": "Entregables",
    "text": "Entregables\nDebe entregar dos direcciones web:\n\nDirección de un repositorio en GitHub (ej. https://github.com/mfvargas/anfibios-costarica) con el código fuente y los datos. Específicamente, el repositorio debe contener:\n\nUn documento Quarto llamado index.qmd con el código en R y la sintaxis Markdown necesarios para generar un tablero de control con las salidas especificadas en la sección Desarrollo.\nUn documento llamado index.html generado a partir de index.qmd.\nLos tres archivos de datos.\nEl directorio index_files.\n\nDirección de un sitio web en GitHub Pages publicado a partir del repositorio GitHub del punto 1 de esta sección (ej. https://mfvargas.github.io/anfibios-costarica/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#desarrollo",
    "href": "tarea-04-grupo-002.html#desarrollo",
    "title": "Tarea 4 - Grupo 002",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl tablero de control desarrollado en Quarto Dashboards debe contener las siguientes visualizaciones de datos.\n\n1 - Tabla de cantidad de registros de presencia por categoría de Lista Roja\nDebe ser una tabla interactiva generada con el paquete DT con una fila por categoría y dos columnas:\n\nAbreviatura de la categoría (EX, EW, CR, etc.).\nCantidad de registros de presencia de especies de anfibios en la categoría.\n\nLos encabezados de la tabla deben estar en español y ser significativos.\nSugerencias\n\nUna la columna iucnRedListCategory, del conjunto de datos de especies, al conjunto de datos de registros de presencia. Use una función de unión (join) no espacial, con la columna species que ambos conjuntos de datos tienen en común.\nUse el argumento colnames de la función datatable() para especificar los encabezados de las columnas.\n\n\n\n2 - Gráfico de barras de cantidad de especies en categorías CR, EN y VU de la Lista Roja\nDebe contener una barra por cada categoría mencionada (solo esas categorías) y su longitud debe mostrar la cantidad de especies de anfibios en la categoría. Las barras deben estar ordenadas por longitud (de mayor a menor o de menor a mayor).\nEl gráfico deben programarse con ggplot2 y convertirse a plotly con la función ggplotly(). Debe tener:\n\nTítulo (puede asignarlo directamente en el gráfico o con la opción #| title del bloque de código).\nEtiquetas en los ejes x e y.\n\n\n\n3 - Mapa de riqueza de especies de anfibios en áreas de conservación\nDebe ser un mapa leaflet interactivo con las siguientes capas y controles:\n\nDos capas base de tipo tiles (teselas) (ej. OSM, Carto, ESRI).\nUna capa de áreas de conservación (polígonos) coloreada de acuerdo con la riqueza de especies (i.e. cantidad de especies) de anfibios en cada área (i.e. un mapa de coropletas). Al hacer clic sobre un polígono, la ventana emergente debe mostrar el nombre del área y la cantidad de especies.\nUna leyenda que muestre el significado de los colores usados en la capa de áreas de conservación.\nUn control de capas.\n\n\n\n4 Gráfico de barras de riqueza de especies de anfibios en áreas de conservación\nDebe contener una barra por cada área de conservación y su longitud debe mostrar su riqueza de especies de anfibios. Las barras deben estar ordenadas por longitud (de mayor a menor o de menor a mayor).\nEl gráfico deben programarse con ggplot2 y convertirse a plotly con la función ggplotly(). Debe tener:\n\nTítulo (puede asignarlo directamente en el gráfico o en la opción #| title del bloque de código).\nEtiquetas en los ejes x e y.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#calificación",
    "href": "tarea-04-grupo-002.html#calificación",
    "title": "Tarea 4 - Grupo 002",
    "section": "Calificación",
    "text": "Calificación\n\nPresentación general del tablero de control (organización, distribución de los componentes): 20%\nTabla: 15%\nPrimer gráfico: 20%\nSegundo gráfico: 20%\nMapa: 25%\n\nUtilice todos los recursos que considere necesarios para organizar los componentes en el tablero de control: filas, columnas, páginas, pestañas, etc. Puede colocar los componentes en el orden que considere apropiado.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#consideraciones-adicionales",
    "href": "tarea-04-grupo-002.html#consideraciones-adicionales",
    "title": "Tarea 4 - Grupo 002",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\n\nLa tarea debe presentarse como un tablero de control desarrollado en Quarto Dashboards y no como otro tipo de documento.\nEsta tarea puede presentarse individualmente o en parejas. En este último caso, solo un estudiante debe presentar la tarea en Mediación Virtual y debe indicar ahí el nombre del otro estudiante.\nSi solo se entrega la dirección del repositorio en GitHub, y no el sitio publicado o este no es consistente con el código fuente del repositorio, se rebajará el 25% del valor de la tarea. RECOMENDACIÓN: genere el sitio web desde el inicio y actualícelo continuamente. No lo deje para última hora.\nNo se aceptarán tareas que se entreguen después de la fecha y hora límite.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-002.html#conjuntos-de-datos",
    "href": "tarea-04-grupo-002.html#conjuntos-de-datos",
    "title": "Tarea 4 - Grupo 002",
    "section": "Conjuntos de datos",
    "text": "Conjuntos de datos\nPara realizar esta tarea, debe utilizar tres conjuntos de datos (puede descargarlos en los enlaces):\n\nÁreas de conservación de Costa Rica\nEste archivo GPKG proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Sistema Nacional de Áreas de Conservación (Sinac) (https://geos1pne.sirefor.go.cr/wfs?). Las geometrías se simplificaron para reducir el tamaño del archivo.\nRegistros de presencia de anfibios de Costa Rica.\nEste archivo CSV proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF) (https://doi.org/10.15468/dl.4tqr9u). Contiene una fila por cada registro de presencia y atributos como el nombre de la especie (species) y las coordenadas geográficas del registro (decimalLongitude, decimalLatitude), entre otros. Se suprimieron las filas con identificaciones en niveles superiores a especie.\nEspecies de anfibios de Costa Rica.\nEste archivo CSV también proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF) (https://doi.org/10.15468/dl.xwmakq). Contiene una fila por cada especie. Se suprimieron las filas con taxones en niveles superiores a especie y se conservaron solo dos columnas de datos:\n\nspecies: nombre de la especie.\niucnRedListCategory: categoría de la especie en la Lista Roja de la UICN.\n\n\nLa Lista Roja de Especies Amenazadas de la Unión Internacional para la Conservación de la Naturaleza (UICN) es un inventario del estado de conservación de especies de animales y plantas a nivel mundial. La Lista Roja asigna a las especies una de las siguientes categorías:\n\nEX (Extinta)\nEW (Extinta en estado silvestre)\nCR (En peligro crítico de extinción)\nEN (En peligro de extinción)\nVU (Vulnerable)\nNT (Casi amenazada)\nLC (Preocupación menor)\nDD (Datos insuficientes)\nNE (No evaluada)",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 002"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html",
    "href": "tarea-04-grupo-001.html",
    "title": "Tarea 4 - Grupo 001",
    "section": "",
    "text": "Fecha y hora límite de entrega\nJueves 27 de junio de 2024, 11:00 a.m.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#descripción-general",
    "href": "tarea-04-grupo-001.html#descripción-general",
    "title": "Tarea 4 - Grupo 001",
    "section": "Descripción general",
    "text": "Descripción general\nEsta tarea consiste en desarrollar un tablero de control en Quarto Dashboards que presente tablas, gráficos estadísticos y mapas sobre registros de presencia y especies de reptiles de Costa Rica. El tablero debe publicarse como un sitio web en GitHub Pages.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#objetivos",
    "href": "tarea-04-grupo-001.html#objetivos",
    "title": "Tarea 4 - Grupo 001",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir código fuente en el lenguaje de programación R y utilizar funciones de los paquetes DT, Tidyverse, Plotly, Leaflet y otros para leer datos, procesarlos y generar visualizaciones en forma de tablas, gráficos estadísticos y mapas.\nDesarrollar tableros de control con Quarto Dashboards que presenten las visualizaciones de datos en una forma organizada y atractiva para el usuario final.\nPublicar documentos Quarto como páginas web en GitHub Pages.\nAnalizar y corregir errores de programación.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#conjuntos-de-datos",
    "href": "tarea-04-grupo-001.html#conjuntos-de-datos",
    "title": "Tarea 4 - Grupo 001",
    "section": "Conjuntos de datos",
    "text": "Conjuntos de datos\nPara realizar esta tarea, debe utilizar tres conjuntos de datos (puede descargarlos en los enlaces):\n\nRegiones socioeconómicas de Costa Rica\nEste conjunto de datos está contenido en el Atlas Digital de Costa Rica 2014 y fue facilitado por el Ministerio de Planificación (Mideplán). Los nombres de las regiones se actualizaron a la versión más reciente. Las geometrías se simplificaron para reducir el tamaño del archivo.\nRegistros de presencia de reptiles de Costa Rica.\nEste archivo CSV proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF) (https://doi.org/10.15468/dl.7526ez). Contiene una fila por cada registro de presencia y atributos como el nombre de la especie (species) y las coordenadas geográficas del registro (decimalLongitude, decimalLatitude), entre otros. Se suprimieron las filas con identificaciones en niveles superiores a especie.\nEspecies de reptiles de Costa Rica.\nEste archivo CSV también proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF) (https://doi.org/10.15468/dl.845zca). Contiene una fila por cada especie. Se suprimieron las filas con taxones en niveles superiores a especie y se conservaron solo dos columnas de datos:\n\nspecies: nombre de la especie.\niucnRedListCategory: categoría de la especie en la Lista Roja de la UICN.\n\n\nLa Lista Roja de Especies Amenazadas de la Unión Internacional para la Conservación de la Naturaleza (UICN) es un inventario del estado de conservación de especies de animales y plantas a nivel mundial. La Lista Roja asigna a las especies una de las siguientes categorías:\n\nEX (Extinta)\nEW (Extinta en estado silvestre)\nCR (En peligro crítico de extinción)\nEN (En peligro de extinción)\nVU (Vulnerable)\nNT (Casi amenazada)\nLC (Preocupación menor)\nDD (Datos insuficientes)\nNE (No evaluada)",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#entregables",
    "href": "tarea-04-grupo-001.html#entregables",
    "title": "Tarea 4 - Grupo 001",
    "section": "Entregables",
    "text": "Entregables\nDebe entregar dos direcciones web:\n\nDirección de un repositorio en GitHub (ej. https://github.com/mfvargas/reptiles-costarica) con el código fuente y los datos. Específicamente, el repositorio debe contener:\n\nUn documento Quarto llamado index.qmd con el código en R y la sintaxis Markdown necesarios para generar un tablero de control con las salidas especificadas en la sección Desarrollo.\nUn documento llamado index.html generado a partir de index.qmd.\nLos tres archivos de datos.\nEl directorio index_files.\n\nDirección de un sitio web en GitHub Pages publicado a partir del repositorio GitHub del punto 1 de esta sección (ej. https://mfvargas.github.io/reptiles-costarica/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#desarrollo",
    "href": "tarea-04-grupo-001.html#desarrollo",
    "title": "Tarea 4 - Grupo 001",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl tablero de control desarrollado en Quarto Dashboards debe contener las siguientes visualizaciones de datos.\n\n1 - Tabla de cantidad de registros de presencia por categoría de Lista Roja\nDebe ser una tabla interactiva generada con el paquete DT con una fila por categoría y dos columnas:\n\nAbreviatura de la categoría (EX, EW, CR, etc.).\nCantidad de registros de presencia de especies de reptiles en la categoría.\n\nLos encabezados de la tabla deben estar en español y ser significativos.\nSugerencias\n\nUna la columna iucnRedListCategory, del conjunto de datos de especies, al conjunto de datos de registros de presencia. Use una función de unión (join) no espacial, con la columna species que ambos conjuntos de datos tienen en común.\nUse el argumento colnames de la función datatable() para especificar los encabezados de las columnas.\n\n\n\n2 - Gráfico de barras de cantidad de registros de presencia de las clases Squamata (lagartos y serpientes), Testudines (tortugas) y Crocodylia (cocodrilos y caimanes)\nDebe contener una barra por cada clase (columna class) mencionada y su longitud debe mostrar la cantidad de registros de presencia en esa clase. Las barras deben estar ordenadas por longitud (de mayor a menor o de menor a mayor).\nEl gráfico deben programarse con ggplot2 y convertirse a plotly con la función ggplotly(). Debe tener:\n\nTítulo (puede asignarlo directamente en el gráfico o con la opción #| title del bloque de código).\nEtiquetas en los ejes x e y.\n\n\n\n3 - Mapa de riqueza de especies de la familia Iguanidae (iguanas y garrobos) en regiones socioeconómicas\nDebe ser un mapa leaflet interactivo con las siguientes capas y controles:\n\nDos capas base de tipo tiles (teselas) (ej. OSM, Carto, ESRI).\nUna capa de regiones socioeconómicas (polígonos) coloreada de acuerdo con la riqueza de especies (i.e. cantidad de especies) de Iguanidae en cada región socioeconómica (i.e. un mapa de coropletas). Al hacer clic sobre un polígono, la ventana emergente debe mostrar el nombre de la región y la cantidad de especies.\nUna leyenda que muestre el significado de los colores usados en la capa de regiones socioeconómicas.\nUn control de capas.\n\n\n\n4 Gráfico de barras de riqueza de especies de la familia Iguanidae en regiones socioeconómicas\nDebe contener una barra por cada región socioeconómica y su longitud debe mostrar su riqueza de especies de Iguanidae. Las barras deben estar ordenadas por longitud (de mayor a menor o de menor a mayor).\nEl gráfico deben programarse con ggplot2 y convertirse a plotly con la función ggplotly(). Debe tener:\n\nTítulo (puede asignarlo directamente en el gráfico o en la opción #| title del bloque de código).\nEtiquetas en los ejes x e y.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#calificación",
    "href": "tarea-04-grupo-001.html#calificación",
    "title": "Tarea 4 - Grupo 001",
    "section": "Calificación",
    "text": "Calificación\n\nPresentación general del tablero de control (organización, distribución de los componentes): 20%\nTabla: 15%\nPrimer gráfico: 20%\nSegundo gráfico: 20%\nMapa: 25%\n\nUtilice todos los recursos que considere necesarios para organizar los componentes en el tablero de control: filas, columnas, páginas, pestañas, etc. Puede colocar los componentes en el orden que considere apropiado.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "tarea-04-grupo-001.html#consideraciones-adicionales",
    "href": "tarea-04-grupo-001.html#consideraciones-adicionales",
    "title": "Tarea 4 - Grupo 001",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\n\nLa tarea debe presentarse como un tablero de control desarrollado en Quarto Dashboards y no como otro tipo de documento.\nEsta tarea puede presentarse individualmente o en parejas. En este último caso, solo un estudiante debe presentar la tarea en Mediación Virtual y debe indicar ahí el nombre del otro estudiante.\nSi solo se entrega la dirección del repositorio en GitHub, y no el sitio publicado o este no es consistente con el código fuente del repositorio, se rebajará el 25% del valor de la tarea. RECOMENDACIÓN: genere el sitio web desde el inicio y actualícelo continuamente. No lo deje para última hora.\nNo se aceptarán tareas que se entreguen después de la fecha y hora límite.",
    "crumbs": [
      "Evaluaciones",
      "Tarea 4 - Grupo 001"
    ]
  },
  {
    "objectID": "16-shiny.html",
    "href": "16-shiny.html",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "",
    "text": "16.1 Resumen\nShiny es un paquete de R que facilita el desarrollo de aplicaciones web interactivas. Las aplicaciones shiny se componen de una interfaz de usuario y de un servidor. En la interfaz de usuario, este puede realizar operaciones como filtros, búsquedas y ordenamientos de datos, entre otras. El servidor se encarga de procesar los datos de acuerdo con los parámetros especificados y de retornar los resultados a la interfaz de usuario.\nAdemás de los bloques de código en R para la interfaz de usuario y el servidor, shiny proporciona bloques para compartir código y datos. También para personalizar la interfaz de usuario.\nLas funciones reactivas de shiny se ejecutan cada vez que el usuario cambia los controles de la interfaz, lo que permite a las aplicaciones shiny responder dinámicamente a las entradas del usuario.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#trabajo-previo",
    "href": "16-shiny.html#trabajo-previo",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.2 Trabajo previo",
    "text": "16.2 Trabajo previo\n\n16.2.1 Lecturas\nQuarto - Dashboards with Shiny for R. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/dashboards/interactivity/shiny-r.html\n\n\n16.2.2 Instalación y carga de paquetes\n\n# Instalación de shiny\ninstall.packages(\"shiny\")\n\n# Instalación de rsconnect\ninstall.packages(\"rsconnect\")\n\n\n# Carga de paquetes\nlibrary(shiny)\nlibrary(rsconnect)",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#introducción",
    "href": "16-shiny.html#introducción",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.3 Introducción",
    "text": "16.3 Introducción\nEn una aplicación interactiva, el usuario puede configurar las salidas, usualmente mediante una interfaz que le permite realizar operaciones como filtros, búsquedas y ordenamientos, entre otras. Shiny es un paquete de R que facilita el desarrollo de este tipo de aplicaciones.\nLas aplicaciones shiny requieren un servidor, el cual es un proceso que puede alojarse en cualquier computador habilitado para ejecutar código en R (o Python) como, por ejemplo, la estación de trabajo del programador (esta opción se usa principalmente para efectos de desarrollo y pruebas), un servidor ubicado en la red de una organización o un servidor en la nube (ej. shinyapps.io, Posit Connect, Posit Cloud).\nPara ejemplos de aplicaciones shiny, puede visitar la siguiente galería.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#arquitectura",
    "href": "16-shiny.html#arquitectura",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.4 Arquitectura",
    "text": "16.4 Arquitectura\nUna aplicación shiny tiene dos componentes principales:\n\nInterfaz de usuario: despliega controles de entrada y salida (widgets), los cuales eventualente convierte a Lenguaje de Marcado de Hipertexto (HTML).\n\nWidgets de entrada: campos de texto, listas de selección, botones de radio, etc.\nWidgets de salida: tablas, gráficos, mapas, etc. Muchos de estos controles están incluídos en los paquetes que generan los diferentes tipos de salidas (ej. DT, plotly, leaflet).\n\nServidor: es un proceso que recibe las entradas y realiza el procesamiento necesario para generar las salidas y retornar los resultados a la interfaz de usuario.\n\nPara más información sobre la arquitectura de aplicaciones shiny, se recomienda leer The Anatomy of a Shiny Application.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#ejemplo-de-aplicación-básica",
    "href": "16-shiny.html#ejemplo-de-aplicación-básica",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.5 Ejemplo de aplicación básica",
    "text": "16.5 Ejemplo de aplicación básica\nEl siguiente documento Quarto contiene una aplicación shiny con un tablero de control interactivo para el conjunto de datos diamonds. Esta aplicación se incluye como ejemplo en https://quarto.org/docs/dashboards/interactivity/shiny-r.html. Puede acceder al ejecutable en https://mfvargas.shinyapps.io/2024-i-tablero-interactivo-diamantes/.\n---\ntitle: \"Diamonds Explorer\"\nauthor: \"Barkamian Analytics\"\nformat: dashboard\nserver: shiny\n---\n\n```{r}\n#| context: setup\nlibrary(ggplot2)\ndataset &lt;- diamonds\n```\n\n# {.sidebar}\n\n```{r}\nsliderInput('sampleSize', 'Sample Size', \n            min=1, max=nrow(dataset),\n            value=min(1000, nrow(dataset)), \n            step=500, round=0)\nbr()\ncheckboxInput('jitter', 'Jitter')\ncheckboxInput('smooth', 'Smooth')\n```\n\n```{r}\nselectInput('x', 'X', names(dataset)) \nselectInput('y', 'Y', names(dataset), names(dataset)[[2]])\nselectInput('color', 'Color', c('None', names(dataset)))\n```\n\n```{r}\nselectInput('facet_row', 'Facet Row',\n  c(None='.', names(diamonds[sapply(diamonds, is.factor)])))\nselectInput('facet_col', 'Facet Column',\n  c(None='.', names(diamonds[sapply(diamonds, is.factor)])))\n```\n\n# Plot\n\n```{r}\nplotOutput('plot')\n```\n\n# Data\n\n```{r}\ntableOutput('data')\n```\n\n```{r}\n#| context: server\n\ndataset &lt;- reactive({\n  diamonds[sample(nrow(diamonds), input$sampleSize),]\n})\n \noutput$plot &lt;- renderPlot({\n  \n  p &lt;- ggplot(\n    dataset(), \n    aes_string(x=input$x, y=input$y)) + geom_point()\n  \n  if (input$color != 'None')\n    p &lt;- p + aes_string(color=input$color)\n  \n  facets &lt;- paste(input$facet_row, '~', input$facet_col)\n  if (facets != '. ~ .')\n    p &lt;- p + facet_grid(facets)\n  \n  if (input$jitter)\n    p &lt;- p + geom_jitter()\n  if (input$smooth)\n    p &lt;- p + geom_smooth()\n  \n  p\n  \n})\n\noutput$data &lt;- renderTable({\n  dataset()\n})\n```\nEs de vital importancia comprender que el último bloque de código (con la opción #| context: server) se ejecuta en una sesión separada de R. Esto implica que no es posible, en principio, acceder desde ese bloque variables definidas en otros bloques, ni viceversa. Sin embargo, existen varias estrategias para compartir código, como las que se detallan en Sharing Code y que se detallan en secciones siguientes de este documento.\nUna forma en la que la interfaz de usuario y el servidor pueden comunicarse, es a través de las listas input y output.\n\ninput contiene la lista de widgets de entrada (listas de selección, campos de entrada de texto, botones de radio, etc.). Cada uno de estos widgets tiene un inputId único. En el ejemplo, “sampleSize” es el inputId del widget tipo sliderInput. Se referencia como input$sampleSize en el bloque del servidor.\noutput es una lista de componentes que se crean o modifican en el servidor (tablas, gráficos, mapas, etc). y que luego se envían a la interfaz de usuario para su visualización. Para crear o modificar un elemento de output, se utiliza una función render*, y para mostrarlo en la interfaz de usuario, se utiliza una función *Output. En el ejemplo, output$plot es un gráfico que se crea con la función renderPlot() en función de los valores de los widgets de entrada.\n\nNótese que hay diferencias importantes entre este documento y otros documentos Quarto:\n\nLa opción server: shiny: en la sección YAML, la cual le indica a Quarto que debe iniciar un servidor Shiny.\nLa opción context: server: en el último bloque de código, la cual indica que ese bloque debe ejecutarse en el servidor.\n\nExisten otros posibles valores de context para los bloques de código en aplicaciones shiny, los cuales permiten compartir código y datos.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#bloques-para-compartir-código-y-datos",
    "href": "16-shiny.html#bloques-para-compartir-código-y-datos",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.6 Bloques para compartir código y datos",
    "text": "16.6 Bloques para compartir código y datos\nComo puede apreciarse en el ejemplo anterior, las aplicaciones shiny pueden contener bloques de código que se ejecutan en tiempo de despliegue (rendering) de la interfaz de usuario y también bloques que se ejecutan en el servidor en respuesta a las acciones del usuario y a los cambios en los valores de entrada. Estos tipos de bloques se identifican respectivamente mediante las opciones context: render (valor por defecto de context) y context: server.\nExisten también otros tipos de bloques, los cuales permiten compartir código y datos.\n\n16.6.1 context: setup\nEl código de este tipo de bloques se ejecuta tanto en el contexto de la interfaz de usuario como del servidor. Puede usarse para operaciones que se ejecutan al inicio de una aplicación, como la carga de paquetes.\n```{r}\n#| label: inicio\n#| context: setup\n#| message: false\n\n# Carga de paquetes\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(sf)\n```\n\n\n16.6.2 context: data\nSe utiliza para cargar datos que deben compartirse entre todos los bloques de código. Por ejemplo:\n```{r}\n#| label: lectura-datos\n#| context: data\n\n# Lectura de archivo CSV\nfelidos &lt;-\n  st_read(\n    dsn = \"felidos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\",\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"\n    ),\n    quiet = TRUE\n  )\n```",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#bloques-para-configurar-la-interfaz-de-usuario",
    "href": "16-shiny.html#bloques-para-configurar-la-interfaz-de-usuario",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.7 Bloques para configurar la interfaz de usuario",
    "text": "16.7 Bloques para configurar la interfaz de usuario\nPor defecto, los widgets que componen la interfaz de usuario se distribuyen automáticamente en la pantalla, usualmente de arriba hacia abajo. Las opciones panel: sidebar y panel: fill, entre otras, permiten personalizar la ubicación de los widgets.\nPara utilizar estas opciones, es necesario especificar page-layout: custom en la sección de YAML. Por ejemplo:\n---\ntitle: \"Félidos de Costa Rica\"\nformat: \n  html:\n    theme: cosmo\n    page-layout: custom\nserver: shiny\n---\n\n16.7.1 panel: sidebar\nSe utiliza para desplegar un panel lateral como, por ejemplo, para widgets de entrada de datos (ej. listas de selección, campos de entrada de texto, botones de radio). Por ejemplo:\n```{r}\n#| panel: sidebar\n\n# Vector ordenado de especies\nlista_especies &lt;- unique(felidos$species)\nlista_especies &lt;- sort(lista_especies)\nlista_especies &lt;- c(\"Todas\", lista_especies)\n\n# Selector de especies\nselectInput(\n  inputId = \"especie\",\n  label = \"Especie\",\n  choices = lista_especies,\n  selected = \"Todas\"\n)\n```\nUn bloque de este tipo debe ir acompañado de otro de tipo panel: fill o panel: center.\n\n\n16.7.2 panel: fill y panel: center\nEstos bloques rellenan el espacio que queda disponible luego de desplegar un bloque del tipo panel: sidebar. Los bloques panel: center incluyen un margen horizontal alrededor del contenido. Pueden emplearse para desplegar salidas como tablas, gráficos y mapas. Por ejemplo:\n```{r}\n#| panel: fill\n\n# Tabla interactiva\ndataTableOutput(\"tabla\")\n```\n\n\n16.7.3 Funciones reactivas\nSon funciones especiales que se ejecutan cada vez que cambia uno de los datos que utiliza como entrada, como un widget de la interfaz de usuario. En el siguiente bloque de código se define una función reactiva que utiliza el valor especificado por el usuario en una lista de selección para filtrar un conjunto de datos.\n```{r}\n# Función reactiva para filtrar los registros de presencia de félidos\n# de acuerdo con el valor de una lista de selección\nfiltrar_felidos &lt;- reactive({\n  # Valor inicial del objeto que va a retornarse\n  felidos_filtrados &lt;- felidos\n  \n  if (input$especie != \"Todas\") {\n    felidos_filtrados &lt;-\n      felidos_filtrados |&gt;\n      filter(species == input$especie)\n  }\n\n  return(felidos_filtrados)\n})  \n```\nLas funciones reactivas permiten a las aplicaciones shiny responder dinámicamente a las entradas del usuario.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#ejercicios",
    "href": "16-shiny.html#ejercicios",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.9 Ejercicios",
    "text": "16.9 Ejercicios\n\nEjecute en su computadora el código del tablero de control sobre diamantes mostrado anteriormente.\n\nCree un proyecto en RStudio.\nCree un documento Quarto.\nCopie en el nuevo documento el código de la aplicación.\nEjecute el documento con el botón Run Document.\n\nPublique el tablero de control en shinyapps.io (puede consultar Quarto - Running Documents y How to Deploy R Shiny App for Free on Shinyapps.io).\n\nCree una cuenta en shinyapps.io.\nObtenga su token de autenticación de shinyapps.io en Accounts - Tokens - Show- Show secret - Copy to clipboard.\nEjecute la aplicación en su computadora y publíquela en shinyapps.io con el botón Publish. Elija la opción shinyapps.io e ingrese el token cuando se le solicite. Debe seleccionar todos los archivos requeridos para que su aplicación funciones (archivos .qmd, archivos .html, archivos de datos, etc).\n\nEjecute en su computadora y luego publique en shinyapps.io la aplicación Iris K-Means Clustering.\nEstudie el resto de los ejemplos en Quarto - Shiny - Examples.\nCree una aplicación shiny para el conjunto de datos de registros de presencia de félidos de Costa Rica, y publíquela en shinyapps.io, con los siguientes componentes:\n\nUna lista de selección de especies.\nUna tabla DT que muestre los registros de la especie seleccionada en la lista.\nUn gráfico ggplot2-plotly de barras que muestre la cantidad de registros por mes de la especie seleccionada en la lista.\nUn mapa leaflet que muestre la ubicación de los registros de la especie seleccionada en la lista.\n\n\nPuede encontrar una solución parcial en https://github.com/gf0604-procesamientodatosgeograficos/2024-i-tablero-interactivo-felidos.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#recursos-de-interés",
    "href": "16-shiny.html#recursos-de-interés",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.10 Recursos de interés",
    "text": "16.10 Recursos de interés\nQuarto - Running Documents. (s. f.). Recuperado 20 de noviembre de 2022, de https://quarto.org/docs/interactive/shiny/running.html\nShiny. (s. f.). Recuperado 20 de noviembre de 2022, de https://shiny.rstudio.com/\nShiny - Gallery. (s. f.). Recuperado 20 de noviembre de 2022, de https://shiny.rstudio.com/gallery/\nThe Anatomy of a Shiny Application | R-bloggers. (2021). Recuperado 21 de noviembre de 2022, de https://www.r-bloggers.com/2021/04/the-anatomy-of-a-shiny-application/\n1littlecoder. (2020). How to Deploy R Shiny App for Free on Shinyapps.io. https://www.youtube.com/watch?v=2QstfyGX4ZU",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#configuración-de-la-interfaz-de-usuario",
    "href": "16-shiny.html#configuración-de-la-interfaz-de-usuario",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.7 Configuración de la interfaz de usuario",
    "text": "16.7 Configuración de la interfaz de usuario\n\n16.7.1 Barras laterales\nLas barras laterales o sidebars se utilizan generalmente para colocar widgets de entrada. Para incluir una barra lateral, se agrega la clase .sidebar a un encabezado de nivel 2. Por ejemplo:\n# {.sidebar}\n\n```{r}\nsliderInput('sampleSize', 'Sample Size', \n            min=1, max=nrow(dataset),\n            value=min(1000, nrow(dataset)), \n            step=500, round=0)\nbr()\ncheckboxInput('jitter', 'Jitter')\ncheckboxInput('smooth', 'Smooth')\n```\n\n```{r}\nselectInput('x', 'X', names(dataset)) \nselectInput('y', 'Y', names(dataset), names(dataset)[[2]])\nselectInput('color', 'Color', c('None', names(dataset)))\n```\n\n```{r}\nselectInput('facet_row', 'Facet Row',\n  c(None='.', names(diamonds[sapply(diamonds, is.factor)])))\nselectInput('facet_col', 'Facet Column',\n  c(None='.', names(diamonds[sapply(diamonds, is.factor)])))\n```\nPuede consultar sobre más recursos para configurar el tablero en https://quarto.org/docs/dashboards/inputs.html.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  },
  {
    "objectID": "16-shiny.html#funciones-reactivas",
    "href": "16-shiny.html#funciones-reactivas",
    "title": "16  shiny - desarrollo de aplicaciones web interactivas",
    "section": "16.8 Funciones reactivas",
    "text": "16.8 Funciones reactivas\nSon funciones especiales que se ejecutan cada vez que cambia uno de los datos que utiliza como entrada, como un widget de la interfaz de usuario. En el siguiente bloque de código se define una función reactiva que utiliza el valor especificado por el usuario en una lista de selección para filtrar un conjunto de datos.\n```{r}\n# Función reactiva para filtrar los registros de presencia de félidos\n# de acuerdo con el valor de una lista de selección\nfiltrar_felidos &lt;- reactive({\n  # Valor inicial del objeto que va a retornarse\n  felidos_filtrados &lt;- felidos\n  \n  if (input$especie != \"Todas\") {\n    felidos_filtrados &lt;-\n      felidos_filtrados |&gt;\n      filter(species == input$especie)\n  }\n\n  return(felidos_filtrados)\n})  \n```\nLas funciones reactivas permiten a las aplicaciones shiny responder dinámicamente a las entradas del usuario.",
    "crumbs": [
      "VI - Visualización avanzada",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>shiny - desarrollo de aplicaciones web interactivas</span>"
    ]
  }
]